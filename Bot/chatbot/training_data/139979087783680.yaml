categories:
- StackOverflow
- C++
conversations:
- - Why is it faster to process a sorted array than an unsorted array?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p><strong>You are a victim of <a\
    \ href=\"//en.wikipedia.org/wiki/Branch_predictor\" rel=\"noreferrer\">branch\
    \ prediction</a> fail.</strong></p>\n<hr/>\n<h2>What is Branch Prediction?</h2>\n\
    <p>Consider a railroad junction:</p>\n<p><a href=\"//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG\"\
    \ rel=\"noreferrer\"><img alt=\"Licensed Image\" src=\"https://i.stack.imgur.com/muxnt.jpg\"\
    /></a>\n<sub><a href=\"//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG\"\
    \ rel=\"noreferrer\">Image</a> by Mecanismo, via Wikimedia Commons. Used under\
    \ the <a href=\"//creativecommons.org/licenses/by-sa/3.0/deed.en\" rel=\"noreferrer\"\
    >CC-By-SA 3.0</a> license.</sub></p>\n<p>Now for the sake of argument, suppose\
    \ this is back in the 1800s - before long distance or radio communication.</p>\n\
    <p>You are the operator of a junction and you hear a train coming. You have no\
    \ idea which way it is supposed to go. You stop the train to ask the driver which\
    \ direction they want. And then you set the switch appropriately.</p>\n<p><em>Trains\
    \ are heavy and have a lot of inertia. So they take forever to start up and slow\
    \ down.</em></p>\n<p>Is there a better way? You guess which direction the train\
    \ will go!</p>\n<ul>\n<li>If you guessed right, it continues on.</li>\n<li>If\
    \ you guessed wrong, the captain will stop, back up, and yell at you to flip the\
    \ switch. Then it can restart down the other path.</li>\n</ul>\n<p><strong>If\
    \ you guess right every time</strong>, the train will never have to stop.<br/>\n\
    <strong>If you guess wrong too often</strong>, the train will spend a lot of time\
    \ stopping, backing up, and restarting.</p>\n<hr/>\n<p><strong>Consider an if-statement:</strong>\
    \ At the processor level, it is a branch instruction:</p>\n<p><img alt=\"image2\"\
    \ src=\"https://i.stack.imgur.com/pyfwC.png\"/></p>\n<p>You are a processor and\
    \ you see a branch. You have no idea which way it will go. What do you do? You\
    \ halt execution and wait until the previous instructions are complete. Then you\
    \ continue down the correct path.</p>\n<p><em>Modern processors are complicated\
    \ and have long pipelines. So they take forever to \"warm up\" and \"slow down\"\
    .</em></p>\n<p>Is there a better way? You guess which direction the branch will\
    \ go!</p>\n<ul>\n<li>If you guessed right, you continue executing.</li>\n<li>If\
    \ you guessed wrong, you need to flush the pipeline and roll back to the branch.\
    \ Then you can restart down the other path.</li>\n</ul>\n<p><strong>If you guess\
    \ right every time</strong>, the execution will never have to stop.<br/>\n<strong>If\
    \ you guess wrong too often</strong>, you spend a lot of time stalling, rolling\
    \ back, and restarting.</p>\n<hr/>\n<p>This is branch prediction. I admit it's\
    \ not the best analogy since the train could just signal the direction with a\
    \ flag. But in computers, the processor doesn't know which direction a branch\
    \ will go until the last moment.</p>\n<p>So how would you strategically guess\
    \ to minimize the number of times that the train must back up and go down the\
    \ other path? You look at the past history! If the train goes left 99% of the\
    \ time, then you guess left. If it alternates, then you alternate your guesses.\
    \ If it goes one way every 3 times, you guess the same...</p>\n<p><strong><em>In\
    \ other words, you try to identify a pattern and follow it.</em></strong> This\
    \ is more or less how branch predictors work.</p>\n<p>Most applications have well-behaved\
    \ branches. So modern branch predictors will typically achieve &gt;90% hit rates.\
    \ But when faced with unpredictable branches with no recognizable patterns, branch\
    \ predictors are virtually useless.</p>\n<p>Further reading: <a href=\"//en.wikipedia.org/wiki/Branch_predictor\"\
    \ rel=\"noreferrer\">\"Branch predictor\" article on Wikipedia</a>.</p>\n<hr/>\n\
    <h2>As hinted from above, the culprit is this if-statement:</h2>\n<pre><code>if\
    \ (data[c] &gt;= 128)\n    sum += data[c];\n</code></pre>\n<p>Notice that the\
    \ data is evenly distributed between 0 and 255. \nWhen the data is sorted, roughly\
    \ the first half of the iterations will not enter the if-statement. After that,\
    \ they will all enter the if-statement.</p>\n<p>This is very friendly to the branch\
    \ predictor since the branch consecutively goes the same direction many times.\n\
    Even a simple saturating counter will correctly predict the branch except for\
    \ the few iterations after it switches direction.</p>\n<p><strong>Quick visualization:</strong></p>\n\
    <pre><code>T = branch taken\nN = branch not taken\n\ndata[] = 0, 1, 2, 3, 4, ...\
    \ 126, 127, 128, 129, 130, ... 250, 251, 252, ...\nbranch = N  N  N  N  N  ...\
    \   N    N    T    T    T  ...   T    T    T  ...\n\n       = NNNNNNNNNNNN ...\
    \ NNNNNNNTTTTTTTTT ... TTTTTTTTTT  (easy to predict)\n</code></pre>\n<p>However,\
    \ when the data is completely random, the branch predictor is rendered useless\
    \ because it can't predict random data.\nThus there will probably be around 50%\
    \ misprediction. (no better than random guessing)</p>\n<pre><code>data[] = 226,\
    \ 185, 125, 158, 198, 144, 217, 79, 202, 118,  14, 150, 177, 182, 133, ...\nbranch\
    \ =   T,   T,   N,   T,   T,   T,   T,  N,   T,   N,   N,   T,   T,   T,   N \
    \ ...\n\n       = TTNTTTTNTNNTTTN ...   (completely random - hard to predict)\n\
    </code></pre>\n<hr/>\n<p><strong>So what can be done?</strong></p>\n<p>If the\
    \ compiler isn't able to optimize the branch into a conditional move, you can\
    \ try some hacks if you are willing to sacrifice readability for performance.</p>\n\
    <p>Replace:</p>\n<pre><code>if (data[c] &gt;= 128)\n    sum += data[c];\n</code></pre>\n\
    <p>with:</p>\n<pre><code>int t = (data[c] - 128) &gt;&gt; 31;\nsum += ~t &amp;\
    \ data[c];\n</code></pre>\n<p>This eliminates the branch and replaces it with\
    \ some bitwise operations.</p>\n<p><sub>(Note that this hack is not strictly equivalent\
    \ to the original if-statement. But in this case, it's valid for all the input\
    \ values of <code>data[]</code>.)</sub></p>\n<p><strong>Benchmarks: Core i7 920\
    \ @ 3.5 GHz</strong></p>\n<p>C++ - Visual Studio 2010 - x64 Release</p>\n<pre><code>//\
    \  Branch - Random\nseconds = 11.777\n\n//  Branch - Sorted\nseconds = 2.352\n\
    \n//  Branchless - Random\nseconds = 2.564\n\n//  Branchless - Sorted\nseconds\
    \ = 2.587\n</code></pre>\n<p>Java - Netbeans 7.1.1 JDK 7 - x64</p>\n<pre><code>//\
    \  Branch - Random\nseconds = 10.93293813\n\n//  Branch - Sorted\nseconds = 5.643797077\n\
    \n//  Branchless - Random\nseconds = 3.113581453\n\n//  Branchless - Sorted\n\
    seconds = 3.186068823\n</code></pre>\n<p>Observations:</p>\n<ul>\n<li><strong>With\
    \ the Branch:</strong> There is a huge difference between the sorted and unsorted\
    \ data.</li>\n<li><strong>With the Hack:</strong> There is no difference between\
    \ sorted and unsorted data.</li>\n<li>In the C++ case, the hack is actually a\
    \ tad slower than with the branch when the data is sorted.</li>\n</ul>\n<p>A general\
    \ rule of thumb is to avoid data-dependent branching in critical loops. (such\
    \ as in this example)</p>\n<hr/>\n<p><strong>Update:</strong></p>\n<ul>\n<li><p>GCC\
    \ 4.6.1 with <code>-O3</code> or <code>-ftree-vectorize</code> on x64 is able\
    \ to generate a conditional move. So there is no difference between the sorted\
    \ and unsorted data - both are fast.</p></li>\n<li><p>VC++ 2010 is unable to generate\
    \ conditional moves for this branch even under <code>/Ox</code>.</p></li>\n<li><p>Intel\
    \ Compiler 11 does something miraculous. It <a href=\"//en.wikipedia.org/wiki/Loop_interchange\"\
    \ rel=\"noreferrer\">interchanges the two loops</a>, thereby hoisting the unpredictable\
    \ branch to the outer loop. So not only is it immune the mispredictions, it is\
    \ also twice as fast as whatever VC++ and GCC can generate! In other words, ICC\
    \ took advantage of the test-loop to defeat the benchmark...</p></li>\n<li><p>If\
    \ you give the Intel Compiler the branchless code, it just out-right vectorizes\
    \ it... and is just as fast as with the branch (with the loop interchange).</p></li>\n\
    </ul>\n<p>This goes to show that even mature modern compilers can vary wildly\
    \ in their ability to optimize code...</p>\n</div>"
- - Why is it faster to process a sorted array than an unsorted array?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p><strong>Branch prediction.</strong></p>\n\
    <p>With a sorted array, the condition <code>data[c] &gt;= 128</code> is first\
    \ <code>false</code> for a streak of values, then becomes <code>true</code> for\
    \ all later values. That's easy to predict. With an unsorted array, you pay for\
    \ the branching cost.</p>\n</div>"
- - Why is it faster to process a sorted array than an unsorted array?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>The reason why performance improves\
    \ drastically when the data is sorted is that the branch prediction penalty is\
    \ removed, as explained beautifully in <a href=\"https://stackoverflow.com/users/922184/mysticial\"\
    >Mysticial</a>'s answer.</p>\n<p>Now, if we look at the code</p>\n<pre><code>if\
    \ (data[c] &gt;= 128)\n    sum += data[c];\n</code></pre>\n<p>we can find that\
    \ the meaning of this particular <code>if... else...</code> branch is to add something\
    \ when a condition is satisfied. This type of branch can be easily transformed\
    \ into a <strong>conditional move</strong> statement, which would be compiled\
    \ into a conditional move instruction: <code>cmovl</code>, in an <code>x86</code>\
    \ system. The branch and thus the potential branch prediction penalty is removed.</p>\n\
    <p>In <code>C</code>, thus <code>C++</code>, the statement, which would compile\
    \ directly (without any optimization) into the conditional move instruction in\
    \ <code>x86</code>, is the ternary operator <code>... ? ... : ...</code>. So we\
    \ rewrite the above statement into an equivalent one:</p>\n<pre><code>sum += data[c]\
    \ &gt;=128 ? data[c] : 0;\n</code></pre>\n<p>While maintaining readability, we\
    \ can check the speedup factor.</p>\n<p>On an Intel <a href=\"http://en.wikipedia.org/wiki/Intel_Core#Core_i7\"\
    \ rel=\"noreferrer\">Core i7</a>-2600K @ 3.4 GHz and Visual Studio 2010 Release\
    \ Mode, the benchmark is (format copied from Mysticial):</p>\n<p><strong>x86</strong></p>\n\
    <pre><code>//  Branch - Random\nseconds = 8.885\n\n//  Branch - Sorted\nseconds\
    \ = 1.528\n\n//  Branchless - Random\nseconds = 3.716\n\n//  Branchless - Sorted\n\
    seconds = 3.71\n</code></pre>\n<p><strong>x64</strong></p>\n<pre><code>//  Branch\
    \ - Random\nseconds = 11.302\n\n//  Branch - Sorted\n seconds = 1.830\n\n//  Branchless\
    \ - Random\nseconds = 2.736\n\n//  Branchless - Sorted\nseconds = 2.737\n</code></pre>\n\
    <p>The result is robust in multiple tests. We get a great speedup when the branch\
    \ result is unpredictable, but we suffer a little bit when it is predictable.\
    \ In fact, when using a conditional move, the performance is the same regardless\
    \ of the data pattern.</p>\n<p>Now let's look more closely by investigating the\
    \ <code>x86</code> assembly they generate. For simplicity, we use two functions\
    \ <code>max1</code> and <code>max2</code>.</p>\n<p><code>max1</code> uses the\
    \ conditional branch <code>if... else ...</code>:</p>\n<pre><code>int max1(int\
    \ a, int b) {\n    if (a &gt; b)\n        return a;\n    else\n        return\
    \ b;\n}\n</code></pre>\n<p><code>max2</code> uses the ternary operator <code>...\
    \ ? ... : ...</code>:</p>\n<pre><code>int max2(int a, int b) {\n    return a &gt;\
    \ b ? a : b;\n}\n</code></pre>\n<p>On a x86-64 machine, <code>GCC -S</code> generates\
    \ the assembly below.</p>\n<pre><code>:max1\n    movl    %edi, -4(%rbp)\n    movl\
    \    %esi, -8(%rbp)\n    movl    -4(%rbp), %eax\n    cmpl    -8(%rbp), %eax\n\
    \    jle     .L2\n    movl    -4(%rbp), %eax\n    movl    %eax, -12(%rbp)\n  \
    \  jmp     .L4\n.L2:\n    movl    -8(%rbp), %eax\n    movl    %eax, -12(%rbp)\n\
    .L4:\n    movl    -12(%rbp), %eax\n    leave\n    ret\n\n:max2\n    movl    %edi,\
    \ -4(%rbp)\n    movl    %esi, -8(%rbp)\n    movl    -4(%rbp), %eax\n    cmpl \
    \   %eax, -8(%rbp)\n    cmovge  -8(%rbp), %eax\n    leave\n    ret\n</code></pre>\n\
    <p><code>max2</code> uses much less code due to the usage of instruction <code>cmovge</code>.\
    \ But the real gain is that <code>max2</code> does not involve branch jumps, <code>jmp</code>,\
    \ which would have a significant performance penalty if the predicted result is\
    \ not right.</p>\n<p>So why does a conditional move perform better?</p>\n<p>In\
    \ a typical <code>x86</code> processor, the execution of an instruction is divided\
    \ into several stages. Roughly, we have different hardware to deal with different\
    \ stages. So we do not have to wait for one instruction to finish to start a new\
    \ one. This is called <strong><a href=\"http://en.wikipedia.org/wiki/Pipeline_%28computing%29\"\
    \ rel=\"noreferrer\">pipelining</a></strong>.</p>\n<p>In a branch case, the following\
    \ instruction is determined by the preceding one, so we cannot do pipelining.\
    \ We have to either wait or predict.</p>\n<p>In a conditional move case, the execution\
    \ conditional move instruction is divided into several stages, but the earlier\
    \ stages like <code>Fetch</code> and <code>Decode</code> does not depend on the\
    \ result of the previous instruction; only latter stages need the result. Thus,\
    \ we wait a fraction of one instruction's execution time. This is why the conditional\
    \ move version is slower than the branch when prediction is easy.</p>\n<p>The\
    \ book <em><a href=\"https://rads.stackoverflow.com/amzn/click/com/0136108040\"\
    \ rel=\"noreferrer\">Computer Systems: A Programmer's Perspective, second edition</a></em>\
    \ explains this in detail. You can check Section 3.6.6 for <em>Conditional Move\
    \ Instructions</em>, entire Chapter 4 for <em>Processor Architecture</em>, and\
    \ Section 5.11.2 for a special treatment for <em>Branch Prediction and Misprediction\
    \ Penalties</em>.</p>\n<p>Sometimes, some modern compilers can optimize our code\
    \ to assembly with better performance, sometimes some compilers can't (the code\
    \ in question is using Visual Studio's native compiler). Knowing the performance\
    \ difference between branch and conditional move when unpredictable can help us\
    \ write code with better performance when the scenario gets so complex that the\
    \ compiler can not optimize them automatically.</p>\n</div>"
- - What is the “-->” operator in C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p><code>--&gt;</code> is not an\
    \ operator. It is in fact two separate operators, <code>--</code> and <code>&gt;</code>.</p>\n\
    <p>The conditional's code decrements <code>x</code>, while returning <code>x</code>'s\
    \ original (not decremented) value, and then compares the original value with\
    \ <code>0</code> using the <code>&gt;</code> operator.</p>\n<p><strong>To better\
    \ understand, the statement could be written as follows:</strong></p>\n<pre><code>while(\
    \ (x--) &gt; 0 )\n</code></pre>\n</div>"
- - What is the “-->” operator in C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Or for something completely different...\
    \ x slides to 0</p>\n<pre><code>while (x --\\\n            \\\n             \\\
    \n              \\\n               &gt; 0)\n     printf(\"%d \", x);\n</code></pre>\n\
    <p>Not so mathematical, but... every picture paints a thousand words...</p>\n\
    </div>"
- - What is the “-->” operator in C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>That's a very complicated operator,\
    \ so even <a href=\"https://isocpp.org/std/the-committee\" rel=\"noreferrer\"\
    >ISO/IEC JTC1 (Joint Technical Committee 1)</a> placed its description in two\
    \ different parts of the C++ Standard.</p>\n<p>Joking aside, they are two different\
    \ operators: <code>--</code> and <code>&gt;</code> described respectively in §5.2.6/2\
    \ and §5.9 of the C++03 Standard.</p>\n</div>"
- - The Definitive C++ Book Guide and List
  - "<div class=\"post-text\" itemprop=\"text\">\n<h2>Beginner</h2>\n<h3>Introductory,\
    \ no previous programming experience</h3>\n<ul>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0321714113\"\
    \ rel=\"noreferrer\"><em>C++ Primer</em></a> * (Stanley Lippman, Josée Lajoie,\
    \ and Barbara E. Moo)  (<strong>updated for C++11</strong>) Coming at 1k pages,\
    \ this is a very thorough introduction into C++ that covers just about everything\
    \ in the language in a very accessible format and in great detail. The fifth edition\
    \ (released August 16, 2012) covers C++11. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1848\"\
    \ rel=\"noreferrer\">[Review]</a> </p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0321992784\"\
    \ rel=\"noreferrer\"><em>Programming: Principles and Practice Using C++</em></a>\
    \ (Bjarne Stroustrup, 2nd Edition - May 25, 2014) (<strong>updated for C++11/C++14</strong>)\
    \ An introduction to programming using C++ by the creator of the language. A good\
    \ read, that assumes no previous programming experience, but is not only for beginners.\
    \ </p></li>\n</ul>\n<p><sub>\n* Not to be confused with <a href=\"https://rads.stackoverflow.com/amzn/click/com/0672326973\"\
    \ rel=\"noreferrer\"><em>C++ Primer Plus</em></a> (Stephen Prata), with a significantly\
    \ less favorable <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1744\"\
    \ rel=\"noreferrer\">review</a>.\n</sub></p>\n<h3>Introductory, with previous\
    \ programming experience</h3>\n<ul>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/B00F8CWGOS\"\
    \ rel=\"noreferrer\"><em>A Tour of C++</em></a> (Bjarne Stroustrup) (<strong><a\
    \ href=\"http://a.co/f7WPDeD\" rel=\"noreferrer\">2nd edition  for C++17</a></strong>)\
    \ The “tour” is a quick (about 180 pages and 14 chapters) tutorial overview of\
    \ all of standard C++ (language and standard library, <strong>and using C++11</strong>)\
    \ at a moderately high level for people who already know C++ or at least are experienced\
    \ programmers. This book is an extended version of the material that constitutes\
    \ Chapters 2-5 of The C++ Programming Language, 4th edition.</p></li>\n<li><p><a\
    \ href=\"https://rads.stackoverflow.com/amzn/click/com/020170353X\" rel=\"noreferrer\"\
    ><em>Accelerated C++</em></a> (Andrew Koenig and Barbara Moo, 1st Edition - August\
    \ 24, 2000)  This basically covers the same ground as the <em>C++ Primer</em>,\
    \ but does so on a fourth of its space. This is largely because it does not attempt\
    \ to be an introduction to <em>programming</em>, but an introduction to <em>C++</em>\
    \ for people who've previously programmed in some other language. It has a steeper\
    \ learning curve, but, for those who can cope with this, it is a very compact\
    \ introduction to the language. (Historically, it broke new ground by being the\
    \ first beginner's book to use a modern approach to teaching the language.) Despite\
    \ this, the C++\nit teaches is purely C++98. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1185\"\
    \ rel=\"noreferrer\">[Review]</a></p></li>\n</ul>\n<h3>Best practices</h3>\n<ul>\n\
    <li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0321334876\" rel=\"\
    noreferrer\"><em>Effective C++</em></a> (Scott Meyers, 3rd Edition - May 22, 2005)\
    \  This was written with the aim of being the best second book C++ programmers\
    \ should read, and it succeeded. Earlier editions were aimed at programmers coming\
    \ from C, the third edition changes this and targets programmers coming from languages\
    \ like Java. It presents ~50 easy-to-remember rules of thumb along with their\
    \ rationale in a very accessible (and enjoyable) style. For C++11 and C++14 the\
    \ examples and a few issues are outdated and Effective Modern C++ should be preferred.\
    \ <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=700\"\
    \ rel=\"noreferrer\">[Review]</a></p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/1491903996\"\
    \ rel=\"noreferrer\"><em>Effective Modern C++</em></a> (Scott Meyers) This is\
    \ basically the new version of <em>Effective C++</em>, aimed at C++ programmers\
    \ making the transition from C++03 to C++11 and C++14. </p></li>\n<li><a href=\"\
    https://rads.stackoverflow.com/amzn/click/com/0201749629\" rel=\"noreferrer\"\
    ><em>Effective STL</em></a> (Scott Meyers)  This aims to do the same to the part\
    \ of the standard library coming from the STL what <em>Effective C++</em> did\
    \ to the language as a whole: It presents rules of thumb along with their rationale.\
    \ <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=67\"\
    \ rel=\"noreferrer\">[Review]</a></li>\n</ul>\n<hr/>\n<h2>Intermediate</h2>\n\
    <ul>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/020163371X\"\
    \ rel=\"noreferrer\"><em>More Effective C++</em></a> (Scott Meyers) Even more\
    \ rules of thumb than <em>Effective C++</em>. Not as important as the ones in\
    \ the first book, but still good to know.</p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201615622\"\
    \ rel=\"noreferrer\"><em>Exceptional C++</em></a> (Herb Sutter)  Presented as\
    \ a set of puzzles, this has one of the best and thorough discussions of the proper\
    \ resource management and exception safety in C++ through Resource Acquisition\
    \ is Initialization (RAII) in addition to in-depth coverage of a variety of other\
    \ topics including the pimpl idiom, name lookup, good class design, and the C++\
    \ memory model. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=209\"\
    \ rel=\"noreferrer\">[Review]</a></p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/020170434X\"\
    \ rel=\"noreferrer\"><em>More Exceptional C++</em></a> (Herb Sutter)  Covers additional\
    \ exception safety topics not covered in <em>Exceptional C++</em>, in addition\
    \ to discussion of effective object-oriented programming in C++ and correct use\
    \ of the STL. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=784\"\
    \ rel=\"noreferrer\">[Review]</a></p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201760428\"\
    \ rel=\"noreferrer\"><em>Exceptional C++ Style</em></a> (Herb Sutter)  Discusses\
    \ generic programming, optimization, and resource management; this book also has\
    \ an excellent exposition of how to write modular code in C++ by using non-member\
    \ functions and the single responsibility principle. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=107\"\
    \ rel=\"noreferrer\">[Review]</a></p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0321113586\"\
    \ rel=\"noreferrer\"><em>C++ Coding Standards</em></a> (Herb Sutter and Andrei\
    \ Alexandrescu) “Coding standards” here doesn't mean “how many spaces should I\
    \ indent my code?”  This book contains 101 best practices, idioms, and common\
    \ pitfalls that can help you to write correct, understandable, and efficient C++\
    \ code. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1439\"\
    \ rel=\"noreferrer\">[Review]</a></p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201734842\"\
    \ rel=\"noreferrer\"><em>C++ Templates: The Complete Guide</em></a> (David Vandevoorde\
    \ and Nicolai M. Josuttis) This is <em>the</em> book about templates as they existed\
    \ before C++11.  It covers everything from the very basics to some of the most\
    \ advanced template metaprogramming and explains every detail of how templates\
    \ work (both conceptually and at how they are implemented) and discusses many\
    \ common pitfalls.  Has excellent summaries of the One Definition Rule (ODR) and\
    \ overload resolution in the appendices. A <a href=\"https://rads.stackoverflow.com/amzn/click/com/0321714121\"\
    \ rel=\"noreferrer\">second edition</a> covering C++11, C++14 and C++17 has been\
    \ already published . <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=506\"\
    \ rel=\"noreferrer\">[Review]</a></p></li>\n<li><p><a href=\"https://leanpub.com/cpp17/\"\
    \ rel=\"noreferrer\"><em>C++ 17 - The Complete Guide</em></a> (Nicolai M. Josuttis)\
    \ This book describes all the new features introduced in the C++17 Standard covering\
    \ everything from the simple ones like 'Inline Variables', 'constexpr if' all\
    \ the way up to 'Polymorphic Memory Resources' and 'New and Delete with overaligned\
    \ Data'.</p></li>\n</ul>\n<hr/>\n<h2>Advanced</h2>\n<ul>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201704315\"\
    \ rel=\"noreferrer\"><em>Modern C++ Design</em></a> (Andrei Alexandrescu)  A groundbreaking\
    \ book on advanced generic programming techniques.  Introduces policy-based design,\
    \ type lists, and fundamental generic programming idioms then explains how many\
    \ useful design patterns (including small object allocators, functors, factories,\
    \ visitors, and multi-methods) can be implemented efficiently, modularly, and\
    \ cleanly using generic programming. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=979\"\
    \ rel=\"noreferrer\">[Review]</a></p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0321227255\"\
    \ rel=\"noreferrer\"><em>C++ Template Metaprogramming</em></a> (David Abrahams\
    \ and Aleksey Gurtovoy)</p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/1933988770\"\
    \ rel=\"noreferrer\"><em>C++ Concurrency In Action</em></a> (Anthony Williams)\
    \ A book covering C++11 concurrency support including the thread library, the\
    \ atomics library, the C++ memory model, locks and mutexes, as well as issues\
    \ of designing and debugging multithreaded applications.</p></li>\n<li><p><a href=\"\
    https://rads.stackoverflow.com/amzn/click/com/1460966163\" rel=\"noreferrer\"\
    ><em>Advanced C++ Metaprogramming</em></a> (Davide Di Gennaro) A pre-C++11 manual\
    \ of TMP techniques, focused more on practice than theory.  There are a ton of\
    \ snippets in this book, some of which are made obsolete by type traits, but the\
    \ techniques, are nonetheless useful to know.  If you can put up with the quirky\
    \ formatting/editing, it is easier to read than Alexandrescu, and arguably, more\
    \ rewarding.  For more experienced developers, there is a good chance that you\
    \ may pick up something about a dark corner of C++ (a quirk) that usually only\
    \ comes about through extensive experience.</p></li>\n</ul>\n<hr/>\n<h2>Reference\
    \ Style - All Levels</h2>\n<ul>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0321958322\"\
    \ rel=\"noreferrer\"><em>The C++ Programming Language</em></a> (Bjarne Stroustrup)\
    \ (<strong>updated for C++11</strong>) The classic introduction to C++ by its\
    \ creator. Written to parallel the classic K&amp;R, this indeed reads very much\
    \ like it and covers just about everything from the core language to the standard\
    \ library, to programming paradigms to the language's philosophy. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1853\"\
    \ rel=\"noreferrer\">[Review]</a> Note: All releases of the C++ standard are tracked\
    \ in this question: <a href=\"https://stackoverflow.com/a/4653479/14065\">Where\
    \ do I find the current C++ standard</a>.   </p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0321623215\"\
    \ rel=\"noreferrer\"><em>C++ Standard Library Tutorial and Reference</em></a>\
    \ (Nicolai Josuttis) (<strong>updated for C++11</strong>) <em>The</em> introduction\
    \ and reference for the C++ Standard Library. The second edition (released on\
    \ April 9, 2012) covers C++11. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1849\"\
    \ rel=\"noreferrer\">[Review]</a></p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201183951\"\
    \ rel=\"noreferrer\"><em>The C++ IO Streams and Locales</em></a> (Angelika Langer\
    \ and Klaus Kreft)  There's very little to say about this book except that, if\
    \ you want to know anything about streams and locales, then this is the one place\
    \ to find definitive answers. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=200\"\
    \ rel=\"noreferrer\">[Review]</a></p></li>\n</ul>\n<p><strong>C++11/14/17/… References:</strong></p>\n\
    <ul>\n<li><p><em>The C++<a href=\"https://www.iso.org/standard/50372.html\" rel=\"\
    noreferrer\">11</a>/<a href=\"https://www.iso.org/standard/64029.html\" rel=\"\
    noreferrer\">14</a>/<a href=\"https://www.iso.org/standard/68564.html\" rel=\"\
    noreferrer\">17</a> Standard (INCITS/ISO/IEC 14882:2011/2014/2017)</em> This,\
    \ of course, is the final arbiter of all that is or isn't C++. Be aware, however,\
    \ that it is intended purely as a reference for <em>experienced</em> users willing\
    \ to devote considerable time and effort to its understanding. The C++17 standard\
    \ is released in electronic form for 198 Swiss Francs.</p></li>\n<li><p>The C++17\
    \ standard is available, but seemingly not in an economical form – <a href=\"\
    https://www.iso.org/standard/68564.html\" rel=\"noreferrer\">directly from the\
    \ ISO</a> it costs 198 Swiss Francs (about $200 US). For most people, the <a href=\"\
    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"noreferrer\"\
    >final draft before standardization</a> is more than adequate (and free). Many\
    \ will prefer an <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf\"\
    \ rel=\"noreferrer\">even newer draft</a>, documenting new features that are likely\
    \ to be included in C++20.</p></li>\n<li><p><a href=\"http://www.artima.com/shop/overview_of_the_new_cpp\"\
    \ rel=\"noreferrer\"><em>Overview of the New C++ (C++11/14) (PDF only)</em></a>\
    \ (Scott Meyers) (<strong>updated for C++14</strong>) These are the presentation\
    \ materials (slides and some lecture notes) of a three-day training course offered\
    \ by Scott Meyers, who's a highly respected author on C++. Even though the list\
    \ of items is short, the quality is high.</p></li>\n<li><p>The <a href=\"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md\"\
    \ rel=\"noreferrer\"><em>C++ Core Guidelines (C++11/14/17/…)</em></a> (edited\
    \ by Bjarne Stroustrup and Herb Sutter) is an evolving online document consisting\
    \ of a set of guidelines for using modern C++ well. The guidelines are focused\
    \ on relatively higher-level issues, such as interfaces, resource management,\
    \ memory management and concurrency affecting application architecture and library\
    \ design. The project was <a href=\"https://isocpp.org/blog/2015/09/bjarne-stroustrup-announces-cpp-core-guidelines\"\
    \ rel=\"noreferrer\">announced at CppCon'15 by Bjarne Stroustrup and others</a>\
    \ and welcomes contributions from the community. Most guidelines are supplemented\
    \ with a rationale and examples as well as discussions of possible tool support.\
    \ Many rules are designed specifically to be automatically checkable by static\
    \ analysis tools.</p></li>\n<li><p>The <a href=\"https://isocpp.org/faq\" rel=\"\
    noreferrer\"><em>C++ Super-FAQ</em></a> (Marshall Cline, Bjarne Stroustrup and\
    \ others) is an effort by the Standard C++ Foundation to unify the C++ FAQs previously\
    \ maintained individually by Marshall Cline and Bjarne Stroustrup and also incorporating\
    \ new contributions. The items mostly address issues at an intermediate level\
    \ and are often written with a humorous tone. Not all items might be fully up\
    \ to date with the latest edition of the C++ standard yet.</p></li>\n<li><p><a\
    \ href=\"http://en.cppreference.com/\" rel=\"noreferrer\"><em>cppreference.com\
    \ (C++03/11/14/17/…)</em></a> (initiated by Nate Kohl) is a wiki that summarizes\
    \ the basic core-language features and has extensive documentation of the C++\
    \ standard library. The documentation is very precise but is easier to read than\
    \ the official standard document and provides better navigation due to its wiki\
    \ nature. The project documents all versions of the C++ standard and the site\
    \ allows filtering the display for a specific version. The project was <a href=\"\
    https://isocpp.org/blog/2015/07/cppcon-2014-cppreference.com-documenting-cpp-one-edit-at-a-time-nate-kohl\"\
    \ rel=\"noreferrer\">presented by Nate Kohl at CppCon'14</a>.</p></li>\n</ul>\n\
    <hr/>\n<h2>Classics / Older</h2>\n<p><strong>Note:</strong> Some information contained\
    \ within these books may not be up-to-date or no longer considered best practice.</p>\n\
    <ul>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201543303\"\
    \ rel=\"noreferrer\"><em>The Design and Evolution of C++</em></a> (Bjarne Stroustrup)\
    \  If you want to know <em>why</em> the language is the way it is, this book is\
    \ where you find answers. This covers everything <em>before the standardization</em>\
    \ of C++.</p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201423391\"\
    \ rel=\"noreferrer\"><em>Ruminations on C++</em></a> - (Andrew Koenig and Barbara\
    \ Moo) <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=776\"\
    \ rel=\"noreferrer\">[Review]</a></p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201548550\"\
    \ rel=\"noreferrer\"><em>Advanced C++ Programming Styles and Idioms</em></a> (James\
    \ Coplien)  A predecessor of the pattern movement, it describes many C++-specific\
    \ “idioms”. It's certainly a very good book and might still be worth a read if\
    \ you can spare the time, but quite old and not up-to-date with current C++. </p></li>\n\
    <li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201633620\" rel=\"\
    noreferrer\"><em>Large Scale C++ Software Design</em></a> (John Lakos)  Lakos\
    \ explains techniques to manage very big C++ software projects. Certainly, a good\
    \ read, if it only was up to date. It was written long before C++ 98 and misses\
    \ on many features (e.g. namespaces) important for large-scale projects. If you\
    \ need to work in a big C++ software project, you might want to read it, although\
    \ you need to take more than a grain of salt with it. The first volume of a new\
    \ edition is <a href=\"https://rads.stackoverflow.com/amzn/click/com/0201717069\"\
    \ rel=\"noreferrer\">expected in 2018</a>.</p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201834545\"\
    \ rel=\"noreferrer\"><em>Inside the C++ Object Model</em></a> (Stanley Lippman)\
    \  If you want to know how virtual member functions are commonly implemented and\
    \ how base objects are commonly laid out in memory in a multi-inheritance scenario,\
    \ and how all this affects performance, this is where you will find thorough discussions\
    \ of such topics.</p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201514591\"\
    \ rel=\"noreferrer\"><em>The Annotated C++ Reference Manual</em></a> (Bjarne Stroustrup,\
    \ Margaret A. Ellis) This book is quite outdated in the fact that it explores\
    \ the 1989 C++ 2.0 version - Templates, exceptions, namespaces and new casts were\
    \ not yet introduced. Saying that however, this book goes through the entire C++\
    \ standard of the time explaining the rationale, the possible implementations,\
    \ and features of the language. This is not a book to learn programming principles\
    \ and patterns on C++, but to understand every aspect of the C++ language.</p></li>\n\
    <li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0139798099\" rel=\"\
    noreferrer\"><em>Thinking in C++</em></a> (Bruce Eckel, 2nd Edition, 2000).  Two\
    \ volumes; is a tutorial style <em>free</em> set of intro level books. Downloads:\
    \ <a href=\"https://ia800100.us.archive.org/10/items/TICPP2ndEdVolOne/TICPP-2nd-ed-Vol-one.zip\"\
    \ rel=\"noreferrer\">vol 1</a>, <a href=\"https://ia800108.us.archive.org/24/items/TICPP2ndEdVolTwo/TICPP-2nd-ed-Vol-two.zip\"\
    \ rel=\"noreferrer\">vol 2</a>. Unfortunately they’re marred by a number of trivial\
    \ errors (e.g. maintaining that temporaries are automatically <code>const</code>),\
    \ with no official errata list. A partial 3<sup>rd</sup> party errata list is\
    \ available at (<a href=\"http://www.computersciencelab.com/Eckel.htm\" rel=\"\
    noreferrer\">http://www.computersciencelab.com/Eckel.htm</a>), but it’s apparently\
    \ not maintained.</p></li>\n<li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201533936\"\
    \ rel=\"noreferrer\"><em>Scientific and Engineering C++: An Introduction to Advanced\
    \ Techniques and Examples</em></a> (John Barton and Lee Nackman) \nIt is a comprehensive\
    \ and very detailed book that tried to explain and make use of all the features\
    \ available in C++, in the context of numerical methods. It introduced at the\
    \ time several new techniques, such as the Curiously Recurring Template Pattern\
    \ (CRTP, also called Barton-Nackman trick).\nIt pioneered several techniques such\
    \ as dimensional analysis and automatic differentiation. \nIt came with a lot\
    \ of compilable and useful code, ranging from an expression parser to a Lapack\
    \ wrapper. \nThe code is still available here: <a href=\"http://www.informit.com/store/scientific-and-engineering-c-plus-plus-an-introduction-9780201533934\"\
    \ rel=\"noreferrer\">http://www.informit.com/store/scientific-and-engineering-c-plus-plus-an-introduction-9780201533934</a>.\n\
    Unfortunately, the books have become somewhat outdated in the style and C++ features,\
    \ however, it was an incredible tour-de-force at the time (1994, pre-STL).\nThe\
    \ chapters on dynamics inheritance are a bit complicated to understand and not\
    \ very useful.\nAn updated version of this classic book that includes move semantics\
    \ and the lessons learned from the STL would be very nice.</p></li>\n</ul>\n</div>"
- - What are the differences between a pointer variable and a reference variable in
    C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<ol>\n<li><p>A pointer can be re-assigned:\
    \ </p>\n<pre><code>int x = 5;\nint y = 6;\nint *p;\np =  &amp;x;\np = &amp;y;\n\
    *p = 10;\nassert(x == 5);\nassert(y == 10);\n</code></pre>\n<p>A reference cannot,\
    \ and must be assigned at initialization:</p>\n<pre><code>int x = 5;\nint y =\
    \ 6;\nint &amp;r = x;\n</code></pre></li>\n<li><p>A pointer has its own memory\
    \ address and size on the stack (4 bytes on x86), whereas a reference shares the\
    \ same memory address (with the original variable) but also takes up some space\
    \ on the stack.  Since a reference has the same address as the original variable\
    \ itself, it is safe to think of a reference as another name for the same variable.\
    \  Note: What a pointer points to can be on the stack or heap.  Ditto a reference.\
    \ My claim in this statement is not that a pointer must point to the stack.  A\
    \ pointer is just a variable that holds a memory address.  This variable is on\
    \ the stack.  Since a reference has its own space on the stack, and since the\
    \ address is the same as the variable it references.  More on <a href=\"https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936\"\
    >stack vs heap</a>.  This implies that there is a real address of a reference\
    \ that the compiler will not tell you. </p>\n<pre><code>int x = 0;\nint &amp;r\
    \ = x;\nint *p = &amp;x;\nint *p2 = &amp;r;\nassert(p == p2);\n</code></pre></li>\n\
    <li><p>You can have pointers to pointers to pointers offering extra levels of\
    \ indirection.  Whereas references only offer one level of indirection. </p>\n\
    <pre><code>int x = 0;\nint y = 0;\nint *p = &amp;x;\nint *q = &amp;y;\nint **pp\
    \ = &amp;p;\npp = &amp;q;//*pp = q\n**pp = 4;\nassert(y == 4);\nassert(x == 0);\n\
    </code></pre></li>\n<li><p>Pointer can be assigned <code>nullptr</code> directly,\
    \ whereas reference cannot. If you try hard enough, and you know how, you can\
    \ make the address of a reference <code>nullptr</code>.  Likewise, if you try\
    \ hard enough you can have a reference to a pointer, and then that reference can\
    \ contain <code>nullptr</code>.</p>\n<pre><code>int *p = nullptr;\nint &amp;r\
    \ = nullptr; &lt;--- compiling error\nint &amp;r = *p;  &lt;--- likely no compiling\
    \ error, especially if the nullptr is hidden behind a function call, yet it refers\
    \ to a non-existent int at address 0\n</code></pre></li>\n<li><p>Pointers can\
    \ iterate over an array, you can use <code>++</code> to go to the next item that\
    \ a pointer is pointing to, and <code>+ 4</code> to go to the 5th element.  This\
    \ is no matter what size the object is that the pointer points to.</p></li>\n\
    <li><p>A pointer needs to be dereferenced with <code>*</code> to access the memory\
    \ location it points to, whereas a reference can be used directly.  A pointer\
    \ to a class/struct uses <code>-&gt;</code> to access it's members whereas a reference\
    \ uses a <code>.</code>.</p></li>\n<li><p>A pointer is a variable that holds a\
    \ memory address.  Regardless of how a reference is implemented, a reference has\
    \ the same memory address as the item it references.</p></li>\n<li><p>References\
    \ cannot be stuffed into an array, whereas pointers can be (Mentioned by user\
    \ @litb)</p></li>\n<li><p>Const references can be bound to temporaries. Pointers\
    \ cannot (not without some indirection):</p>\n<pre><code>const int &amp;x = int(12);\
    \ //legal C++\nint *y = &amp;int(12); //illegal to dereference a temporary.\n\
    </code></pre>\n<p>This makes <code>const&amp;</code> safer for use in argument\
    \ lists and so forth.</p></li>\n</ol>\n</div>"
- - What are the differences between a pointer variable and a reference variable in
    C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<h1>What's a C++ reference (<em>for\
    \ C programmers</em>)</h1>\n<p>A <em>reference</em> can be thought of as a <em>constant\
    \ pointer</em> (not to be confused with a pointer to a constant value!) with automatic\
    \ indirection, ie the compiler will apply the <code>*</code> operator for you.</p>\n\
    <p>All references must be initialized with a non-null value or compilation will\
    \ fail. It's neither possible to get the address of a reference - the address\
    \ operator will return the address of the referenced value instead - nor is it\
    \ possible to do arithmetics on references.</p>\n<p>C programmers might dislike\
    \ C++ references as it will no longer be obvious when indirection happens or if\
    \ an argument gets passed by value or by pointer without looking at function signatures.</p>\n\
    <p>C++ programmers might dislike using pointers as they are considered unsafe\
    \ - although references aren't really any safer than constant pointers except\
    \ in the most trivial cases - lack the convenience of automatic indirection and\
    \ carry a different semantic connotation.</p>\n<p>Consider the following statement\
    \ from the <a href=\"https://isocpp.org/wiki/faq/references#overview-refs\" rel=\"\
    noreferrer\"><em>C++ FAQ</em></a>:</p>\n<blockquote>\n<p>Even though a reference\
    \ is often implemented using an address in the\n  underlying assembly language,\
    \ please do <em>not</em> think of a reference as a\n  funny looking pointer to\
    \ an object. A reference <em>is</em> the object. It is\n  not a pointer to the\
    \ object, nor a copy of the object. It <em>is</em> the\n  object.</p>\n</blockquote>\n\
    <p>But if a reference <em>really</em> were the object, how could there be dangling\
    \ references? In unmanaged languages, it's impossible for references to be any\
    \ 'safer' than pointers - there generally just isn't a way to reliably alias values\
    \ across scope boundaries!</p>\n<h1>Why I consider C++ references useful</h1>\n\
    <p>Coming from a C background, C++ references may look like a somewhat silly concept,\
    \ but one should still use them instead of pointers where possible: Automatic\
    \ indirection <em>is</em> convenient, and references become especially useful\
    \ when dealing with <a href=\"https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\"\
    \ rel=\"noreferrer\">RAII</a> - but not because of any perceived safety advantage,\
    \ but rather because they make writing idiomatic code less awkward.</p>\n<p>RAII\
    \ is one of the central concepts of C++, but it interacts non-trivially with copying\
    \ semantics. Passing objects by reference avoids these issues as no copying is\
    \ involved. If references were not present in the language, you'd have to use\
    \ pointers instead, which are more cumbersome to use, thus violating the language\
    \ design principle that the best-practice solution should be easier than the alternatives.</p>\n\
    </div>"
- - What are the differences between a pointer variable and a reference variable in
    C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>If you want to be really pedantic,\
    \ there is one thing you can do with a reference that you can't do with a pointer:\
    \ extend the lifetime of a temporary object. In C++ if you bind a const reference\
    \ to a temporary object, the lifetime of that object becomes the lifetime of the\
    \ reference.</p>\n<pre><code>std::string s1 = \"123\";\nstd::string s2 = \"456\"\
    ;\n\nstd::string s3_copy = s1 + s2;\nconst std::string&amp; s3_reference = s1\
    \ + s2;\n</code></pre>\n<p>In this example s3_copy copies the temporary object\
    \ that is a result of the concatenation. Whereas s3_reference in essence becomes\
    \ the temporary object. It's really a reference to a temporary object that now\
    \ has the same lifetime as the reference. </p>\n<p>If you try this without the\
    \ <code>const</code> it should fail to compile. You cannot bind a non-const reference\
    \ to a temporary object, nor can you take its address for that matter.</p>\n</div>"
- - How do I iterate over the words of a string?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>For what it's worth, here's another\
    \ way to extract tokens from an input string, relying only on standard library\
    \ facilities. It's an example of the power and elegance behind the design of the\
    \ STL.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include\
    \ &lt;sstream&gt;\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\n\nint\
    \ main() {\n    using namespace std;\n    string sentence = \"And I feel fine...\"\
    ;\n    istringstream iss(sentence);\n    copy(istream_iterator&lt;string&gt;(iss),\n\
    \         istream_iterator&lt;string&gt;(),\n         ostream_iterator&lt;string&gt;(cout,\
    \ \"\\n\"));\n}\n</code></pre>\n<p>Instead of copying the extracted tokens to\
    \ an output stream, one could insert them into a container, using the same generic\
    \ <code>copy</code> algorithm.</p>\n<pre><code>vector&lt;string&gt; tokens;\n\
    copy(istream_iterator&lt;string&gt;(iss),\n     istream_iterator&lt;string&gt;(),\n\
    \     back_inserter(tokens));\n</code></pre>\n<p>... or create the <code>vector</code>\
    \ directly:</p>\n<pre><code>vector&lt;string&gt; tokens{istream_iterator&lt;string&gt;{iss},\n\
    \                      istream_iterator&lt;string&gt;{}};\n</code></pre>\n</div>"
- - How do I iterate over the words of a string?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>I use this to split string by\
    \ a delimiter. The first puts the results in a pre-constructed vector, the second\
    \ returns a new vector.</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>#include\
    \ &lt;string&gt;\n#include &lt;sstream&gt;\n#include &lt;vector&gt;\n#include\
    \ &lt;iterator&gt;\n\ntemplate&lt;typename Out&gt;\nvoid split(const std::string\
    \ &amp;s, char delim, Out result) {\n    std::stringstream ss(s);\n    std::string\
    \ item;\n    while (std::getline(ss, item, delim)) {\n        *(result++) = item;\n\
    \    }\n}\n\nstd::vector&lt;std::string&gt; split(const std::string &amp;s, char\
    \ delim) {\n    std::vector&lt;std::string&gt; elems;\n    split(s, delim, std::back_inserter(elems));\n\
    \    return elems;\n}\n</code></pre>\n<hr/>\n<p>Note that this solution does not\
    \ skip empty tokens, so the following will find 4 items, one of which is empty:</p>\n\
    <pre class=\"lang-c++ prettyprint-override\"><code>std::vector&lt;std::string&gt;\
    \ x = split(\"one:two::three\", ':');\n</code></pre>\n</div>"
- - How do I iterate over the words of a string?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>A possible solution using Boost\
    \ might be:</p>\n<pre><code>#include &lt;boost/algorithm/string.hpp&gt;\nstd::vector&lt;std::string&gt;\
    \ strs;\nboost::split(strs, \"string to split\", boost::is_any_of(\"\\t \"));\n\
    </code></pre>\n<p>This approach might be even faster than the <code>stringstream</code>\
    \ approach. And since this is a generic template function it can be used to split\
    \ other types of strings (wchar, etc. or UTF-8) using all kinds of delimiters.</p>\n\
    <p>See the <a href=\"http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html\"\
    \ rel=\"noreferrer\">documentation</a> for details.</p>\n</div>"
- - What does the explicit keyword mean?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>The compiler is allowed to make\
    \ one implicit conversion to resolve the parameters to a function. What this means\
    \ is that the compiler can use constructors callable with a <strong>single parameter</strong>\
    \ to convert from one type to another in order to get the right type for a parameter.\
    \ </p>\n<p>Here's an example class with a constructor that can be used for implicit\
    \ conversions:</p>\n<pre><code>class Foo\n{\npublic:\n  // single parameter constructor,\
    \ can be used as an implicit conversion\n  Foo (int foo) : m_foo (foo) \n  {\n\
    \  }\n\n  int GetFoo () { return m_foo; }\n\nprivate:\n  int m_foo;\n};\n</code></pre>\n\
    <p>Here's a simple function that takes a <code>Foo</code> object:</p>\n<pre><code>void\
    \ DoBar (Foo foo)\n{\n  int i = foo.GetFoo ();\n}\n</code></pre>\n<p>and here's\
    \ where the <code>DoBar</code> function is called.</p>\n<pre><code>int main ()\n\
    {\n  DoBar (42);\n}\n</code></pre>\n<p>The argument is not a <code>Foo</code>\
    \ object, but an <code>int</code>. However, there exists a constructor for <code>Foo</code>\
    \ that takes an <code>int</code> so this constructor can be used to convert the\
    \ parameter to the correct type.</p>\n<p>The compiler is allowed to do this once\
    \ for each parameter.</p>\n<p>Prefixing the <code>explicit</code> keyword to the\
    \ constructor prevents the compiler from using that constructor for implicit conversions.\
    \ Adding it to the above class will create a compiler error at the function call\
    \ <code>DoBar (42)</code>.  It is now necessary to call for conversion explicitly\
    \ with  <code>DoBar (Foo (42))</code></p>\n<p>The reason you might want to do\
    \ this is to avoid accidental construction that can hide bugs.  Contrived example:</p>\n\
    <ul>\n<li>You have a <code>MyString(int size)</code> class with a constructor\
    \ that constructs a string of the given size.  You have a function <code>print(const\
    \ MyString&amp;)</code>, and you call <code>print(3)</code> (when you <em>actually</em>\
    \ intended to call <code>print(\"3\")</code>).  You expect it to print \"3\",\
    \ but it prints an empty string of length 3 instead.</li>\n</ul>\n</div>"
- - What does the explicit keyword mean?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Suppose, you have a class <code>String</code>:</p>\n\
    <pre><code>class String {\npublic:\n    String(int n); // allocate n bytes to\
    \ the String object\n    String(const char *p); // initializes object with char\
    \ *p\n};\n</code></pre>\n<p>Now, if you try:</p>\n<pre><code>String mystring =\
    \ 'x';\n</code></pre>\n<p>The character <code>'x'</code> will be implicitly converted\
    \ to <code>int</code> and then the <code>String(int)</code> constructor will be\
    \ called. But, this is not what the user might have intended. So, to prevent such\
    \ conditions, we shall define the constructor as <code>explicit</code>:</p>\n\
    <pre><code>class String {\npublic:\n    explicit String (int n); //allocate n\
    \ bytes\n    String(const char *p); // initialize sobject with string p\n};\n\
    </code></pre>\n</div>"
- - What does the explicit keyword mean?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>In C++, a constructor with only\
    \ one required parameter is considered an implicit conversion function.  It converts\
    \ the parameter type to the class type.  Whether this is a good thing or not depends\
    \ on the semantics of the constructor.</p>\n<p>For example, if you have a string\
    \ class with constructor <code>String(const char* s)</code>, that's probably exactly\
    \ what you want.  You can pass a <code>const char*</code> to a function expecting\
    \ a <code>String</code>, and the compiler will automatically construct a temporary\
    \ <code>String</code> object for you.</p>\n<p>On the other hand, if you have a\
    \ buffer class whose constructor <code>Buffer(int size)</code> takes the size\
    \ of the buffer in bytes, you probably don't want the compiler to quietly turn\
    \ <code>int</code>s into <code>Buffer</code>s.  To prevent that, you declare the\
    \ constructor with the <code>explicit</code> keyword:</p>\n<pre><code>class Buffer\
    \ { explicit Buffer(int size); ... }\n</code></pre>\n<p>That way,</p>\n<pre><code>void\
    \ useBuffer(Buffer&amp; buf);\nuseBuffer(4);\n</code></pre>\n<p>becomes a compile-time\
    \ error.  If you want to pass a temporary <code>Buffer</code> object, you have\
    \ to do so explicitly:</p>\n<pre><code>useBuffer(Buffer(4));\n</code></pre>\n\
    <p>In summary, if your single-parameter constructor converts the parameter into\
    \ an object of your class, you probably don't want to use the <code>explicit</code>\
    \ keyword.  But if you have a constructor that simply happens to take a single\
    \ parameter, you should declare it as <code>explicit</code> to prevent the compiler\
    \ from surprising you with unexpected conversions.</p>\n</div>"
- - Why is “using namespace std” considered bad practice?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>This is not related to performance\
    \ at all. But consider this: you are using two libraries called Foo and Bar:</p>\n\
    <pre><code>using namespace foo;\nusing namespace bar;\n</code></pre>\n<p>Everything\
    \ works fine, you can call <code>Blah()</code> from Foo and <code>Quux()</code>\
    \ from Bar without problems. But one day you upgrade to a new version of Foo 2.0,\
    \ which now offers a function called <code>Quux()</code>. Now you've got a conflict:\
    \ Both Foo 2.0 and Bar import <code>Quux()</code> into your global namespace.\
    \ This is going to take some effort to fix, especially if the function parameters\
    \ happen to match.</p>\n<p>If you had used <code>foo::Blah()</code> and <code>bar::Quux()</code>,\
    \ then the introduction of <code>foo::Quux()</code> would have been a non-event.</p>\n\
    </div>"
- - Why is “using namespace std” considered bad practice?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>I agree with everything <a href=\"\
    https://stackoverflow.com/questions/1452721/1452738#1452738\">Greg wrote</a>,\
    \ but I'd like to add: <strong><em>It can even get worse than Greg said!</em></strong></p>\n\
    <p>Library Foo 2.0 could introduce a function, <code>Quux()</code>, that is an\
    \ unambiguously better match for some of your calls to <code>Quux()</code> than\
    \ the <code>bar::Quux()</code> your code called for years. Then your <strong><em>code\
    \ still compiles</em></strong>, but <strong><em>it silently calls the wrong function</em></strong>\
    \ and does god-knows-what. That's about as bad as things can get.</p>\n<p>Keep\
    \ in mind that the <code>std</code> namespace has tons of identifiers, many of\
    \ which are <em>very</em> common ones (think <code>list</code>, <code>sort</code>,\
    \ <code>string</code>, <code>iterator</code>, etc.) which are very likely to appear\
    \ in other code, too.</p>\n<p>If you consider this unlikely: There was <a href=\"\
    https://stackoverflow.com/a/2712125/140719\">a question asked</a> here on Stack\
    \ Overflow where pretty much exactly this happened (wrong function called due\
    \ to omitted <code>std::</code> prefix) about half a year after I gave this answer.\
    \ <a href=\"https://stackoverflow.com/questions/13402789/\">Here</a> is another,\
    \ more recent example of such a question.\nSo this is a real problem.</p>\n<hr/>\n\
    <p>Here's one more data point: Many, many years ago, I also used to find it annoying\
    \ having to prefix everything from the standard library with <code>std::</code>.\
    \ Then I worked in a project where it was decided at the start that both <code>using</code>\
    \ directives and declarations are banned except for function scopes. Guess what?\
    \ It took most of us very few weeks to get used to writing the prefix, and after\
    \ a few more weeks most of us even agreed that it actually made the code <em>more\
    \ readable</em>. There's a reason for that: <strong><em>Whether you like shorter\
    \ or longer prose is subjective, but the prefixes objectively add clarity to the\
    \ code.</em></strong> Not only the compiler, but you, too, find it easier to see\
    \ which identifier is referred to.</p>\n<p>In a decade, that project grew to have\
    \ several million lines of code. Since these discussions come up again and again,\
    \ I once was curious how often the (allowed) function-scope <code>using</code>\
    \ actually was used in the project. I grep'd the sources for it and only found\
    \ one or two dozen places where it was used. To me this indicates that, once tried,\
    \ developers don't find <code>std::</code> painful enough to employ using directives\
    \ even once every 100 kLoC even where it was allowed to be used.</p>\n<hr/>\n\
    <p>Bottom line: Explicitly prefixing everything doesn't do any harm, takes very\
    \ little getting used to, and has objective advantages. In particular, it makes\
    \ the code easier to interpret by the compiler and by human readers — and that\
    \ should probably be the main goal when writing code.</p>\n</div>"
- - Why is “using namespace std” considered bad practice?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>The problem with putting <code>using\
    \ namespace</code> in the header files of your classes is that it forces anyone\
    \ who wants to use your classes (by including your header files) to also be 'using'\
    \ (i.e. seeing everything in) those other namespaces.</p>\n<p>However, you may\
    \ feel free to put a using statement in your (private) *.cpp files.</p>\n<hr/>\n\
    <p>Beware that some people disagree with my saying \"feel free\" like this --\
    \ because although a using statement in a cpp file is <em>better</em> than in\
    \ a header (because it doesn't affect people who include your header file), they\
    \ think it's still not <em>good</em> (because depending on the code it could make\
    \ the implementation of the class more difficult to maintain). <a href=\"https://isocpp.org/wiki/faq/coding-standards#using-namespace-std\"\
    \ rel=\"noreferrer\">This FAQ topic</a> says,</p>\n<blockquote>\n<p>The using-directive\
    \ exists for legacy C++ code and to ease the transition to namespaces, but you\
    \ probably shouldn’t use it on a regular basis, at least not in your new C++ code.</p>\n\
    </blockquote>\n<p>The FAQ suggests two alternatives:</p>\n<ul>\n<li><p>A using-declaration:</p>\n\
    <pre><code>using std::cout; // a using-declaration lets you use cout without qualification\n\
    cout &lt;&lt; \"Values:\";\n</code></pre></li>\n<li><p>Just typing std::</p>\n\
    <pre><code>std::cout &lt;&lt; \"Values:\";\n</code></pre></li>\n</ul>\n</div>"
- - How do you set, clear, and toggle a single bit?
  - "<div class=\"post-text\" itemprop=\"text\">\n<h1>Setting a bit</h1>\n<p>Use the\
    \ bitwise OR operator (<code>|</code>) to set a bit.</p>\n<pre><code>number |=\
    \ 1UL &lt;&lt; n;\n</code></pre>\n<p>That will set the <code>n</code>th bit of\
    \ <code>number</code>. <code>n</code> should be zero, if you want to set the <code>1</code>st\
    \ bit and so on upto <code>n-1</code>, if you want to set the <code>n</code>th\
    \ bit.</p>\n<p>Use <code>1ULL</code> if <code>number</code> is wider than <code>unsigned\
    \ long</code>; promotion of <code>1UL &lt;&lt; n</code> doesn't happen until after\
    \ evaluating <code>1UL &lt;&lt; n</code> where it's undefined behaviour to shift\
    \ by more than the width of a <code>long</code>.  The same applies to all the\
    \ rest of the examples.</p>\n<h1>Clearing a bit</h1>\n<p>Use the bitwise AND operator\
    \ (<code>&amp;</code>) to clear a bit.</p>\n<pre><code>number &amp;= ~(1UL &lt;&lt;\
    \ n);\n</code></pre>\n<p>That will clear the <code>n</code>th bit of <code>number</code>.\
    \ You must invert the bit string with the bitwise NOT operator (<code>~</code>),\
    \ then AND it.</p>\n<h1>Toggling a bit</h1>\n<p>The XOR operator (<code>^</code>)\
    \ can be used to toggle a bit.</p>\n<pre><code>number ^= 1UL &lt;&lt; n;\n</code></pre>\n\
    <p>That will toggle the <code>n</code>th bit of <code>number</code>.</p>\n<h1>Checking\
    \ a bit</h1>\n<p>You didn't ask for this, but I might as well add it.</p>\n<p>To\
    \ check a bit, shift the number n to the right, then bitwise AND it:</p>\n<pre><code>bit\
    \ = (number &gt;&gt; n) &amp; 1U;\n</code></pre>\n<p>That will put the value of\
    \ the <code>n</code>th bit of <code>number</code> into the variable <code>bit</code>.</p>\n\
    <h1>Changing the <em>n</em>th bit to <em>x</em></h1>\n<p>Setting the <code>n</code>th\
    \ bit to either <code>1</code> or <code>0</code> can be achieved with the following\
    \ on a 2's complement C++ implementation:</p>\n<pre><code>number ^= (-x ^ number)\
    \ &amp; (1UL &lt;&lt; n);\n</code></pre>\n<p>Bit <code>n</code> will be set if\
    \ <code>x</code> is <code>1</code>, and cleared if <code>x</code> is <code>0</code>.\
    \  If <code>x</code> has some other value, you get garbage.  <code>x = !!x</code>\
    \ will booleanize it to 0 or 1.</p>\n<p>To make this independent of 2's complement\
    \ negation behaviour (where <code>-1</code> has all bits set, unlike on a 1's\
    \ complement or sign/magnitude C++ implementation), use unsigned negation.</p>\n\
    <pre><code>number ^= (-(unsigned long)x ^ number) &amp; (1UL &lt;&lt; n);\n</code></pre>\n\
    <p>or</p>\n<pre><code>unsigned long newbit = !!x;    // Also booleanize to force\
    \ 0 or 1\nnumber ^= (-newbit ^ number) &amp; (1UL &lt;&lt; n);\n</code></pre>\n\
    <p>It's generally a good idea to use unsigned types for portable bit manipulation.</p>\n\
    <p>It's also generally a good idea to not to copy/paste code in general and so\
    \ many people use preprocessor macros (like <a href=\"https://stackoverflow.com/a/263738/52074\"\
    >the community wiki answer further down</a>) or some sort of encapsulation.</p>\n\
    </div>"
- - How do you set, clear, and toggle a single bit?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Using the Standard C++ Library:\
    \ <a href=\"http://en.cppreference.com/w/cpp/utility/bitset\" rel=\"noreferrer\"\
    ><code>std::bitset&lt;N&gt;</code></a>.</p>\n<p>Or the <a href=\"http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29\"\
    \ rel=\"noreferrer\">Boost</a> version: <a href=\"http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html\"\
    \ rel=\"noreferrer\"><code>boost::dynamic_bitset</code></a>.</p>\n<p>There is\
    \ no need to roll your own:</p>\n<pre><code>#include &lt;bitset&gt;\n#include\
    \ &lt;iostream&gt;\n\nint main()\n{\n    std::bitset&lt;5&gt; x;\n\n    x[1] =\
    \ 1;\n    x[2] = 0;\n    // Note x[0-4]  valid\n\n    std::cout &lt;&lt; x &lt;&lt;\
    \ std::endl;\n}\n</code></pre>\n<hr/>\n<pre><code>[Alpha:] &gt; ./a.out\n00010\n\
    </code></pre>\n<p>The Boost version allows a runtime sized bitset compared with\
    \ a <a href=\"https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library\" rel=\"\
    noreferrer\">standard library</a> compile-time sized bitset.</p>\n</div>"
- - How do you set, clear, and toggle a single bit?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>The other option is to use bit\
    \ fields:</p>\n<pre><code>struct bits {\n    unsigned int a:1;\n    unsigned int\
    \ b:1;\n    unsigned int c:1;\n};\n\nstruct bits mybits;\n</code></pre>\n<p>defines\
    \ a 3-bit field (actually, it's three 1-bit felds). Bit operations now become\
    \ a bit (haha) simpler:</p>\n<p>To set or clear a bit:</p>\n<pre><code>mybits.b\
    \ = 1;\nmybits.c = 0;\n</code></pre>\n<p>To toggle a bit:</p>\n<pre><code>mybits.a\
    \ = !mybits.a;\nmybits.b = ~mybits.b;\nmybits.c ^= 1;  /* all work */\n</code></pre>\n\
    <p>Checking a bit:</p>\n<pre><code>if (mybits.c)  //if mybits.c is non zero the\
    \ next line below will execute\n</code></pre>\n<p>This only works with fixed-size\
    \ bit fields. Otherwise you have to resort to the bit-twiddling techniques described\
    \ in previous posts.</p>\n</div>"
- - When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p><strong><code>static_cast</code></strong>\
    \ is the first cast you should attempt to use. It does things like implicit conversions\
    \ between types (such as <code>int</code> to <code>float</code>, or pointer to\
    \ <code>void*</code>), and it can also call explicit conversion functions (or\
    \ implicit ones). In many cases, explicitly stating <code>static_cast</code> isn't\
    \ necessary, but it's important to note that the <code>T(something)</code> syntax\
    \ is equivalent to <code>(T)something</code> and should be avoided (more on that\
    \ later). A <code>T(something, something_else)</code> is safe, however, and guaranteed\
    \ to call the constructor.</p>\n<p><code>static_cast</code> can also cast through\
    \ inheritance hierarchies. It is unnecessary when casting upwards (towards a base\
    \ class), but when casting downwards it can be used as long as it doesn't cast\
    \ through <code>virtual</code> inheritance. It does not do checking, however,\
    \ and it is undefined behavior to <code>static_cast</code> down a hierarchy to\
    \ a type that isn't actually the type of the object.</p>\n<hr/>\n<p><strong><code>const_cast</code></strong>\
    \ can be used to remove or add <code>const</code> to a variable; no other C++\
    \ cast is capable of removing it (not even <code>reinterpret_cast</code>). It\
    \ is important to note that modifying a formerly <code>const</code> value is only\
    \ undefined if the original variable is <code>const</code>; if you use it to take\
    \ the <code>const</code> off a reference to something that wasn't declared with\
    \ <code>const</code>, it is safe. This can be useful when overloading member functions\
    \ based on <code>const</code>, for instance. It can also be used to add <code>const</code>\
    \ to an object, such as to call a member function overload.</p>\n<p><code>const_cast</code>\
    \ also works similarly on <code>volatile</code>, though that's less common.</p>\n\
    <hr/>\n<p><strong><code>dynamic_cast</code></strong> is almost exclusively used\
    \ for handling polymorphism. You can cast a pointer or reference to any polymorphic\
    \ type to any other class type (a polymorphic type has at least one virtual function,\
    \ declared or inherited). You can use it for more than just casting downwards\
    \ -- you can cast sideways or even up another chain. The <code>dynamic_cast</code>\
    \ will seek out the desired object and return it if possible. If it can't, it\
    \ will return <code>nullptr</code> in the case of a pointer, or throw <code>std::bad_cast</code>\
    \ in the case of a reference.</p>\n<p><code>dynamic_cast</code> has some limitations,\
    \ though. It doesn't work if there are multiple objects of the same type in the\
    \ inheritance hierarchy (the so-called 'dreaded diamond') and you aren't using\
    \ <code>virtual</code> inheritance. It also can only go through public inheritance\
    \ - it will always fail to travel through <code>protected</code> or <code>private</code>\
    \ inheritance. This is rarely an issue, however, as such forms of inheritance\
    \ are rare.</p>\n<hr/>\n<p><strong><code>reinterpret_cast</code></strong> is the\
    \ most dangerous cast, and should be used very sparingly. It turns one type directly\
    \ into another - such as casting the value from one pointer to another, or storing\
    \ a pointer in an <code>int</code>, or all sorts of other nasty things. Largely,\
    \ the only guarantee you get with <code>reinterpret_cast</code> is that normally\
    \ if you cast the result back to the original type, you will get the exact same\
    \ value (but <strong><em>not</em></strong> if the intermediate type is smaller\
    \ than the original type). There are a number of conversions that <strong><code>reinterpret_cast</code></strong>\
    \ cannot do, too. It's used primarily for particularly weird conversions and bit\
    \ manipulations, like turning a raw data stream into actual data, or storing data\
    \ in the low bits of an aligned pointer.</p>\n<hr/>\n<p><strong>C-style cast</strong>\
    \ and <strong>function-style cast</strong> are casts using <code>(type)object</code>\
    \ or <code>type(object)</code>, respectively. A C-style cast is defined as the\
    \ first of the following which succeeds:</p>\n<ul>\n<li><code>const_cast</code></li>\n\
    <li><code>static_cast</code> (though ignoring access restrictions)</li>\n<li><code>static_cast</code>\
    \ (see above), then <code>const_cast</code></li>\n<li><code>reinterpret_cast</code></li>\n\
    <li><code>reinterpret_cast</code>, then <code>const_cast</code></li>\n</ul>\n\
    <p>It can therefore be used as a replacement for other casts in some instances,\
    \ but can be extremely dangerous because of the ability to devolve into a <code>reinterpret_cast</code>,\
    \ and the latter should be preferred when explicit casting is needed, unless you\
    \ are sure <code>static_cast</code> will succeed or <code>reinterpret_cast</code>\
    \ will fail. Even then, consider the longer, more explicit option.</p>\n<p>C-style\
    \ casts also ignore access control when performing a <code>static_cast</code>,\
    \ which means that they have the ability to perform an operation that no other\
    \ cast can. This is mostly a kludge, though, and in my mind is just another reason\
    \ to avoid C-style casts.</p>\n</div>"
- - When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Use <code>dynamic_cast</code>\
    \ for converting pointers/references within an inheritance hierarchy.</p>\n<p>Use\
    \ <code>static_cast</code> for ordinary type conversions.</p>\n<p>Use <code>reinterpret_cast</code>\
    \ for low-level reinterpreting of bit patterns.  Use with extreme caution.</p>\n\
    <p>Use <code>const_cast</code> for casting away <code>const/volatile</code>. \
    \ Avoid this unless you are stuck using a const-incorrect API.</p>\n</div>"
- - When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p><em>(A lot of theoretical and\
    \ conceptual explanation has been given above)</em> </p>\n<p>Below are some of\
    \ the <strong>practical examples</strong> when I used <strong>static_cast</strong>,\
    \ <strong>dynamic_cast</strong>, <strong>const_cast</strong>, <strong>reinterpret_cast</strong>.</p>\n\
    <p>(Also referes this to understand the explaination : <a href=\"http://www.cplusplus.com/doc/tutorial/typecasting/\"\
    \ rel=\"noreferrer\">http://www.cplusplus.com/doc/tutorial/typecasting/</a>)</p>\n\
    <p><strong>static_cast :</strong></p>\n<pre><code>OnEventData(void* pData)\n\n\
    {\n  ......\n\n  //  pData is a void* pData, \n\n  //  EventData is a structure\
    \ e.g. \n  //  typedef struct _EventData {\n  //  std::string id;\n  //  std::\
    \ string remote_id;\n  //  } EventData;\n\n  // On Some Situation a void pointer\
    \ *pData\n  // has been static_casted as \n  // EventData* pointer \n\n  EventData\
    \ *evtdata = static_cast&lt;EventData*&gt;(pData);\n  .....\n}\n</code></pre>\n\
    <p><strong>dynamic_cast :</strong></p>\n<pre><code>void DebugLog::OnMessage(Message\
    \ *msg)\n{\n    static DebugMsgData *debug;\n    static XYZMsgData *xyz;\n\n \
    \   if(debug = dynamic_cast&lt;DebugMsgData*&gt;(msg-&gt;pdata)){\n        //\
    \ debug message\n    }\n    else if(xyz = dynamic_cast&lt;XYZMsgData*&gt;(msg-&gt;pdata)){\n\
    \        // xyz message\n    }\n    else/* if( ... )*/{\n        // ...\n    }\n\
    }\n</code></pre>\n<p><strong>const_cast :</strong></p>\n<pre><code>// *Passwd\
    \ declared as a const\n\nconst unsigned char *Passwd\n\n\n// on some situation\
    \ it require to remove its constness\n\nconst_cast&lt;unsigned char*&gt;(Passwd)\n\
    </code></pre>\n<p><strong>reinterpret_cast :</strong></p>\n<pre><code>typedef\
    \ unsigned short uint16;\n\n// Read Bytes returns that 2 bytes got read. \n\n\
    bool ByteBuffer::ReadUInt16(uint16&amp; val) {\n  return ReadBytes(reinterpret_cast&lt;char*&gt;(&amp;val),\
    \ 2);\n}\n</code></pre>\n</div>"
- - Why are elementwise additions much faster in separate loops than in a combined
    loop?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Upon further analysis of this,\
    \ I believe this is (at least partially) caused by data alignment of the four\
    \ pointers. This will cause some level of cache bank/way conflicts.</p>\n<p>If\
    \ I've guessed correctly on how you are allocating your arrays, they <strong><em>are\
    \ likely to be aligned to the page line</em></strong>.</p>\n<p>This means that\
    \ all your accesses in each loop will fall on the same cache way. However, Intel\
    \ processors have had 8-way L1 cache associativity for a while. But in reality,\
    \ the performance isn't completely uniform. Accessing 4-ways is still slower than\
    \ say 2-ways.</p>\n<p><strong>EDIT : It does in fact look like you are allocating\
    \ all the arrays separately.</strong>\nUsually when such large allocations are\
    \ requested, the allocator will request fresh pages from the OS. Therefore, there\
    \ is a high chance that large allocations will appear at the same offset from\
    \ a page-boundary.</p>\n<p><strong>Here's the test code:</strong></p>\n<pre><code>int\
    \ main(){\n    const int n = 100000;\n\n#ifdef ALLOCATE_SEPERATE\n    double *a1\
    \ = (double*)malloc(n * sizeof(double));\n    double *b1 = (double*)malloc(n *\
    \ sizeof(double));\n    double *c1 = (double*)malloc(n * sizeof(double));\n  \
    \  double *d1 = (double*)malloc(n * sizeof(double));\n#else\n    double *a1 =\
    \ (double*)malloc(n * sizeof(double) * 4);\n    double *b1 = a1 + n;\n    double\
    \ *c1 = b1 + n;\n    double *d1 = c1 + n;\n#endif\n\n    //  Zero the data to\
    \ prevent any chance of denormals.\n    memset(a1,0,n * sizeof(double));\n   \
    \ memset(b1,0,n * sizeof(double));\n    memset(c1,0,n * sizeof(double));\n   \
    \ memset(d1,0,n * sizeof(double));\n\n    //  Print the addresses\n    cout &lt;&lt;\
    \ a1 &lt;&lt; endl;\n    cout &lt;&lt; b1 &lt;&lt; endl;\n    cout &lt;&lt; c1\
    \ &lt;&lt; endl;\n    cout &lt;&lt; d1 &lt;&lt; endl;\n\n    clock_t start = clock();\n\
    \n    int c = 0;\n    while (c++ &lt; 10000){\n\n#if ONE_LOOP\n        for(int\
    \ j=0;j&lt;n;j++){\n            a1[j] += b1[j];\n            c1[j] += d1[j];\n\
    \        }\n#else\n        for(int j=0;j&lt;n;j++){\n            a1[j] += b1[j];\n\
    \        }\n        for(int j=0;j&lt;n;j++){\n            c1[j] += d1[j];\n  \
    \      }\n#endif\n\n    }\n\n    clock_t end = clock();\n    cout &lt;&lt; \"\
    seconds = \" &lt;&lt; (double)(end - start) / CLOCKS_PER_SEC &lt;&lt; endl;\n\n\
    \    system(\"pause\");\n    return 0;\n}\n</code></pre>\n<hr/>\n<p><strong>Benchmark\
    \ Results:</strong></p>\n<h1>EDIT: Results on an <em>actual</em> Core 2 architecture\
    \ machine:</h1>\n<p><strong>2 x Intel Xeon X5482 Harpertown @ 3.2 GHz:</strong></p>\n\
    <pre><code>#define ALLOCATE_SEPERATE\n#define ONE_LOOP\n00600020\n006D0020\n007A0020\n\
    00870020\nseconds = 6.206\n\n#define ALLOCATE_SEPERATE\n//#define ONE_LOOP\n005E0020\n\
    006B0020\n00780020\n00850020\nseconds = 2.116\n\n//#define ALLOCATE_SEPERATE\n\
    #define ONE_LOOP\n00570020\n00633520\n006F6A20\n007B9F20\nseconds = 1.894\n\n\
    //#define ALLOCATE_SEPERATE\n//#define ONE_LOOP\n008C0020\n00983520\n00A46A20\n\
    00B09F20\nseconds = 1.993\n</code></pre>\n<p>Observations:</p>\n<ul>\n<li><p><strong>6.206\
    \ seconds</strong> with one loop and <strong>2.116 seconds</strong> with two loops.\
    \ This reproduces the OP's results exactly.</p></li>\n<li><p><strong>In the first\
    \ two tests, the arrays are allocated separately.</strong> You'll notice that\
    \ they all have the same alignment relative to the page.</p></li>\n<li><p><strong>In\
    \ the second two tests, the arrays are packed together to break that alignment.</strong>\
    \ Here you'll notice both loops are faster. Furthermore, the second (double) loop\
    \ is now the slower one as you would normally expect.</p></li>\n</ul>\n<p>As @Stephen\
    \ Cannon points out in the comments, there is very likely possibility that this\
    \ alignment causes <strong><em>false aliasing</em></strong> in the load/store\
    \ units or the cache. I Googled around for this and found that Intel actually\
    \ has a hardware counter for <strong><em>partial address aliasing</em></strong>\
    \ stalls:</p>\n<p><a href=\"http://software.intel.com/sites/products/documentation/doclib/stdxe/2013/~amplifierxe/pmw_dp/events/partial_address_alias.html\"\
    >http://software.intel.com/sites/products/documentation/doclib/stdxe/2013/~amplifierxe/pmw_dp/events/partial_address_alias.html</a></p>\n\
    <hr/>\n<h1>5 Regions - Explanations</h1>\n<p><strong>Region 1:</strong></p>\n\
    <p>This one is easy. The dataset is so small that the performance is dominated\
    \ by overhead like looping and branching.</p>\n<p><strong>Region 2:</strong></p>\n\
    <p><strike>Here, as the data sizes increases, the amount of relative overhead\
    \ goes down and the performance \"saturates\". Here two loops is slower because\
    \ it has twice as much loop and branching overhead.</strike></p>\n<p>I'm not sure\
    \ exactly what's going on here... Alignment could still play an effect as Agner\
    \ Fog mentions <a href=\"http://www.agner.org/optimize/blog/read.php?i=142\">cache\
    \ bank conflicts</a>. (That link is about Sandy Bridge, but the idea should still\
    \ be applicable to Core 2.)</p>\n<p><strong>Region 3:</strong></p>\n<p>At this\
    \ point, the data no longer fits in L1 cache. So performance is capped by the\
    \ L1 &lt;-&gt; L2 cache bandwidth.</p>\n<p><strong>Region 4:</strong></p>\n<p>The\
    \ performance drop in the single-loop is what we are observing. And as mentioned,\
    \ this is due to the alignment which (most likely) causes <strong><em>false aliasing</em></strong>\
    \ stalls in the processor load/store units.</p>\n<p>However, in order for false\
    \ aliasing to occur, there must be a large enough stride between the datasets.\
    \ This is why you don't see this in region 3.</p>\n<p><strong>Region 5:</strong></p>\n\
    <p>At this point, nothing fits in cache. So you're bound by memory bandwidth.</p>\n\
    <hr/>\n<p><img alt=\"2 x Intel X5482 Harpertown @ 3.2 GHz\" src=\"https://i.stack.imgur.com/ElCGL.png\"\
    />\n<img alt=\"Intel Core i7 870 @ 2.8 GHz\" src=\"https://i.stack.imgur.com/QMpwj.png\"\
    />\n<img alt=\"Intel Core i7 2600K @ 4.4 GHz\" src=\"https://i.stack.imgur.com/NpyhG.png\"\
    /></p>\n</div>"
- - Why are elementwise additions much faster in separate loops than in a combined
    loop?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>OK, the right answer definitely\
    \ has to do something with the CPU cache. But to use the cache argument can be\
    \ quite difficult, especially without data.</p>\n<p>There are many answers, that\
    \ led to a lot of discussion, but let's face it: Cache issues can be very complex\
    \ and are not one dimensional. They depend heavily on the size of the data, so\
    \ my question was unfair: It turned out to be at a very interesting point in the\
    \ cache graph.</p>\n<p>@Mysticial's answer convinced a lot of people (including\
    \ me), probably because it was the only one that seemed to rely on facts, but\
    \ it was only one \"data point\" of the truth.</p>\n<p>That's why I combined his\
    \ test (using a continuous vs. separate allocation) and @James' Answer's advice.</p>\n\
    <p>The graphs below shows, that most of the answers and especially the majority\
    \ of comments to the question and answers can be considered completely wrong or\
    \ true depending on the exact scenario and parameters used.</p>\n<p>Note that\
    \ my initial question was at <strong>n = 100.000</strong>. This point (by accident)\
    \ exhibits special behavior: </p>\n<ol>\n<li><p>It possesses the greatest discrepancy\
    \ between the one and two loop'ed version (almost a factor of three)</p></li>\n\
    <li><p>It is the only point, where one-loop (namely with continuous allocation)\
    \ beats the two-loop version. (This made Mysticial's answer possible, at all.)</p></li>\n\
    </ol>\n<p>The result using initialized data:</p>\n<p><img alt=\"Enter image description\
    \ here\" src=\"https://i.stack.imgur.com/orxF8.png\"/></p>\n<p>The result using\
    \ uninitialized data (this is what Mysticial tested):</p>\n<p><img alt=\"Enter\
    \ image description here\" src=\"https://i.stack.imgur.com/mZPh9.png\"/></p>\n\
    <p>And this is a hard-to-explain one: Initialized data, that is allocated once\
    \ and reused for every following test case of different vector size:</p>\n<p><img\
    \ alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/aiDfv.png\"\
    /></p>\n<h2>Proposal</h2>\n<p>Every low-level performance related question on\
    \ Stack Overflow should be required to provide MFLOPS information for the whole\
    \ range of cache relevant data sizes! It's a waste of everybody's time to think\
    \ of answers and especially discuss them with others without this information.</p>\n\
    </div>"
- - Why are elementwise additions much faster in separate loops than in a combined
    loop?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>The second loop involves a lot\
    \ less cache activity, so it's easier for the processor to keep up with the memory\
    \ demands.</p>\n</div>"
- - Why is reading lines from stdin much slower in C++ than Python?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>By default, <code>cin</code>\
    \ is synchronized with stdio, which causes it to avoid any input buffering.  If\
    \ you add this to the top of your main, you should see much better performance:</p>\n\
    <pre><code>std::ios_base::sync_with_stdio(false);\n</code></pre>\n<p>Normally,\
    \ when an input stream is buffered, instead of reading one character at a time,\
    \ the stream will be read in larger chunks.  This reduces the number of system\
    \ calls, which are typically relatively expensive.  However, since the <code>FILE*</code>\
    \ based <code>stdio</code> and <code>iostreams</code> often have separate implementations\
    \ and therefore separate buffers, this could lead to a problem if both were used\
    \ together.  For example:</p>\n<pre><code>int myvalue1;\ncin &gt;&gt; myvalue1;\n\
    int myvalue2;\nscanf(\"%d\",&amp;myvalue2);\n</code></pre>\n<p>If more input was\
    \ read by <code>cin</code> than it actually needed, then the second integer value\
    \ wouldn't be available for the <code>scanf</code> function, which has its own\
    \ independent buffer.  This would lead to unexpected results.</p>\n<p>To avoid\
    \ this, by default, streams are synchronized with <code>stdio</code>.  One common\
    \ way to achieve this is to have <code>cin</code> read each character one at a\
    \ time as needed using <code>stdio</code> functions.  Unfortunately, this introduces\
    \ a lot of overhead.  For small amounts of input, this isn't a big problem, but\
    \ when you are reading millions of lines, the performance penalty is significant.</p>\n\
    <p>Fortunately, the library designers decided that you should also be able to\
    \ disable this feature to get improved performance if you knew what you were doing,\
    \ so they provided the <a href=\"http://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio\"\
    \ rel=\"noreferrer\"><code>sync_with_stdio</code></a> method.</p>\n</div>"
- - Why is reading lines from stdin much slower in C++ than Python?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Just out of curiosity I've taken\
    \ a look at what happens under the hood, and I've used <a href=\"http://en.wikipedia.org/wiki/Strace\"\
    >dtruss/strace</a> on each test.</p>\n<p>C++</p>\n<pre><code>./a.out &lt; in\n\
    Saw 6512403 lines in 8 seconds.  Crunch speed: 814050\n</code></pre>\n<p>syscalls\
    \ <code>sudo dtruss -c ./a.out &lt; in</code></p>\n<pre><code>CALL           \
    \                             COUNT\n__mac_syscall                           \
    \        1\n&lt;snip&gt;\nopen                                            6\n\
    pread                                           8\nmprotect                  \
    \                     17\nmmap                                           22\n\
    stat64                                         30\nread_nocancel             \
    \                  25958\n</code></pre>\n<p>Python</p>\n<pre><code>./a.py &lt;\
    \ in\nRead 6512402 lines in 1 seconds. LPS: 6512402\n</code></pre>\n<p>syscalls\
    \ <code>sudo dtruss -c ./a.py &lt; in</code></p>\n<pre><code>CALL            \
    \                            COUNT\n__mac_syscall                            \
    \       1\n&lt;snip&gt;\nopen                                            5\npread\
    \                                           8\nmprotect                      \
    \                 17\nmmap                                           21\nstat64\
    \                                         29\n</code></pre>\n</div>"
- - Why is reading lines from stdin much slower in C++ than Python?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>I'm a few years behind here,\
    \ but:</p>\n<p>In 'Edit 4/5/6' of the original post, you are using the construction:</p>\n\
    <pre><code>$ /usr/bin/time cat big_file | program_to_benchmark\n</code></pre>\n\
    <p>This is wrong in a couple of different ways:</p>\n<ol>\n<li><p>You're actually\
    \ timing the execution of `cat`, not your benchmark.  The 'user' and 'sys' CPU\
    \ usage displayed by `time` are those of `cat`, not your benchmarked program.\
    \  Even worse, the 'real' time is also not necessarily accurate.  Depending on\
    \ the implementation of `cat` and of pipelines in your local OS, it is possible\
    \ that `cat` writes a final giant buffer and exits long before the reader process\
    \ finishes its work.</p></li>\n<li><p>Use of `cat` is unnecessary and in fact\
    \ counterproductive; you're adding moving parts.  If you were on a sufficiently\
    \ old system (i.e.  with a single CPU and -- in certain generations of computers\
    \ -- I/O faster than CPU) -- the mere fact that `cat` was running could substantially\
    \ color the results.  You are also subject to whatever input and output buffering\
    \ and other processing `cat` may do.  (This would likely earn you a <a href=\"\
    https://en.wikipedia.org/wiki/Cat_(Unix)#Useless_use_of_cat\" rel=\"noreferrer\"\
    >'Useless Use Of Cat'</a> award if I were Randal Schwartz.</p></li>\n</ol>\n<p>A\
    \ better construction would be:</p>\n<pre><code>$ /usr/bin/time program_to_benchmark\
    \ &lt; big_file\n</code></pre>\n<p>In this statement it is the <em>shell</em>\
    \ which opens big_file, passing it to your program (well, actually to `time` which\
    \ then executes your program as a subprocess) as an already-open file descriptor.\
    \  100% of the file reading is strictly the responsibility of the program you're\
    \ trying to benchmark.  This gets you a real reading of its performance without\
    \ spurious complications.</p>\n<p>I will mention two possible, but actually wrong,\
    \ 'fixes' which could also be considered (but I 'number' them differently as these\
    \ are not things which were wrong in the original post):</p>\n<p>A. You could\
    \ 'fix' this by timing only your program:</p>\n<pre><code>$ cat big_file | /usr/bin/time\
    \ program_to_benchmark\n</code></pre>\n<p>B. or by timing the entire pipeline:</p>\n\
    <pre><code>$ /usr/bin/time sh -c 'cat big_file | program_to_benchmark'\n</code></pre>\n\
    <p>These are wrong for the same reasons as #2: they're still using `cat` unnecessarily.\
    \  I mention them for a few reasons:</p>\n<ul>\n<li><p>they're more 'natural'\
    \ for people who aren't entirely comfortable with the I/O redirection facilities\
    \ of the POSIX shell</p></li>\n<li><p>there may be cases where `cat` <em>is</em>\
    \ needed (e.g.: the file to be read requires some sort of privilege to access,\
    \ and you do not want to grant that privilege to the program to be benchmarked:\
    \ `sudo cat /dev/sda | /usr/bin/time my_compression_test --no-output`)</p></li>\n\
    <li><p><em>in practice</em>, on modern machines, the added `cat` in the pipeline\
    \ is probably of no real consequence</p></li>\n</ul>\n<p>But I say that last thing\
    \ with some hesitation.  If we examine the last result in 'Edit 5' --</p>\n<pre><code>$\
    \ /usr/bin/time cat temp_big_file | wc -l\n0.01user 1.34system 0:01.83elapsed\
    \ 74%CPU ...\n</code></pre>\n<p>-- this claims that `cat` consumed 74% of the\
    \ CPU during the test; and indeed 1.34/1.83 is approximately 74%.  Perhaps a run\
    \ of:</p>\n<pre><code>$ /usr/bin/time wc -l &lt; temp_big_file\n</code></pre>\n\
    <p>would have taken only the remaining .49 seconds!  Probably not: `cat` here\
    \ had to pay for the read() system calls (or equivalent) which transferred the\
    \ file from 'disk' (actually buffer cache), as well as the pipe writes to deliver\
    \ them to `wc`.  The correct test would still have had to do those read() calls;\
    \ only the write-to-pipe and read-from-pipe calls would have been saved, and those\
    \ should be pretty cheap.</p>\n<p>Still, I predict you would be able to measure\
    \ the difference between `cat file | wc -l` and `wc -l &lt; file` and find a noticeable\
    \ (2-digit percentage) difference.  Each of the slower tests will have paid a\
    \ similar penalty in absolute time; which would however amount to a smaller fraction\
    \ of its larger total time.</p>\n<p>In fact I did some quick tests with a 1.5\
    \ gigabyte file of garbage, on a Linux 3.13 (Ubuntu 14.04) system, obtaining these\
    \ results (these are actually 'best of 3' results; after priming the cache, of\
    \ course): </p>\n<pre><code>$ time wc -l &lt; /tmp/junk\nreal 0.280s user 0.156s\
    \ sys 0.124s (total cpu 0.280s)\n$ time cat /tmp/junk | wc -l\nreal 0.407s user\
    \ 0.157s sys 0.618s (total cpu 0.775s)\n$ time sh -c 'cat /tmp/junk | wc -l'\n\
    real 0.411s user 0.118s sys 0.660s (total cpu 0.778s)\n</code></pre>\n<p>Notice\
    \ that the two pipeline results claim to have taken more CPU time (user+sys) than\
    \ realtime.  This is because I'm using the shell (Bash)'s built-in 'time' command,\
    \ which is cognizant of the pipeline; and I'm on a multi-core machine where separate\
    \ processes in a pipeline can use separate cores, accumulating CPU time faster\
    \ than realtime.  Using /usr/bin/time I see smaller CPU time than realtime --\
    \ showing that it can only time the single pipeline element passed to it on its\
    \ command line.  Also, the shell's output gives milliseconds while /usr/bin/time\
    \ only gives hundreths of a second.</p>\n<p>So at the efficiency level of `wc\
    \ -l`, the `cat` makes a huge difference: 409 / 283 = 1.453 or 45.3% more realtime,\
    \ and 775 / 280 = 2.768, or a whopping 177% more CPU used!  On my random it-was-there-at-the-time\
    \ test box.</p>\n<p>I should add that there is at least one other significant\
    \ difference between these styles of testing, and I can't say whether it is a\
    \ benefit or fault; you have to decide this yourself:</p>\n<p>When you run `cat\
    \ big_file | /usr/bin/time my_program`, your program is receiving input from a\
    \ pipe, at precisely the pace sent by `cat`, and in chunks no larger than written\
    \ by `cat`.</p>\n<p>When you run `/usr/bin/time my_program &lt; big_file`, your\
    \ program receives an open file descriptor to the actual file.  Your program --\
    \ <em>or</em> in many cases the I/O libraries of the language in which it was\
    \ written -- may take different actions when presented with a file descriptor\
    \ referencing a regular file.  It may use mmap(2) to map the input file into its\
    \ address space, instead of using explicit read(2) system calls.  These differences\
    \ could have a far larger effect on your benchmark results than the small cost\
    \ of running the `cat` binary.</p>\n<p>Of course it is an interesting benchmark\
    \ result if the same program performs significantly differently between the two\
    \ cases.  It shows that, indeed, the program or its I/O libraries <em>are</em>\
    \ doing something interesting, like using mmap().  So in practice it might be\
    \ good to run the benchmarks both ways; perhaps discounting the `cat` result by\
    \ some small factor to \"forgive\" the cost of running `cat` itself.</p>\n</div>"
- - How can I profile C++ code running on Linux?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>If your goal is to use a profiler,\
    \ use one of the suggested ones.</p>\n<p>However, if you're in a hurry and you\
    \ can manually interrupt your program under the debugger while it's being subjectively\
    \ slow, there's a simple way to find performance problems.</p>\n<p>Just halt it\
    \ several times, and each time look at the call stack. If there is some code that\
    \ is wasting some percentage of the time, 20% or 50% or whatever, that is the\
    \ probability that you will catch it in the act on each sample. So that is roughly\
    \ the percentage of samples on which you will see it. There is no educated guesswork\
    \ required.\nIf you do have a guess as to what the problem is, this will prove\
    \ or disprove it.</p>\n<p>You may have multiple performance problems of different\
    \ sizes. If you clean out any one of them, the remaining ones will take a larger\
    \ percentage, and be easier to spot, on subsequent passes.\nThis <em>magnification\
    \ effect</em>, when compounded over multiple problems, can lead to truly massive\
    \ speedup factors.</p>\n<p>Caveat: Programmers tend to be skeptical of this technique\
    \ unless they've used it themselves. They will say that profilers give you this\
    \ information, but that is only true if they sample the entire call stack, and\
    \ then let you examine a random set of samples. (The summaries are where the insight\
    \ is lost.) Call graphs don't give you the same information, because </p>\n<ol>\n\
    <li>they don't summarize at the instruction level, and</li>\n<li>they give confusing\
    \ summaries in the presence of recursion.</li>\n</ol>\n<p>They will also say it\
    \ only works on toy programs, when actually it works on any program, and it seems\
    \ to work better on bigger programs, because they tend to have more problems to\
    \ find.\nThey will say it sometimes finds things that aren't problems, but that\
    \ is only true if you see something <em>once</em>. If you see a problem on more\
    \ than one sample, it is real.</p>\n<p>P.S. This can also be done on multi-thread\
    \ programs if there is a way to collect call-stack samples of the thread pool\
    \ at a point in time, as there is in Java.</p>\n<p>P.P.S As a rough generality,\
    \ the more layers of abstraction you have in your software, the more likely you\
    \ are to find that that is the cause of performance problems (and the opportunity\
    \ to get speedup).</p>\n<p>Added: It might not be obvious, but the stack sampling\
    \ technique works equally well in the presence of recursion. The reason is that\
    \ the time that would be saved by removal of an instruction is approximated by\
    \ the fraction of samples containing it, regardless of the number of times it\
    \ may occur within a sample.</p>\n<p>Another objection I often hear is: \"<em>It\
    \ will stop someplace random, and it will miss the real problem</em>\".\nThis\
    \ comes from having a prior concept of what the real problem is.\nA key property\
    \ of performance problems is that they defy expectations.\nSampling tells you\
    \ something is a problem, and your first reaction is disbelief.\nThat is natural,\
    \ but you can be sure if it finds a problem it is real, and vice-versa.</p>\n\
    <p>ADDED: Let me make a Bayesian explanation of how it works.  Suppose there is\
    \ some instruction <code>I</code> (call or otherwise) which is on the call stack\
    \ some fraction <code>f</code> of the time (and thus costs that much). For simplicity,\
    \ suppose we don't know what <code>f</code> is, but assume it is either 0.1, 0.2,\
    \ 0.3, ... 0.9, 1.0, and the prior probability of each of these possibilities\
    \ is 0.1, so all of these costs are equally likely a-priori.</p>\n<p>Then suppose\
    \ we take just 2 stack samples, and we see instruction <code>I</code> on both\
    \ samples, designated observation <code>o=2/2</code>. This gives us new estimates\
    \ of the frequency <code>f</code> of <code>I</code>, according to this:</p>\n\
    <pre><code>Prior                                    \nP(f=x) x  P(o=2/2|f=x) P(o=2/2&amp;&amp;f=x)\
    \  P(o=2/2&amp;&amp;f &gt;= x)  P(f &gt;= x)\n\n0.1    1     1             0.1\
    \          0.1            0.25974026\n0.1    0.9   0.81          0.081       \
    \ 0.181          0.47012987\n0.1    0.8   0.64          0.064        0.245   \
    \       0.636363636\n0.1    0.7   0.49          0.049        0.294          0.763636364\n\
    0.1    0.6   0.36          0.036        0.33           0.857142857\n0.1    0.5\
    \   0.25          0.025        0.355          0.922077922\n0.1    0.4   0.16 \
    \         0.016        0.371          0.963636364\n0.1    0.3   0.09         \
    \ 0.009        0.38           0.987012987\n0.1    0.2   0.04          0.004  \
    \      0.384          0.997402597\n0.1    0.1   0.01          0.001        0.385\
    \          1\n\n                  P(o=2/2) 0.385                \n</code></pre>\n\
    <p>The last column says that, for example, the probability that <code>f</code>\
    \ &gt;= 0.5 is 92%, up from the prior assumption of 60%.</p>\n<p>Suppose the prior\
    \ assumptions are different. Suppose we assume P(f=0.1) is .991 (nearly certain),\
    \ and all the other possibilities are almost impossible (0.001). In other words,\
    \ our prior certainty is that <code>I</code> is cheap. Then we get:</p>\n<pre><code>Prior\
    \                                    \nP(f=x) x  P(o=2/2|f=x) P(o=2/2&amp;&amp;\
    \ f=x)  P(o=2/2&amp;&amp;f &gt;= x)  P(f &gt;= x)\n\n0.001  1    1           \
    \   0.001        0.001          0.072727273\n0.001  0.9  0.81           0.00081\
    \      0.00181        0.131636364\n0.001  0.8  0.64           0.00064      0.00245\
    \        0.178181818\n0.001  0.7  0.49           0.00049      0.00294        0.213818182\n\
    0.001  0.6  0.36           0.00036      0.0033         0.24\n0.001  0.5  0.25\
    \           0.00025      0.00355        0.258181818\n0.001  0.4  0.16        \
    \   0.00016      0.00371        0.269818182\n0.001  0.3  0.09           0.00009\
    \      0.0038         0.276363636\n0.001  0.2  0.04           0.00004      0.00384\
    \        0.279272727\n0.991  0.1  0.01           0.00991      0.01375        1\n\
    \n                  P(o=2/2) 0.01375                \n</code></pre>\n<p>Now it\
    \ says P(f &gt;= 0.5) is 26%, up from the prior assumption of 0.6%. So Bayes allows\
    \ us to update our estimate of the probable cost of <code>I</code>. If the amount\
    \ of data is small, it doesn't tell us accurately what the cost is, only that\
    \ it is big enough to be worth fixing.</p>\n<p>Yet another way to look at it is\
    \ called the <a href=\"http://en.wikipedia.org/wiki/Rule_of_succession\" rel=\"\
    noreferrer\">Rule Of Succession</a>.\nIf you flip a coin 2 times, and it comes\
    \ up heads both times, what does that tell you about the probable weighting of\
    \ the coin?\nThe respected way to answer is to say that it's a Beta distribution,\
    \ with average value (number of hits + 1) / (number of tries + 2) = (2+1)/(2+2)\
    \ = 75%.</p>\n<p>(The key is that we see <code>I</code> more than once. If we\
    \ only see it once, that doesn't tell us much except that <code>f</code> &gt;\
    \ 0.)</p>\n<p>So, even a very small number of samples can tell us a lot about\
    \ the cost of instructions that it sees. (And it will see them with a frequency,\
    \ on average, proportional to their cost. If <code>n</code> samples are taken,\
    \ and <code>f</code> is the cost, then <code>I</code> will appear on <code>nf+/-sqrt(nf(1-f))</code>\
    \ samples. Example, <code>n=10</code>, <code>f=0.3</code>, that is <code>3+/-1.4</code>\
    \ samples.)</p>\n<hr/>\n<p>ADDED, to give an intuitive feel for the difference\
    \ between measuring and random stack sampling:<br/>\nThere are profilers now that\
    \ sample the stack, even on wall-clock time, but <em>what comes out</em> is measurements\
    \ (or hot path, or hot spot, from which a \"bottleneck\" can easily hide). What\
    \ they don't show you (and they easily could) is the actual samples themselves.\
    \ And if your goal is to <em>find</em> the bottleneck, the number of them you\
    \ need to see is, <em>on average</em>, 2 divided by the fraction of time it takes.\n\
    So if it takes 30% of time, 2/.3 = 6.7 samples, on average, will show it, and\
    \ the chance that 20 samples will show it is 99.2%.</p>\n<p>Here is an off-the-cuff\
    \ illustration of the difference between examining measurements and examining\
    \ stack samples.\nThe bottleneck could be one big blob like this, or numerous\
    \ small ones, it makes no difference.</p>\n<p><a href=\"https://i.stack.imgur.com/FpWuS.png\"\
    \ rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/FpWuS.png\"\
    /></a></p>\n<p>Measurement is horizontal; it tells you what fraction of time specific\
    \ routines take.\nSampling is vertical.\nIf there is any way to avoid what the\
    \ whole program is doing at that moment, <em>and if you see it on a second sample</em>,\
    \ you've found the bottleneck.\nThat's what makes the difference - seeing the\
    \ whole reason for the time being spent, not just how much.</p>\n</div>"
- - How can I profile C++ code running on Linux?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>You can use <a href=\"http://en.wikipedia.org/wiki/Valgrind\"\
    \ rel=\"noreferrer\">Valgrind</a> with the following options</p>\n<pre><code>valgrind\
    \ --tool=callgrind ./(Your binary)\n</code></pre>\n<p>It will generate a file\
    \ called <code>callgrind.out.x</code>. You can then use <code>kcachegrind</code>\
    \ tool to read this file. It will give you a graphical analysis of things with\
    \ results like which lines cost how much. </p>\n</div>"
- - How can I profile C++ code running on Linux?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>I assume you're using GCC. The\
    \ standard solution would be to profile with <a href=\"http://www.math.utah.edu/docs/info/gprof_toc.html\"\
    \ rel=\"noreferrer\">gprof</a>.</p>\n<p>Be sure to add <code>-pg</code> to compilation\
    \ before profiling:</p>\n<pre><code>cc -o myprog myprog.c utils.c -g -pg\n</code></pre>\n\
    <p>I haven't tried it yet but I've heard good things about <a href=\"https://github.com/gperftools/gperftools\"\
    \ rel=\"noreferrer\">google-perftools</a>. It is definitely worth a try.</p>\n\
    <p>Related question <a href=\"https://stackoverflow.com/questions/56672/how-do-you-profile-your-code\"\
    >here</a>.</p>\n<p>A few other buzzwords if <code>gprof</code> does not do the\
    \ job for you: <a href=\"http://en.wikipedia.org/wiki/Valgrind\" rel=\"noreferrer\"\
    >Valgrind</a>, Intel <a href=\"http://en.wikipedia.org/wiki/VTune\" rel=\"noreferrer\"\
    >VTune</a>, Sun <a href=\"http://en.wikipedia.org/wiki/DTrace\" rel=\"noreferrer\"\
    >DTrace</a>.</p>\n</div>"
- - Cycles in family tree software
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>It seems you (and/or your company)\
    \ have a fundamental misunderstanding of what a family tree is supposed to be.\
    \ </p>\n<p>Let me clarify, I also work for a company that has (as one of its products)\
    \ a family tree in its portfolio, and we have been struggling with similar problems.</p>\n\
    <p>The problem, in our case, and I assume your case as well, comes from the <a\
    \ href=\"http://en.wikipedia.org/wiki/GEDCOM\" rel=\"noreferrer\">GEDCOM</a> format\
    \ that is extremely opinionated about what a family should be. However this format\
    \ contains some severe misconceptions about what a family tree really looks like.</p>\n\
    <p>GEDCOM has many issues, such as incompatibility with same sex relations, incest,\
    \ etc... Which in real life happens more often than you'd imagine (especially\
    \ when going back in time to the 1700-1800).</p>\n<p>We have modeled our family\
    \ tree to what happens in the real world: Events (for example, births, weddings,\
    \ engagement, unions, deaths, adoptions, etc.). We do not put any restrictions\
    \ on these, except for logically impossible ones (for example, one can't be one's\
    \ own parent, relations need two individuals, etc...)</p>\n<p>The lack of validations\
    \ gives us a more \"real world\", simpler and more flexible solution.</p>\n<p>As\
    \ for this specific case, I would suggest removing the assertions as they do not\
    \ hold universally.</p>\n<p>For displaying issues (that will arise) I would suggest\
    \ drawing the same node as many times as needed, hinting at the duplication by\
    \ lighting up all the copies on selecting one of them.</p>\n</div>"
- - Cycles in family tree software
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Relax your assertions.</p>\n\
    <p>Not by changing the rules, which are mostly likely very helpful to 99.9% of\
    \ your customers in catching mistakes in entering their data.</p>\n<p>Instead,\
    \ change it from an error \"can't add relationship\" to a warning with an \"add\
    \ anyway\".</p>\n</div>"
- - Cycles in family tree software
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Here's the problem with family\
    \ trees: they are not trees. They are directed acyclic graphs or DAGs. If I understand\
    \ the principles of the biology of human reproduction correctly, there will not\
    \ be any cycles.</p>\n<p>As far as I know, even the Christians accept marriages\
    \ (and thus children) between cousins, which will turn the family tree into a\
    \ family DAG.</p>\n<p>The moral of the story is: choose the right data structures.</p>\n\
    </div>"
- - Regular cast vs. static_cast vs. dynamic_cast [duplicate]
  - "<div class=\"post-text\" itemprop=\"text\">\n<h2>static_cast</h2>\n<p><code>static_cast</code>\
    \ is used for cases where you basically want to reverse an implicit conversion,\
    \ with a few restrictions and additions. <code>static_cast</code> performs no\
    \ runtime checks. This should be used if you know that you refer to an object\
    \ of a specific type, and thus a check would be unnecessary. Example:</p>\n<pre><code>void\
    \ func(void *data) {\n  // Conversion from MyClass* -&gt; void* is implicit\n\
    \  MyClass *c = static_cast&lt;MyClass*&gt;(data);\n  ...\n}\n\nint main() {\n\
    \  MyClass c;\n  start_thread(&amp;func, &amp;c)  // func(&amp;c) will be called\n\
    \      .join();\n}\n</code></pre>\n<p>In this example, you know that you passed\
    \ a <code>MyClass</code> object, and thus there isn't any need for a runtime check\
    \ to ensure this.</p>\n<h2>dynamic_cast</h2>\n<p><code>dynamic_cast</code> is\
    \ useful when you don't know what the dynamic type of the object is. It returns\
    \ a null pointer if the object referred to doesn't contain the type casted to\
    \ as a base class (when you cast to a reference, a <code>bad_cast</code> exception\
    \ is thrown in that case).</p>\n<pre><code>if (JumpStm *j = dynamic_cast&lt;JumpStm*&gt;(&amp;stm))\
    \ {\n  ...\n} else if (ExprStm *e = dynamic_cast&lt;ExprStm*&gt;(&amp;stm)) {\n\
    \  ...\n}\n</code></pre>\n<p>You cannot use <code>dynamic_cast</code> if you downcast\
    \ (cast to a derived class) and the argument type is not polymorphic. For example,\
    \ the following code is not valid, because <code>Base</code> doesn't contain any\
    \ virtual function:</p>\n<pre><code>struct Base { };\nstruct Derived : Base {\
    \ };\nint main() {\n  Derived d; Base *b = &amp;d;\n  dynamic_cast&lt;Derived*&gt;(b);\
    \ // Invalid\n}\n</code></pre>\n<p>An \"up-cast\" (cast to the base class) is\
    \ always valid with both <code>static_cast</code> and <code>dynamic_cast</code>,\
    \ and also without any cast, as an \"up-cast\" is an implicit conversion.</p>\n\
    <h2>Regular Cast</h2>\n<p>These casts are also called C-style cast. A C-style\
    \ cast is basically identical to trying out a range of sequences of C++ casts,\
    \ and taking the first C++ cast that works, without ever considering <code>dynamic_cast</code>.\
    \ Needless to say, this is much more powerful as it combines all of <code>const_cast</code>,\
    \ <code>static_cast</code> and <code>reinterpret_cast</code>, but it's also unsafe,\
    \ because it does not use <code>dynamic_cast</code>.</p>\n<p>In addition, C-style\
    \ casts not only allow you to do this, but they also allow you to safely cast\
    \ to a private base-class, while the \"equivalent\" <code>static_cast</code> sequence\
    \ would give you a compile-time error for that.</p>\n<p>Some people prefer C-style\
    \ casts because of their brevity. I use them for numeric casts only, and use the\
    \ appropriate C++ casts when user defined types are involved, as they provide\
    \ stricter checking.</p>\n</div>"
- - Regular cast vs. static_cast vs. dynamic_cast [duplicate]
  - "<div class=\"post-text\" itemprop=\"text\">\n<h2>Static cast</h2>\n<p>The static\
    \ cast performs conversions between compatible types. It is similar to the C-style\
    \ cast, but is more restrictive. For example, the C-style cast would allow an\
    \ integer pointer to point to a char.</p>\n<pre><code>char c = 10;       // 1\
    \ byte\nint *p = (int*)&amp;c; // 4 bytes\n</code></pre>\n<p>Since this results\
    \ in a 4-byte pointer pointing to 1 byte of allocated memory, writing to this\
    \ pointer will either cause a run-time error or will overwrite some adjacent memory.</p>\n\
    <pre><code>*p = 5; // run-time error: stack corruption\n</code></pre>\n<p>In contrast\
    \ to the C-style cast, the static cast will allow the compiler to check that the\
    \ pointer and pointee data types are compatible, which allows the programmer to\
    \ catch this incorrect pointer assignment during compilation.</p>\n<pre><code>int\
    \ *q = static_cast&lt;int*&gt;(&amp;c); // compile-time error\n</code></pre>\n\
    <h2>Reinterpret cast</h2>\n<p>To force the pointer conversion, in the same way\
    \ as the C-style cast does in the background, the reinterpret cast would be used\
    \ instead.</p>\n<pre><code>int *r = reinterpret_cast&lt;int*&gt;(&amp;c); // forced\
    \ conversion\n</code></pre>\n<p>This cast handles conversions between certain\
    \ unrelated types, such as from one pointer type to another incompatible pointer\
    \ type. It will simply perform a binary copy of the data without altering the\
    \ underlying bit pattern. Note that the result of such a low-level operation is\
    \ system-specific and therefore not portable. It should be used with caution if\
    \ it cannot be avoided altogether.</p>\n<h2>Dynamic cast</h2>\n<p>This one is\
    \ only used to convert object pointers and object references into other pointer\
    \ or reference types in the inheritance hierarchy. It is the only cast that makes\
    \ sure that the object pointed to can be converted, by performing a run-time check\
    \ that the pointer refers to a complete object of the destination type. For this\
    \ run-time check to be possible the object must be polymorphic. That is, the class\
    \ must define or inherit at least one virtual function. This is because the compiler\
    \ will only generate the needed run-time type information for such objects.</p>\n\
    <p><strong>Dynamic cast examples</strong></p>\n<p>In the example below, a MyChild\
    \ pointer is converted into a MyBase pointer using a dynamic cast. This derived-to-base\
    \ conversion succeeds, because the Child object includes a complete Base object.</p>\n\
    <pre><code>class MyBase \n{ \n  public:\n  virtual void test() {}\n};\nclass MyChild\
    \ : public MyBase {};\n\n\n\nint main()\n{\n  MyChild *child = new MyChild();\n\
    \  MyBase  *base = dynamic_cast&lt;MyBase*&gt;(child); // ok\n}\n</code></pre>\n\
    <p>The next example attempts to convert a MyBase pointer to a MyChild pointer.\
    \ Since the Base object does not contain a complete Child object this pointer\
    \ conversion will fail. To indicate this, the dynamic cast returns a null pointer.\
    \ This gives a convenient way to check whether or not a conversion has succeeded\
    \ during run-time.</p>\n<pre><code>MyBase  *base = new MyBase();\nMyChild *child\
    \ = dynamic_cast&lt;MyChild*&gt;(base);\n\n\nif (child == 0) \nstd::cout &lt;&lt;\
    \ \"Null pointer returned\";\n</code></pre>\n<p>If a reference is converted instead\
    \ of a pointer, the dynamic cast will then fail by throwing a bad_cast exception.\
    \ This needs to be handled using a try-catch statement.</p>\n<pre><code>#include\
    \ &lt;exception&gt;\n// …  \ntry\n{ \n  MyChild &amp;child = dynamic_cast&lt;MyChild&amp;&gt;(*base);\n\
    }\ncatch(std::bad_cast &amp;e) \n{ \n  std::cout &lt;&lt; e.what(); // bad dynamic_cast\n\
    }\n</code></pre>\n<h2>Dynamic or static cast</h2>\n<p>The advantage of using a\
    \ dynamic cast is that it allows the programmer to check whether or not a conversion\
    \ has succeeded during run-time. The disadvantage is that there is a performance\
    \ overhead associated with doing this check. For this reason using a static cast\
    \ would have been preferable in the first example, because a derived-to-base conversion\
    \ will never fail.</p>\n<pre><code>MyBase *base = static_cast&lt;MyBase*&gt;(child);\
    \ // ok\n</code></pre>\n<p>However, in the second example the conversion may either\
    \ succeed or fail. It will fail if the MyBase object contains a MyBase instance\
    \ and it will succeed if it contains a MyChild instance. In some situations this\
    \ may not be known until run-time. When this is the case dynamic cast is a better\
    \ choice than static cast.</p>\n<pre><code>// Succeeds for a MyChild object\n\
    MyChild *child = dynamic_cast&lt;MyChild*&gt;(base);\n</code></pre>\n<p>If the\
    \ base-to-derived conversion had been performed using a static cast instead of\
    \ a dynamic cast the conversion would not have failed. It would have returned\
    \ a pointer that referred to an incomplete object. Dereferencing such a pointer\
    \ can lead to run-time errors.</p>\n<pre><code>// Allowed, but invalid\nMyChild\
    \ *child = static_cast&lt;MyChild*&gt;(base);\n\n// Incomplete MyChild object\
    \ dereferenced\n(*child);\n</code></pre>\n<h2>Const cast</h2>\n<p>This one is\
    \ primarily used to add or remove the const modifier of a variable.</p>\n<pre><code>const\
    \ int myConst = 5;\nint *nonConst = const_cast&lt;int*&gt;(&amp;myConst); // removes\
    \ const\n</code></pre>\n<p>Although const cast allows the value of a constant\
    \ to be changed, doing so is still invalid code that may cause a run-time error.\
    \ This could occur for example if the constant was located in a section of read-only\
    \ memory.</p>\n<pre><code>*nonConst = 10; // potential run-time error\n</code></pre>\n\
    <p>Const cast is instead used mainly when there is a function that takes a non-constant\
    \ pointer argument, even though it does not modify the pointee.</p>\n<pre><code>void\
    \ print(int *p) \n{\n   std::cout &lt;&lt; *p;\n}\n</code></pre>\n<p>The function\
    \ can then be passed a constant variable by using a const cast.</p>\n<pre><code>print(&amp;myConst);\
    \ // error: cannot convert \n                 // const int* to int*\n\nprint(nonConst);\
    \ // allowed\n</code></pre>\n<p><a href=\"http://www.pvtuts.com/cpp/cpp-type-conversion-i\"\
    >Source and More Explanations</a></p>\n</div>"
- - Regular cast vs. static_cast vs. dynamic_cast [duplicate]
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>You should look at the article\
    \ <em><a href=\"http://en.wikibooks.org/wiki/C%2B%2B_Programming/Programming_Languages/C%2B%2B/Code/Statements/Variables/Type_Casting\"\
    \ rel=\"noreferrer\">C++ Programming/Type Casting</a></em>.</p>\n<p>It contains\
    \ a good description of all of the different cast types. The following taken from\
    \ the above link:</p>\n<blockquote>\n<p>const_cast</p>\n<p>const_cast(expression)\
    \ The const_cast&lt;&gt;() is used to add/remove\n  const(ness) (or volatile-ness)\
    \ of a variable.</p>\n<p>static_cast</p>\n<p>static_cast(expression) The static_cast&lt;&gt;()\
    \ is used to cast between\n  the integer types. 'e.g.' char-&gt;long, int-&gt;short\
    \ etc.</p>\n<p>Static cast is also used to cast pointers to related types, for\n\
    \  example casting void* to the appropriate type.</p>\n<p>dynamic_cast</p>\n<p>Dynamic\
    \ cast is used to convert pointers and references at run-time,\n  generally for\
    \ the purpose of casting a pointer or reference up or down\n  an inheritance chain\
    \ (inheritance hierarchy).</p>\n<p>dynamic_cast(expression)</p>\n<p>The target\
    \ type must be a pointer or reference type, and the\n  expression must evaluate\
    \ to a pointer or reference. Dynamic cast works\n  only when the type of object\
    \ to which the expression refers is\n  compatible with the target type and the\
    \ base class has at least one\n  virtual member function. If not, and the type\
    \ of expression being cast\n  is a pointer, NULL is returned, if a dynamic cast\
    \ on a reference\n  fails, a bad_cast exception is thrown. When it doesn't fail,\
    \ dynamic\n  cast returns a pointer or reference of the target type to the object\n\
    \  to which expression referred.</p>\n<p>reinterpret_cast</p>\n<p>Reinterpret\
    \ cast simply casts one type bitwise to another. Any pointer\n  or integral type\
    \ can be casted to any other with reinterpret cast,\n  easily allowing for misuse.\
    \ For instance, with reinterpret cast one\n  might, unsafely, cast an integer\
    \ pointer to a string pointer.</p>\n</blockquote>\n</div>"
- - What is a smart pointer and when should I use one?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>A smart pointer is a class that\
    \ wraps a 'raw' (or 'bare') C++ pointer, to manage the lifetime of the object\
    \ being pointed to. There is no single smart pointer type, but all of them try\
    \ to abstract a raw pointer in a practical way.</p>\n<p>Smart pointers should\
    \ be preferred over raw pointers. If you feel you need to use pointers (first\
    \ consider if you <em>really</em> do), you would normally want to use a smart\
    \ pointer as this can alleviate many of the problems with raw pointers, mainly\
    \ forgetting to delete the object and leaking memory.</p>\n<p>With raw pointers,\
    \ the programmer has to explicitly destroy the object when it is no longer useful.</p>\n\
    <pre><code>// Need to create the object to achieve some goal\nMyObject* ptr =\
    \ new MyObject(); \nptr-&gt;DoSomething(); // Use the object in some way\ndelete\
    \ ptr; // Destroy the object. Done with it.\n// Wait, what if DoSomething() raises\
    \ an exception...?\n</code></pre>\n<p>A smart pointer by comparison defines a\
    \ policy as to when the object is destroyed. You still have to create the object,\
    \ but you no longer have to worry about destroying it.</p>\n<pre><code>SomeSmartPtr&lt;MyObject&gt;\
    \ ptr(new MyObject());\nptr-&gt;DoSomething(); // Use the object in some way.\n\
    \n// Destruction of the object happens, depending \n// on the policy the smart\
    \ pointer class uses.\n\n// Destruction would happen even if DoSomething() \n\
    // raises an exception\n</code></pre>\n<p>The simplest policy in use involves\
    \ the scope of the smart pointer wrapper object, such as implemented by <a href=\"\
    http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm\" rel=\"noreferrer\"\
    ><code>boost::scoped_ptr</code></a> or <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr\"\
    \ rel=\"noreferrer\"><code>std::unique_ptr</code></a>. </p>\n<pre><code>void f()\n\
    {\n    {\n       boost::scoped_ptr&lt;MyObject&gt; ptr(new MyObject());\n    \
    \   ptr-&gt;DoSomethingUseful();\n    } // boost::scopted_ptr goes out of scope\
    \ -- \n      // the MyObject is automatically destroyed.\n\n    // ptr-&gt;Oops();\
    \ // Compile error: \"ptr\" not defined\n                    // since it is no\
    \ longer in scope.\n}\n</code></pre>\n<p>Note that <code>scoped_ptr</code> instances\
    \ cannot be copied. This prevents the pointer from being deleted multiple times\
    \ (incorrectly). You can, however, pass references to it around to other functions\
    \ you call.</p>\n<p>Scoped pointers are useful when you want to tie the lifetime\
    \ of the object to a particular block of code, or if you embedded it as member\
    \ data inside another object, the lifetime of that other object. The object exists\
    \ until the containing block of code is exited, or until the containing object\
    \ is itself destroyed.</p>\n<p>A more complex smart pointer policy involves reference\
    \ counting the pointer. This does allow the pointer to be copied. When the last\
    \ \"reference\" to the object is destroyed, the object is deleted. This policy\
    \ is implemented by <a href=\"http://www.boost.org/doc/libs/release/libs/smart_ptr/shared_ptr.htm\"\
    \ rel=\"noreferrer\"><code>boost::shared_ptr</code></a> and <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\"\
    \ rel=\"noreferrer\"><code>std::shared_ptr</code></a>.</p>\n<pre><code>void f()\n\
    {\n    typedef std::shared_ptr&lt;MyObject&gt; MyObjectPtr; // nice short alias\n\
    \    MyObjectPtr p1; // Empty\n\n    {\n        MyObjectPtr p2(new MyObject());\n\
    \        // There is now one \"reference\" to the created object\n        p1 =\
    \ p2; // Copy the pointer.\n        // There are now two references to the object.\n\
    \    } // p2 is destroyed, leaving one reference to the object.\n} // p1 is destroyed,\
    \ leaving a reference count of zero. \n  // The object is deleted.\n</code></pre>\n\
    <p>Reference counted pointers are very useful when the lifetime of your object\
    \ is much more complicated, and is not tied directly to a particular section of\
    \ code or to another object.</p>\n<p>There is one drawback to reference counted\
    \ pointers — the possibility of creating a dangling reference:</p>\n<pre><code>//\
    \ Create the smart pointer on the heap\nMyObjectPtr* pp = new MyObjectPtr(new\
    \ MyObject())\n// Hmm, we forgot to destroy the smart pointer,\n// because of\
    \ that, the object is never destroyed!\n</code></pre>\n<p>Another possibility\
    \ is creating circular references:</p>\n<pre><code>struct Owner {\n   boost::shared_ptr&lt;Owner&gt;\
    \ other;\n};\n\nboost::shared_ptr&lt;Owner&gt; p1 (new Owner());\nboost::shared_ptr&lt;Owner&gt;\
    \ p2 (new Owner());\np1-&gt;other = p2; // p1 references p2\np2-&gt;other = p1;\
    \ // p2 references p1\n\n// Oops, the reference count of of p1 and p2 never goes\
    \ to zero!\n// The objects are never destroyed!\n</code></pre>\n<p>To work around\
    \ this problem, both Boost and C++11 have defined a <code>weak_ptr</code> to define\
    \ a weak (uncounted) reference to a <code>shared_ptr</code>.</p>\n<hr/>\n<p><strong>UPDATE</strong></p>\n\
    <p>This answer is rather old, and so describes what was 'good' at the time, which\
    \ was smart pointers provided by the Boost library. Since C++11, the standard\
    \ library has provided sufficient smart pointers types, and so you should favour\
    \ the use of <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr\" rel=\"\
    noreferrer\"><code>std::unique_ptr</code></a>, <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\"\
    \ rel=\"noreferrer\"><code>std::shared_ptr</code></a> and <a href=\"http://en.cppreference.com/w/cpp/memory/weak_ptr\"\
    \ rel=\"noreferrer\"><code>std::weak_ptr</code></a>. </p>\n<p>There is also <a\
    \ href=\"http://en.cppreference.com/w/cpp/memory/auto_ptr\" rel=\"noreferrer\"\
    ><code>std::auto_ptr</code></a>. It is very much like a scoped pointer, except\
    \ that it also has the \"special\" dangerous ability to be copied — which also\
    \ unexpectedly transfers ownership! <strong>It is deprecated in the newest standards,\
    \ so you shouldn't use it. Use the <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr\"\
    \ rel=\"noreferrer\"><code>std::unique_ptr</code></a> instead.</strong></p>\n\
    <pre><code>std::auto_ptr&lt;MyObject&gt; p1 (new MyObject());\nstd::auto_ptr&lt;MyObject&gt;\
    \ p2 = p1; // Copy and transfer ownership. \n                                \
    \ // p1 gets set to empty!\np2-&gt;DoSomething(); // Works.\np1-&gt;DoSomething();\
    \ // Oh oh. Hopefully raises some NULL pointer exception.\n</code></pre>\n</div>"
- - What is a smart pointer and when should I use one?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Here's a simple answer for these\
    \ days of modern C++:</p>\n<ul>\n<li><strong>What is a smart pointer?</strong>\
    \ <br/>\nIt's a type whose values can be used like pointers, but which provides\
    \ the additional feature of automatic memory management: When a smart pointer\
    \ is no longer in use, the memory it points to is deallocated (see also <a href=\"\
    http://en.wikipedia.org/wiki/Smart_pointer\" rel=\"noreferrer\">the more detailed\
    \ definition on Wikipedia</a>).</li>\n<li><strong>When should I use one?</strong>\
    \ <br/>\nIn code which involves tracking the ownership of a piece of memory, allocating\
    \ or de-allocating; the smart pointer often saves you the need to do these things\
    \ explicitly.</li>\n<li><strong>But which smart pointer should I use in which\
    \ of those cases?</strong>\n<ul>\n<li>Use <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr\"\
    \ rel=\"noreferrer\"><code>std::unique_ptr</code></a> when you don't intend to\
    \ hold multiple references to the same object. For example, use it for a pointer\
    \ to memory which gets allocated on entering some scope and de-allocated on exiting\
    \ the scope.</li>\n<li>Use <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\"\
    \ rel=\"noreferrer\"><code>std::shared_ptr</code></a> when you do want to refer\
    \ to your object from multiple places - and do not want your object to be de-allocated\
    \ until all these references are themselves gone.</li>\n<li>Use <a href=\"http://en.cppreference.com/w/cpp/memory/weak_ptr\"\
    \ rel=\"noreferrer\"><code>std::weak_ptr</code></a> when you do want to refer\
    \ to your object from multiple places - for those references for which it's ok\
    \ to ignore and deallocate (so they'll just note the object is gone when you try\
    \ to dereference).</li>\n<li>Don't use the <code>boost::</code> smart pointers\
    \ or <code>std::auto_ptr</code> except in special cases which you can read up\
    \ on if you must.</li>\n</ul></li>\n<li><strong>Hey, I didn't ask which one to\
    \ use!</strong> <br/>\nAh, but you really wanted to, admit it.</li>\n<li><strong>So\
    \ when should I use regular pointers then?</strong> <br/>\nMostly in code that\
    \ is oblivious to memory ownership. This would typically be in functions which\
    \ get a pointer from someplace else and do not allocatemor de-allocate, and do\
    \ not store a copy of the pointer which outlasts their execution.</li>\n</ul>\n\
    </div>"
- - What is a smart pointer and when should I use one?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p><a href=\"http://en.wikipedia.org/wiki/Smart_pointer\"\
    \ rel=\"noreferrer\">Smart pointer</a> is a pointer-like type with some additional\
    \ functionality, e.g. automatic memory deallocation, reference counting etc.</p>\n\
    <p>Small intro is available on page <a href=\"http://ootips.org/yonat/4dev/smart-pointers.html\"\
    \ rel=\"noreferrer\">Smart Pointers - What, Why, Which?</a>.</p>\n<p>One of the\
    \ simple smart-pointer type is <a href=\"http://en.cppreference.com/w/cpp/memory/auto_ptr\"\
    \ rel=\"noreferrer\"><code>std::auto_ptr</code></a> (chapter 20.4.5 of C++ standard),\
    \ which allows to deallocate memory automatically when it out of scope and which\
    \ is more robust than simple pointer usage when exceptions are thrown, although\
    \ less flexible.</p>\n<p>Another convenient type is <a href=\"http://www.boost.org/doc/libs/1_36_0/libs/smart_ptr/shared_ptr.htm\"\
    \ rel=\"noreferrer\"><code>boost::shared_ptr</code></a> which implements reference\
    \ counting and automatically deallocates memory when no references to object remains.\
    \ This helps avoiding memory leaks and is easy to use to implement <a href=\"\
    http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" rel=\"noreferrer\"\
    >RAII</a>.</p>\n<p>Subject is covered in depth in book <a href=\"https://rads.stackoverflow.com/amzn/click/com/0201734842\"\
    \ rel=\"noreferrer\">\"C++ Templates: The Complete Guide\" by David Vandevoorde,\
    \ Nicolai M. Josuttis</a>, chapter Chapter 20. Smart Pointers.\nSome topics covered:</p>\n\
    <ul>\n<li>Protecting Against Exceptions</li>\n<li>Holders, (note, <a href=\"http://en.cppreference.com/w/cpp/memory/auto_ptr\"\
    \ rel=\"noreferrer\">std::auto_ptr</a> is implementation of such type of smart\
    \ pointer)</li>\n<li><a href=\"http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization\"\
    \ rel=\"noreferrer\">Resource Acquisition Is Initialization</a> (This is frequently\
    \ used for exception-safe resource management in C++)</li>\n<li>Holder Limitations</li>\n\
    <li><a href=\"http://en.wikipedia.org/wiki/Reference_counting\" rel=\"noreferrer\"\
    >Reference Counting</a></li>\n<li>Concurrent Counter Access</li>\n<li>Destruction\
    \ and Deallocation</li>\n</ul>\n</div>"
- - Why can templates only be implemented in the header file?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>It is <em>not</em> necessary\
    \ to put the implementation in the header file, see the alternative solution at\
    \ the end of this answer.</p>\n<p>Anyway, the reason your code is failing is that,\
    \ when instantiating a template, the compiler creates a new class with the given\
    \ template argument. For example:</p>\n<pre><code>template&lt;typename T&gt;\n\
    struct Foo\n{\n    T bar;\n    void doSomething(T param) {/* do stuff using T\
    \ */}\n};\n\n// somewhere in a .cpp\nFoo&lt;int&gt; f; \n</code></pre>\n<p>When\
    \ reading this line, the compiler will create a new class (let's call it <code>FooInt</code>),\
    \ which is equivalent to the following:</p>\n<pre><code>struct FooInt\n{\n   \
    \ int bar;\n    void doSomething(int param) {/* do stuff using int */}\n}\n</code></pre>\n\
    <p>Consequently, the compiler needs to have access to the implementation of the\
    \ methods, to instantiate them with the template argument (in this case <code>int</code>).\
    \ If these implementations were not in the header, they wouldn't be accessible,\
    \ and therefore the compiler wouldn't be able to instantiate the template.</p>\n\
    <p>A common solution to this is to write the template declaration in a header\
    \ file, then implement the class in an implementation file (for example .tpp),\
    \ and include this implementation file at the end of the header.</p>\n<pre><code>//\
    \ Foo.h\ntemplate &lt;typename T&gt;\nstruct Foo\n{\n    void doSomething(T param);\n\
    };\n\n#include \"Foo.tpp\"\n\n// Foo.tpp\ntemplate &lt;typename T&gt;\nvoid Foo&lt;T&gt;::doSomething(T\
    \ param)\n{\n    //implementation\n}\n</code></pre>\n<p>This way, implementation\
    \ is still separated from declaration, but is accessible to the compiler.</p>\n\
    <p>Another solution is to keep the implementation separated, and explicitly instantiate\
    \ all the template instances you'll need:</p>\n<pre><code>// Foo.h\n\n// no implementation\n\
    template &lt;typename T&gt; struct Foo { ... };\n\n//----------------------------------------\
    \    \n// Foo.cpp\n\n// implementation of Foo's methods\n\n// explicit instantiations\n\
    template class Foo&lt;int&gt;;\ntemplate class Foo&lt;float&gt;;\n// You will\
    \ only be able to use Foo with int or float\n</code></pre>\n<p>If my explanation\
    \ isn't clear enough, you can have a look at the <a href=\"https://isocpp.org/wiki/faq/templates#templates-defn-vs-decl\"\
    \ rel=\"noreferrer\">C++ Super-FAQ on this subject</a>.</p>\n</div>"
- - Why can templates only be implemented in the header file?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Plenty correct answers here,\
    \ but I wanted to add this (for completeness):</p>\n<p>If you, at the bottom of\
    \ the implementation cpp file, do explicit instantiation of all the types the\
    \ template will be used with, the linker will be able to find them as usual.</p>\n\
    <p>Edit: Adding example of explicit template instantiation. Used after the template\
    \ has been defined, and all member functions has been defined.</p>\n<pre><code>template\
    \ class vector&lt;int&gt;;\n</code></pre>\n<p>This will instantiate (and thus\
    \ make available to the linker) the class and all its member functions (only).\
    \ Similar syntax works for template functions, so if you have non-member operator\
    \ overloads you may need to do the same for those.</p>\n<p>The above example is\
    \ fairly useless since vector is fully defined in headers, except when a common\
    \ include file (precompiled header?) uses <code>extern template class vector&lt;int&gt;</code>\
    \ so as to keep it from instantiating it in all the <em>other</em> (1000?) files\
    \ that use vector. </p>\n</div>"
- - Why can templates only be implemented in the header file?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>It's because of the requirement\
    \ for separate compilation and because templates are instantiation-style polymorphism.</p>\n\
    <p>Lets get a little closer to concrete for an explanation. Say I've got the following\
    \ files:</p>\n<ul>\n<li>foo.h\n<ul>\n<li>declares the interface of <code>class\
    \ MyClass&lt;T&gt;</code></li>\n</ul></li>\n<li>foo.cpp\n<ul>\n<li>defines the\
    \ implementation of <code>class MyClass&lt;T&gt;</code></li>\n</ul></li>\n<li>bar.cpp\n\
    <ul>\n<li>uses <code>MyClass&lt;int&gt;</code></li>\n</ul></li>\n</ul>\n<p>Separate\
    \ compilation means I should be able to compile <strong>foo.cpp</strong> independently\
    \ from <strong>bar.cpp</strong>. The compiler does all the hard work of analysis,\
    \ optimization, and code generation on each compilation unit completely independently;\
    \ we don't need to do whole-program analysis. It's only the linker that needs\
    \ to handle the entire program at once, and the linker's job is substantially\
    \ easier.</p>\n<p><strong>bar.cpp</strong> doesn't even need to exist when I compile\
    \ <strong>foo.cpp</strong>, but I should still be able to link the <strong>foo.o</strong>\
    \ I already had together with the <strong>bar.o</strong> I've only just produced,\
    \ without needing to recompile <strong>foo.cpp</strong>. <strong>foo.cpp</strong>\
    \ could even be compiled into a dynamic library, distributed somewhere else without\
    \ <strong>foo.cpp</strong>, and linked with code they write years after I wrote\
    \ <strong>foo.cpp</strong>.</p>\n<p>\"Instantiation-style polymorphism\" means\
    \ that the template <code>MyClass&lt;T&gt;</code> isn't really a generic class\
    \ that can be compiled to code that can work for any value of <code>T</code>.\
    \ That would add overhead such as boxing, needing to pass function pointers to\
    \ allocators and constructors, etc. The intention of C++ templates is to avoid\
    \ having to write nearly identical <code>class MyClass_int</code>, <code>class\
    \ MyClass_float</code>, etc, but to still be able to end up with compiled code\
    \ that is mostly as if we <em>had</em> written each version separately. So a template\
    \ is <em>literally</em> a template; a class template is <em>not</em> a class,\
    \ it's a recipe for creating a new class for each <code>T</code> we encounter.\
    \ A template cannot be compiled into code, only the result of instantiating the\
    \ template can be compiled.</p>\n<p>So when <strong>foo.cpp</strong> is compiled,\
    \ the compiler can't see <strong>bar.cpp</strong> to know that <code>MyClass&lt;int&gt;</code>\
    \ is needed. It can see the template <code>MyClass&lt;T&gt;</code>, but it can't\
    \ emit code for that (it's a template, not a class). And when <strong>bar.cpp</strong>\
    \ is compiled, the compiler can see that it needs to create a <code>MyClass&lt;int&gt;</code>,\
    \ but it can't see the template <code>MyClass&lt;T&gt;</code> (only its interface\
    \ in <strong>foo.h</strong>) so it can't create it.</p>\n<p>If <strong>foo.cpp</strong>\
    \ itself uses <code>MyClass&lt;int&gt;</code>, then code for that will be generated\
    \ while compiling <strong>foo.cpp</strong>, so when <strong>bar.o</strong> is\
    \ linked to <strong>foo.o</strong> they can be hooked up and will work. We can\
    \ use that fact to allow a finite set of template instantiations to be implemented\
    \ in a .cpp file by writing a single template. But there's no way for <strong>bar.cpp</strong>\
    \ to use the template <em>as a template</em> and instantiate it on whatever types\
    \ it likes; it can only use pre-existing versions of the templated class that\
    \ the author of <strong>foo.cpp</strong> thought to provide.</p>\n<p>You might\
    \ think that when compiling a template the compiler should \"generate all versions\"\
    , with the ones that are never used being filtered out during linking. Aside from\
    \ the huge overhead and the extreme difficulties such an approach would face because\
    \ \"type modifier\" features like pointers and arrays allow even just the built-in\
    \ types to give rise to an infinite number of types, what happens when I now extend\
    \ my program by adding:</p>\n<ul>\n<li>baz.cpp\n<ul>\n<li>declares and implements\
    \ <code>class BazPrivate</code>, and uses <code>MyClass&lt;BazPrivate&gt;</code></li>\n\
    </ul></li>\n</ul>\n<p>There is no possible way that this could work unless we\
    \ either</p>\n<ol>\n<li>Have to recompile <strong>foo.cpp</strong> every time\
    \ we change <em>any other file in the program</em>, in case it added a new novel\
    \ instantiation of <code>MyClass&lt;T&gt;</code></li>\n<li>Require that <strong>baz.cpp</strong>\
    \ contains (possibly via header includes) the full template of <code>MyClass&lt;T&gt;</code>,\
    \ so that the compiler can generate <code>MyClass&lt;BazPrivate&gt;</code> during\
    \ compilation of <strong>baz.cpp</strong>.</li>\n</ol>\n<p>Nobody likes (1), because\
    \ whole-program-analysis compilation systems take <em>forever</em> to compile\
    \ , and because it makes it impossible to distribute compiled libraries without\
    \ the source code. So we have (2) instead.</p>\n</div>"
- - What are move semantics?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>I find it easiest to understand\
    \ move semantics with example code. Let's start with a very simple string class\
    \ which only holds a pointer to a heap-allocated block of memory:</p>\n<pre><code>#include\
    \ &lt;cstring&gt;\n#include &lt;algorithm&gt;\n\nclass string\n{\n    char* data;\n\
    \npublic:\n\n    string(const char* p)\n    {\n        size_t size = strlen(p)\
    \ + 1;\n        data = new char[size];\n        memcpy(data, p, size);\n    }\n\
    </code></pre>\n<p>Since we chose to manage the memory ourselves, we need to follow\
    \ the <a href=\"http://en.wikipedia.org/wiki/Rule_of_three_%28C++_programming%29\"\
    \ rel=\"noreferrer\">rule of three</a>. I am going to defer writing the assignment\
    \ operator and only implement the destructor and the copy constructor for now:</p>\n\
    <pre><code>    ~string()\n    {\n        delete[] data;\n    }\n\n    string(const\
    \ string&amp; that)\n    {\n        size_t size = strlen(that.data) + 1;\n   \
    \     data = new char[size];\n        memcpy(data, that.data, size);\n    }\n\
    </code></pre>\n<p>The copy constructor defines what it means to copy string objects.\
    \ The parameter <code>const string&amp; that</code> binds to all expressions of\
    \ type string which allows you to make copies in the following examples:</p>\n\
    <pre><code>string a(x);                                    // Line 1\nstring b(x\
    \ + y);                                // Line 2\nstring c(some_function_returning_a_string());\
    \   // Line 3\n</code></pre>\n<p>Now comes the key insight into move semantics.\
    \ Note that only in the first line where we copy <code>x</code> is this deep copy\
    \ really necessary, because we might want to inspect <code>x</code> later and\
    \ would be very surprised if <code>x</code> had changed somehow. Did you notice\
    \ how I just said <code>x</code> three times (four times if you include this sentence)\
    \ and meant the <em>exact same object</em> every time? We call expressions such\
    \ as <code>x</code> \"lvalues\".</p>\n<p>The arguments in lines 2 and 3 are not\
    \ lvalues, but rvalues, because the underlying string objects have no names, so\
    \ the client has no way to inspect them again at a later point in time.\nrvalues\
    \ denote temporary objects which are destroyed at the next semicolon (to be more\
    \ precise: at the end of the full-expression that lexically contains the rvalue).\
    \ This is important because during the initialization of <code>b</code> and <code>c</code>,\
    \ we could do whatever we wanted with the source string, and <em>the client couldn't\
    \ tell a difference</em>!</p>\n<p>C++0x introduces a new mechanism called \"rvalue\
    \ reference\" which, among other things,\nallows us to detect rvalue arguments\
    \ via function overloading. All we have to do is write a constructor with an rvalue\
    \ reference parameter. Inside that constructor we can do <em>anything we want</em>\
    \ with the source, as long as we leave it in <em>some</em> valid state:</p>\n\
    <pre><code>    string(string&amp;&amp; that)   // string&amp;&amp; is an rvalue\
    \ reference to a string\n    {\n        data = that.data;\n        that.data =\
    \ nullptr;\n    }\n</code></pre>\n<p>What have we done here? Instead of deeply\
    \ copying the heap data, we have just copied the pointer and then set the original\
    \ pointer to null. In effect, we have \"stolen\" the data that originally belonged\
    \ to the source string. Again, the key insight is that under no circumstance could\
    \ the client detect that the source had been modified. Since we don't really do\
    \ a copy here, we call this constructor a \"move constructor\". Its job is to\
    \ move resources from one object to another instead of copying them.</p>\n<p>Congratulations,\
    \ you now understand the basics of move semantics! Let's continue by implementing\
    \ the assignment operator. If you're unfamiliar with the <a href=\"https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom\"\
    >copy and swap idiom</a>, learn it and come back, because it's an awesome C++\
    \ idiom related to exception safety.</p>\n<pre><code>    string&amp; operator=(string\
    \ that)\n    {\n        std::swap(data, that.data);\n        return *this;\n \
    \   }\n};\n</code></pre>\n<p>Huh, that's it? \"Where's the rvalue reference?\"\
    \ you might ask. \"We don't need it here!\" is my answer :)</p>\n<p>Note that\
    \ we pass the parameter <code>that</code> <em>by value</em>, so <code>that</code>\
    \ has to be initialized just like any other string object. Exactly how is <code>that</code>\
    \ going to be initialized? In the olden days of <a href=\"http://en.wikipedia.org/wiki/C++#Standardization\"\
    \ rel=\"noreferrer\">C++98</a>, the answer would have been \"by the copy constructor\"\
    . In C++0x, the compiler chooses between the copy constructor and the move constructor\
    \ based on whether the argument to the assignment operator is an lvalue or an\
    \ rvalue.</p>\n<p>So if you say <code>a = b</code>, the <em>copy constructor</em>\
    \ will initialize <code>that</code> (because the expression <code>b</code> is\
    \ an lvalue), and the assignment operator swaps the contents with a freshly created,\
    \ deep copy. That is the very definition of the copy and swap idiom -- make a\
    \ copy, swap the contents with the copy, and then get rid of the copy by leaving\
    \ the scope. Nothing new here.</p>\n<p>But if you say <code>a = x + y</code>,\
    \ the <em>move constructor</em> will initialize <code>that</code> (because the\
    \ expression <code>x + y</code> is an rvalue), so there is no deep copy involved,\
    \ only an efficient move.\n<code>that</code> is still an independent object from\
    \ the argument, but its construction was trivial,\nsince the heap data didn't\
    \ have to be copied, just moved. It wasn't necessary to copy it because <code>x\
    \ + y</code> is an rvalue, and again, it is okay to move from string objects denoted\
    \ by rvalues.</p>\n<p>To summarize, the copy constructor makes a deep copy, because\
    \ the source must remain untouched.\nThe move constructor, on the other hand,\
    \ can just copy the pointer and then set the pointer in the source to null. It\
    \ is okay to \"nullify\" the source object in this manner, because the client\
    \ has no way of inspecting the object again.</p>\n<p>I hope this example got the\
    \ main point across. There is a lot more to rvalue references and move semantics\
    \ which I intentionally left out to keep it simple. If you want more details please\
    \ see <a href=\"https://stackoverflow.com/a/11540204/179917\">my supplementary\
    \ answer</a>.</p>\n</div>"
- - What are move semantics?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>My first answer was an extremely\
    \ simplified introduction to move semantics, and many details were left out on\
    \ purpose to keep it simple.\nHowever, there is a lot more to move semantics,\
    \ and I thought it was time for a second answer to fill the gaps.\nThe first answer\
    \ is already quite old, and it did not feel right to simply replace it with a\
    \ completely different text. I think it still serves well as a first introduction.\
    \ But if you want to dig deeper, read on :)</p>\n<p>Stephan T. Lavavej took the\
    \ time provide valuable feedback. Thank you very much, Stephan!</p>\n<h2>Introduction</h2>\n\
    <p>Move semantics allows an object, under certain conditions, to take ownership\
    \ of some other object's external resources. This is important in two ways:</p>\n\
    <ol>\n<li><p>Turning expensive copies into cheap moves. See my first answer for\
    \ an example. Note that if an object does not manage at least one external resource\
    \ (either directly, or indirectly through its member objects), move semantics\
    \ will not offer any advantages over copy semantics. In that case, copying an\
    \ object and moving an object means the exact same thing:</p>\n<pre><code>class\
    \ cannot_benefit_from_move_semantics\n{\n    int a;        // moving an int means\
    \ copying an int\n    float b;      // moving a float means copying a float\n\
    \    double c;     // moving a double means copying a double\n    char d[64];\
    \   // moving a char array means copying a char array\n\n    // ...\n};\n</code></pre></li>\n\
    <li><p>Implementing safe \"move-only\" types; that is, types for which copying\
    \ does not make sense, but moving does.  Examples include locks, file handles,\
    \ and smart pointers with unique ownership semantics. Note: This answer discusses\
    \ <code>std::auto_ptr</code>, a deprecated C++98 standard library template, which\
    \ was replaced by <code>std::unique_ptr</code> in C++11. Intermediate C++ programmers\
    \ are probably at least somewhat familiar with <code>std::auto_ptr</code>, and\
    \ because of the \"move semantics\" it displays, it seems like a good starting\
    \ point for discussing move semantics in C++11. YMMV.</p></li>\n</ol>\n<h2>What\
    \ is a move?</h2>\n<p>The C++98 standard library offers a smart pointer with unique\
    \ ownership semantics called <code>std::auto_ptr&lt;T&gt;</code>. In case you\
    \ are unfamiliar with <code>auto_ptr</code>, its purpose is to guarantee that\
    \ a dynamically allocated object is always released, even in the face of exceptions:</p>\n\
    <pre><code>{\n    std::auto_ptr&lt;Shape&gt; a(new Triangle);\n    // ...\n  \
    \  // arbitrary code, could throw exceptions\n    // ...\n}   // &lt;--- when\
    \ a goes out of scope, the triangle is deleted automatically\n</code></pre>\n\
    <p>The unusual thing about <code>auto_ptr</code> is its \"copying\" behavior:</p>\n\
    <pre><code>auto_ptr&lt;Shape&gt; a(new Triangle);\n\n      +---------------+\n\
    \      | triangle data |\n      +---------------+\n        ^\n        |\n    \
    \    |\n        |\n  +-----|---+\n  |   +-|-+ |\na | p | | | |\n  |   +---+ |\n\
    \  +---------+\n\nauto_ptr&lt;Shape&gt; b(a);\n\n      +---------------+\n   \
    \   | triangle data |\n      +---------------+\n        ^\n        |\n       \
    \ +----------------------+\n                               |\n  +---------+  \
    \          +-----|---+\n  |   +---+ |            |   +-|-+ |\na | p |   | |  \
    \        b | p | | | |\n  |   +---+ |            |   +---+ |\n  +---------+  \
    \          +---------+\n</code></pre>\n<p>Note how the initialization of <code>b</code>\
    \ with <code>a</code> does <em>not</em> copy the triangle, but instead transfers\
    \ the ownership of the triangle from <code>a</code> to <code>b</code>. We also\
    \ say \"<code>a</code> is <em>moved into</em> <code>b</code>\" or \"the triangle\
    \ is <em>moved</em> from <code>a</code> <em>to</em> <code>b</code>\". This may\
    \ sound confusing, because the triangle itself always stays at the same place\
    \ in memory.</p>\n<blockquote>\n<p>To move an object means to transfer ownership\
    \ of some resource it manages to another object.</p>\n</blockquote>\n<p>The copy\
    \ constructor of <code>auto_ptr</code> probably looks something like this (somewhat\
    \ simplified):</p>\n<pre><code>auto_ptr(auto_ptr&amp; source)   // note the missing\
    \ const\n{\n    p = source.p;\n    source.p = 0;   // now the source no longer\
    \ owns the object\n}\n</code></pre>\n<h2>Dangerous and harmless moves</h2>\n<p>The\
    \ dangerous thing about <code>auto_ptr</code> is that what syntactically looks\
    \ like a copy is actually a move. Trying to call a member function on a moved-from\
    \ <code>auto_ptr</code> will invoke undefined behavior, so you have to be very\
    \ careful not to use an <code>auto_ptr</code> after it has been moved from:</p>\n\
    <pre><code>auto_ptr&lt;Shape&gt; a(new Triangle);   // create triangle\nauto_ptr&lt;Shape&gt;\
    \ b(a);              // move a into b\ndouble area = a-&gt;area();           //\
    \ undefined behavior\n</code></pre>\n<p>But <code>auto_ptr</code> is not <em>always</em>\
    \ dangerous. Factory functions are a perfectly fine use case for <code>auto_ptr</code>:</p>\n\
    <pre><code>auto_ptr&lt;Shape&gt; make_triangle()\n{\n    return auto_ptr&lt;Shape&gt;(new\
    \ Triangle);\n}\n\nauto_ptr&lt;Shape&gt; c(make_triangle());      // move temporary\
    \ into c\ndouble area = make_triangle()-&gt;area();   // perfectly safe\n</code></pre>\n\
    <p>Note how both examples follow the same syntactic pattern:</p>\n<pre><code>auto_ptr&lt;Shape&gt;\
    \ variable(expression);\ndouble area = expression-&gt;area();\n</code></pre>\n\
    <p>And yet, one of them invokes undefined behavior, whereas the other one does\
    \ not. So what is the difference between the expressions <code>a</code> and <code>make_triangle()</code>?\
    \ Aren't they both of the same type? Indeed they are, but they have different\
    \ <em>value categories</em>.</p>\n<h2>Value categories</h2>\n<p>Obviously, there\
    \ must be some profound difference between the expression <code>a</code> which\
    \ denotes an <code>auto_ptr</code> variable, and the expression <code>make_triangle()</code>\
    \ which denotes the call of a function that returns an <code>auto_ptr</code> by\
    \ value, thus creating a fresh temporary <code>auto_ptr</code> object every time\
    \ it is called. <code>a</code> is an example of an <em>lvalue</em>, whereas <code>make_triangle()</code>\
    \ is an example of an <em>rvalue</em>.</p>\n<p>Moving from lvalues such as <code>a</code>\
    \ is dangerous, because we could later try to call a member function via <code>a</code>,\
    \ invoking undefined behavior. On the other hand, moving from rvalues such as\
    \ <code>make_triangle()</code> is perfectly safe, because after the copy constructor\
    \ has done its job, we cannot use the temporary again. There is no expression\
    \ that denotes said temporary; if we simply write <code>make_triangle()</code>\
    \ again, we get a <em>different</em> temporary. In fact, the moved-from temporary\
    \ is already gone on the next line:</p>\n<pre><code>auto_ptr&lt;Shape&gt; c(make_triangle());\n\
    \                                  ^ the moved-from temporary dies right here\n\
    </code></pre>\n<p>Note that the letters <code>l</code> and <code>r</code> have\
    \ a historic origin in the left-hand side and right-hand side of an assignment.\
    \ This is no longer true in C++, because there are lvalues which cannot appear\
    \ on the left-hand side of an assignment (like arrays or user-defined types without\
    \ an assignment operator), and there are rvalues which can (all rvalues of class\
    \ types with an assignment operator).</p>\n<blockquote>\n<p>An rvalue of class\
    \ type is an expression whose evaluation creates a temporary object.\n  Under\
    \ normal circumstances, no other expression inside the same scope denotes the\
    \ same temporary object.</p>\n</blockquote>\n<h2>Rvalue references</h2>\n<p>We\
    \ now understand that moving from lvalues is potentially dangerous, but moving\
    \ from rvalues is harmless. If C++ had language support to distinguish lvalue\
    \ arguments from rvalue arguments, we could either completely forbid moving from\
    \ lvalues, or at least make moving from lvalues <em>explicit</em> at call site,\
    \ so that we no longer move by accident.</p>\n<p>C++11's answer to this problem\
    \ is <em>rvalue references</em>. An rvalue reference is a new kind of reference\
    \ that only binds to rvalues, and the syntax is <code>X&amp;&amp;</code>. The\
    \ good old reference <code>X&amp;</code> is now known as an <em>lvalue reference</em>.\
    \ (Note that <code>X&amp;&amp;</code> is <em>not</em> a reference to a reference;\
    \ there is no such thing in C++.)</p>\n<p>If we throw <code>const</code> into\
    \ the mix, we already have four different kinds of references. What kinds of expressions\
    \ of type <code>X</code> can they bind to?</p>\n<pre><code>            lvalue\
    \   const lvalue   rvalue   const rvalue\n---------------------------------------------------------\
    \              \nX&amp;          yes\nconst X&amp;    yes      yes           \
    \ yes      yes\nX&amp;&amp;                                 yes\nconst X&amp;&amp;\
    \                           yes      yes\n</code></pre>\n<p>In practice, you can\
    \ forget about <code>const X&amp;&amp;</code>. Being restricted to read from rvalues\
    \ is not very useful.</p>\n<blockquote>\n<p>An rvalue reference <code>X&amp;&amp;</code>\
    \ is a new kind of reference that only binds to rvalues.</p>\n</blockquote>\n\
    <h2>Implicit conversions</h2>\n<p>Rvalue references went through several versions.\
    \ Since version 2.1, an rvalue reference <code>X&amp;&amp;</code> also binds to\
    \ all value categories of a different type <code>Y</code>, provided there is an\
    \ implicit conversion from <code>Y</code> to <code>X</code>. In that case, a temporary\
    \ of type <code>X</code> is created, and the rvalue reference is bound to that\
    \ temporary:</p>\n<pre><code>void some_function(std::string&amp;&amp; r);\n\n\
    some_function(\"hello world\");\n</code></pre>\n<p>In the above example, <code>\"\
    hello world\"</code> is an lvalue of type <code>const char[12]</code>. Since there\
    \ is an implicit conversion from <code>const char[12]</code> through <code>const\
    \ char*</code> to <code>std::string</code>, a temporary of type <code>std::string</code>\
    \ is created, and <code>r</code> is bound to that temporary. This is one of the\
    \ cases where the distinction between rvalues (expressions) and temporaries (objects)\
    \ is a bit blurry.</p>\n<h2>Move constructors</h2>\n<p>A useful example of a function\
    \ with an <code>X&amp;&amp;</code> parameter is the <em>move constructor</em>\
    \ <code>X::X(X&amp;&amp; source)</code>. Its purpose is to transfer ownership\
    \ of the managed resource from the source into the current object.</p>\n<p>In\
    \ C++11, <code>std::auto_ptr&lt;T&gt;</code> has been replaced by <code>std::unique_ptr&lt;T&gt;</code>\
    \ which takes advantage of rvalue references. I will develop and discuss a simplified\
    \ version of <code>unique_ptr</code>. First, we encapsulate a raw pointer and\
    \ overload the operators <code>-&gt;</code> and <code>*</code>, so our class feels\
    \ like a pointer:</p>\n<pre><code>template&lt;typename T&gt;\nclass unique_ptr\n\
    {\n    T* ptr;\n\npublic:\n\n    T* operator-&gt;() const\n    {\n        return\
    \ ptr;\n    }\n\n    T&amp; operator*() const\n    {\n        return *ptr;\n \
    \   }\n</code></pre>\n<p>The constructor takes ownership of the object, and the\
    \ destructor deletes it:</p>\n<pre><code>    explicit unique_ptr(T* p = nullptr)\n\
    \    {\n        ptr = p;\n    }\n\n    ~unique_ptr()\n    {\n        delete ptr;\n\
    \    }\n</code></pre>\n<p>Now comes the interesting part, the move constructor:</p>\n\
    <pre><code>    unique_ptr(unique_ptr&amp;&amp; source)   // note the rvalue reference\n\
    \    {\n        ptr = source.ptr;\n        source.ptr = nullptr;\n    }\n</code></pre>\n\
    <p>This move constructor does exactly what the <code>auto_ptr</code> copy constructor\
    \ did, but it can only be supplied with rvalues:</p>\n<pre><code>unique_ptr&lt;Shape&gt;\
    \ a(new Triangle);\nunique_ptr&lt;Shape&gt; b(a);                 // error\nunique_ptr&lt;Shape&gt;\
    \ c(make_triangle());   // okay\n</code></pre>\n<p>The second line fails to compile,\
    \ because <code>a</code> is an lvalue, but the parameter <code>unique_ptr&amp;&amp;\
    \ source</code> can only be bound to rvalues. This is exactly what we wanted;\
    \ dangerous moves should never be implicit. The third line compiles just fine,\
    \ because <code>make_triangle()</code> is an rvalue. The move constructor will\
    \ transfer ownership from the temporary to <code>c</code>. Again, this is exactly\
    \ what we wanted.</p>\n<blockquote>\n<p>The move constructor transfers ownership\
    \ of a managed resource into the current object.</p>\n</blockquote>\n<h2>Move\
    \ assignment operators</h2>\n<p>The last missing piece is the move assignment\
    \ operator. Its job is to release the old resource and acquire the new resource\
    \ from its argument:</p>\n<pre><code>    unique_ptr&amp; operator=(unique_ptr&amp;&amp;\
    \ source)   // note the rvalue reference\n    {\n        if (this != &amp;source)\
    \    // beware of self-assignment\n        {\n            delete ptr;        \
    \ // release the old resource\n\n            ptr = source.ptr;   // acquire the\
    \ new resource\n            source.ptr = nullptr;\n        }\n        return *this;\n\
    \    }\n};\n</code></pre>\n<p>Note how this implementation of the move assignment\
    \ operator duplicates logic of both the destructor and the move constructor. Are\
    \ you familiar with the copy-and-swap idiom? It can also be applied to move semantics\
    \ as the move-and-swap idiom:</p>\n<pre><code>    unique_ptr&amp; operator=(unique_ptr\
    \ source)   // note the missing reference\n    {\n        std::swap(ptr, source.ptr);\n\
    \        return *this;\n    }\n};\n</code></pre>\n<p>Now that <code>source</code>\
    \ is a variable of type <code>unique_ptr</code>, it will be initialized by the\
    \ move constructor; that is, the argument will be moved into the parameter. The\
    \ argument is still required to be an rvalue, because the move constructor itself\
    \ has an rvalue reference parameter. When control flow reaches the closing brace\
    \ of <code>operator=</code>, <code>source</code> goes out of scope, releasing\
    \ the old resource automatically.</p>\n<blockquote>\n<p>The move assignment operator\
    \ transfers ownership of a managed resource into the current object, releasing\
    \ the old resource.\n  The move-and-swap idiom simplifies the implementation.</p>\n\
    </blockquote>\n<h2>Moving from lvalues</h2>\n<p>Sometimes, we want to move from\
    \ lvalues. That is, sometimes we want the compiler to treat an lvalue as if it\
    \ were an rvalue, so it can invoke the move constructor, even though it could\
    \ be potentially unsafe.\nFor this purpose, C++11 offers a standard library function\
    \ template called <code>std::move</code> inside the header <code>&lt;utility&gt;</code>.\n\
    This name is a bit unfortunate, because <code>std::move</code> simply casts an\
    \ lvalue to an rvalue; it does <em>not</em> move anything by itself. It merely\
    \ <em>enables</em> moving. Maybe it should have been named <code>std::cast_to_rvalue</code>\
    \ or <code>std::enable_move</code>, but we are stuck with the name by now.</p>\n\
    <p>Here is how you explicitly move from an lvalue:</p>\n<pre><code>unique_ptr&lt;Shape&gt;\
    \ a(new Triangle);\nunique_ptr&lt;Shape&gt; b(a);              // still an error\n\
    unique_ptr&lt;Shape&gt; c(std::move(a));   // okay\n</code></pre>\n<p>Note that\
    \ after the third line, <code>a</code> no longer owns a triangle. That's okay,\
    \ because by <em>explicitly</em> writing <code>std::move(a)</code>, we made our\
    \ intentions clear: \"Dear constructor, do whatever you want with <code>a</code>\
    \ in order to initialize <code>c</code>; I don't care about <code>a</code> anymore.\
    \ Feel free to have your way with <code>a</code>.\"</p>\n<blockquote>\n<p><code>std::move(some_lvalue)</code>\
    \ casts an lvalue to an rvalue, thus enabling a subsequent move.</p>\n</blockquote>\n\
    <h2>Xvalues</h2>\n<p>Note that even though <code>std::move(a)</code> is an rvalue,\
    \ its evaluation does <em>not</em> create a temporary object. This conundrum forced\
    \ the committee to introduce a third value category. Something that can be bound\
    \ to an rvalue reference, even though it is not an rvalue in the traditional sense,\
    \ is called an <em>xvalue</em> (eXpiring value). The traditional rvalues were\
    \ renamed to <em>prvalues</em> (Pure rvalues).</p>\n<p>Both prvalues and xvalues\
    \ are rvalues. Xvalues and lvalues are both <em>glvalues</em> (Generalized lvalues).\
    \ The relationships are easier to grasp with a diagram:</p>\n<pre><code>     \
    \   expressions\n          /     \\\n         /       \\\n        /         \\\
    \n    glvalues   rvalues\n      /  \\       /  \\\n     /    \\     /    \\\n\
    \    /      \\   /      \\\nlvalues   xvalues   prvalues\n</code></pre>\n<p>Note\
    \ that only xvalues are really new; the rest is just due to renaming and grouping.</p>\n\
    <blockquote>\n<p>C++98 rvalues are known as prvalues in C++11. Mentally replace\
    \ all occurrences of \"rvalue\" in the preceding paragraphs with \"prvalue\".</p>\n\
    </blockquote>\n<h2>Moving out of functions</h2>\n<p>So far, we have seen movement\
    \ into local variables, and into function parameters. But moving is also possible\
    \ in the opposite direction. If a function returns by value, some object at call\
    \ site (probably a local variable or a temporary, but could be any kind of object)\
    \ is initialized with the expression after the <code>return</code> statement as\
    \ an argument to the move constructor:</p>\n<pre><code>unique_ptr&lt;Shape&gt;\
    \ make_triangle()\n{\n    return unique_ptr&lt;Shape&gt;(new Triangle);\n}   \
    \       \\-----------------------------/\n                  |\n              \
    \    | temporary is moved into c\n                  |\n                  v\nunique_ptr&lt;Shape&gt;\
    \ c(make_triangle());\n</code></pre>\n<p>Perhaps surprisingly, automatic objects\
    \ (local variables that are not declared as <code>static</code>) can also be <em>implicitly</em>\
    \ moved out of functions:</p>\n<pre><code>unique_ptr&lt;Shape&gt; make_square()\n\
    {\n    unique_ptr&lt;Shape&gt; result(new Square);\n    return result;   // note\
    \ the missing std::move\n}\n</code></pre>\n<p>How come the move constructor accepts\
    \ the lvalue <code>result</code> as an argument? The scope of <code>result</code>\
    \ is about to end, and it will be destroyed during stack unwinding. Nobody could\
    \ possibly complain afterwards that <code>result</code> had changed somehow; when\
    \ control flow is back at the caller, <code>result</code> does not exist anymore!\
    \ For that reason, C++11 has a special rule that allows returning automatic objects\
    \ from functions without having to write <code>std::move</code>. In fact, you\
    \ should <em>never</em> use <code>std::move</code> to move automatic objects out\
    \ of functions, as this inhibits the \"named return value optimization\" (NRVO).</p>\n\
    <blockquote>\n<p>Never use <code>std::move</code> to move automatic objects out\
    \ of functions.</p>\n</blockquote>\n<p>Note that in both factory functions, the\
    \ return type is a value, not an rvalue reference. Rvalue references are still\
    \ references, and as always, you should never return a reference to an automatic\
    \ object; the caller would end up with a dangling reference if you tricked the\
    \ compiler into accepting your code, like this:</p>\n<pre><code>unique_ptr&lt;Shape&gt;&amp;&amp;\
    \ flawed_attempt()   // DO NOT DO THIS!\n{\n    unique_ptr&lt;Shape&gt; very_bad_idea(new\
    \ Square);\n    return std::move(very_bad_idea);   // WRONG!\n}\n</code></pre>\n\
    <blockquote>\n<p>Never return automatic objects by rvalue reference. Moving is\
    \ exclusively performed by the move constructor, not by <code>std::move</code>,\
    \ and not by merely binding an rvalue to an rvalue reference.</p>\n</blockquote>\n\
    <h2>Moving into members</h2>\n<p>Sooner or later, you are going to write code\
    \ like this:</p>\n<pre><code>class Foo\n{\n    unique_ptr&lt;Shape&gt; member;\n\
    \npublic:\n\n    Foo(unique_ptr&lt;Shape&gt;&amp;&amp; parameter)\n    : member(parameter)\
    \   // error\n    {}\n};\n</code></pre>\n<p>Basically, the compiler will complain\
    \ that <code>parameter</code> is an lvalue. If you look at its type, you see an\
    \ rvalue reference, but an rvalue reference simply means \"a reference that is\
    \ bound to an rvalue\"; it does <em>not</em> mean that the reference itself is\
    \ an rvalue! Indeed, <code>parameter</code> is just an ordinary variable with\
    \ a name. You can use <code>parameter</code> as often as you like inside the body\
    \ of the constructor, and it always denotes the same object. Implicitly moving\
    \ from it would be dangerous, hence the language forbids it.</p>\n<blockquote>\n\
    <p>A named rvalue reference is an lvalue, just like any other variable.</p>\n\
    </blockquote>\n<p>The solution is to manually enable the move:</p>\n<pre><code>class\
    \ Foo\n{\n    unique_ptr&lt;Shape&gt; member;\n\npublic:\n\n    Foo(unique_ptr&lt;Shape&gt;&amp;&amp;\
    \ parameter)\n    : member(std::move(parameter))   // note the std::move\n   \
    \ {}\n};\n</code></pre>\n<p>You could argue that <code>parameter</code> is not\
    \ used anymore after the initialization of <code>member</code>. Why is there no\
    \ special rule to silently insert <code>std::move</code> just as with return values?\
    \ Probably because it would be too much burden on the compiler implementors. For\
    \ example, what if the constructor body was in another translation unit? By contrast,\
    \ the return value rule simply has to check the symbol tables to determine whether\
    \ or not the identifier after the <code>return</code> keyword denotes an automatic\
    \ object.</p>\n<p>You can also pass <code>parameter</code> by value. For move-only\
    \ types like <code>unique_ptr</code>, it seems there is no established idiom yet.\
    \ Personally, I prefer pass by value, as it causes less clutter in the interface.</p>\n\
    <h2>Special member functions</h2>\n<p>C++98 implicitly declares three special\
    \ member functions on demand, that is, when they are needed somewhere: the copy\
    \ constructor, the copy assignment operator and the destructor.</p>\n<pre><code>X::X(const\
    \ X&amp;);              // copy constructor\nX&amp; X::operator=(const X&amp;);\
    \   // copy assignment operator\nX::~X();                     // destructor\n\
    </code></pre>\n<p>Rvalue references went through several versions. Since version\
    \ 3.0, C++11 declares two additional special member functions on demand: the move\
    \ constructor and the move assignment operator. Note that neither VC10 nor VC11\
    \ conform to version 3.0 yet, so you will have to implement them yourself.</p>\n\
    <pre><code>X::X(X&amp;&amp;);                   // move constructor\nX&amp; X::operator=(X&amp;&amp;);\
    \        // move assignment operator\n</code></pre>\n<p>These two new special\
    \ member functions are only implicitly declared if none of the special member\
    \ functions are declared manually. Also, if you declare your own move constructor\
    \ or move assignment operator, neither the copy constructor nor the copy assignment\
    \ operator will be declared implicitly.</p>\n<p>What do these rules mean in practice?</p>\n\
    <blockquote>\n<p>If you write a class without unmanaged resources, there is no\
    \ need to declare any of the five special member functions yourself, and you will\
    \ get correct copy semantics and move semantics for free. Otherwise, you will\
    \ have to implement the special member functions yourself. Of course, if your\
    \ class does not benefit from move semantics, there is no need to implement the\
    \ special move operations.</p>\n</blockquote>\n<p>Note that the copy assignment\
    \ operator and the move assignment operator can be fused into a single, unified\
    \ assignment operator, taking its argument by value:</p>\n<pre><code>X&amp; X::operator=(X\
    \ source)    // unified assignment operator\n{\n    swap(source);            //\
    \ see my first answer for an explanation\n    return *this;\n}\n</code></pre>\n\
    <p>This way, the number of special member functions to implement drops from five\
    \ to four. There is a tradeoff between exception-safety and efficiency here, but\
    \ I am not an expert on this issue.</p>\n<h2>Forwarding references (<a href=\"\
    http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4164.pdf\" rel=\"noreferrer\"\
    >previously</a> known as <em>Universal references</em>)</h2>\n<p>Consider the\
    \ following function template:</p>\n<pre><code>template&lt;typename T&gt;\nvoid\
    \ foo(T&amp;&amp;);\n</code></pre>\n<p>You might expect <code>T&amp;&amp;</code>\
    \ to only bind to rvalues, because at first glance, it looks like an rvalue reference.\
    \ As it turns out though, <code>T&amp;&amp;</code> also binds to lvalues:</p>\n\
    <pre><code>foo(make_triangle());   // T is unique_ptr&lt;Shape&gt;, T&amp;&amp;\
    \ is unique_ptr&lt;Shape&gt;&amp;&amp;\nunique_ptr&lt;Shape&gt; a(new Triangle);\n\
    foo(a);                 // T is unique_ptr&lt;Shape&gt;&amp;, T&amp;&amp; is unique_ptr&lt;Shape&gt;&amp;\n\
    </code></pre>\n<p>If the argument is an rvalue of type <code>X</code>, <code>T</code>\
    \ is deduced to be <code>X</code>, hence <code>T&amp;&amp;</code> means <code>X&amp;&amp;</code>.\
    \ This is what anyone would expect.\nBut if the argument is an lvalue of type\
    \ <code>X</code>, due to a special rule, <code>T</code> is deduced to be <code>X&amp;</code>,\
    \ hence <code>T&amp;&amp;</code> would mean something like <code>X&amp; &amp;&amp;</code>.\
    \ But since C++ still has no notion of references to references, the type <code>X&amp;\
    \ &amp;&amp;</code> is <em>collapsed</em> into <code>X&amp;</code>. This may sound\
    \ confusing and useless at first, but reference collapsing is essential for <em>perfect\
    \ forwarding</em> (which will not be discussed here).</p>\n<blockquote>\n<p>T&amp;&amp;\
    \ is not an rvalue reference, but a forwarding reference. It also binds to lvalues,\
    \ in which case <code>T</code> and <code>T&amp;&amp;</code> are both lvalue references.</p>\n\
    </blockquote>\n<p>If you want to constrain a function template to rvalues, you\
    \ can combine <a href=\"http://en.cppreference.com/w/cpp/language/sfinae\" rel=\"\
    noreferrer\">SFINAE</a> with type traits:</p>\n<pre><code>#include &lt;type_traits&gt;\n\
    \ntemplate&lt;typename T&gt;\ntypename std::enable_if&lt;std::is_rvalue_reference&lt;T&amp;&amp;&gt;::value,\
    \ void&gt;::type\nfoo(T&amp;&amp;);\n</code></pre>\n<h2>Implementation of move</h2>\n\
    <p>Now that you understand reference collapsing, here is how <code>std::move</code>\
    \ is implemented:</p>\n<pre><code>template&lt;typename T&gt;\ntypename std::remove_reference&lt;T&gt;::type&amp;&amp;\n\
    move(T&amp;&amp; t)\n{\n    return static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);\n\
    }\n</code></pre>\n<p>As you can see, <code>move</code> accepts any kind of parameter\
    \ thanks to the forwarding reference <code>T&amp;&amp;</code>, and it returns\
    \ an rvalue reference. The <code>std::remove_reference&lt;T&gt;::type</code> meta-function\
    \ call is necessary because otherwise, for lvalues of type <code>X</code>, the\
    \ return type would be <code>X&amp; &amp;&amp;</code>, which would collapse into\
    \ <code>X&amp;</code>. Since <code>t</code> is always an lvalue (remember that\
    \ a named rvalue reference is an lvalue), but we want to bind <code>t</code> to\
    \ an rvalue reference, we have to explicitly cast <code>t</code> to the correct\
    \ return type.\nThe call of a function that returns an rvalue reference is itself\
    \ an xvalue. Now you know where xvalues come from ;)</p>\n<blockquote>\n<p>The\
    \ call of a function that returns an rvalue reference, such as <code>std::move</code>,\
    \ is an xvalue.</p>\n</blockquote>\n<p>Note that returning by rvalue reference\
    \ is fine in this example, because <code>t</code> does not denote an automatic\
    \ object, but instead an object that was passed in by the caller.</p>\n</div>"
- - What are move semantics?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Move semantics are based on <strong><em>rvalue\
    \ references</em></strong>.<br/>\nAn rvalue is a temporary object, which is going\
    \ to be destroyed at the end of the expression. In current C++, rvalues only bind\
    \ to <code>const</code> references. C++1x will allow non-<code>const</code> rvalue\
    \ references, spelled <code>T&amp;&amp;</code>, which are references to an rvalue\
    \ objects.<br/>\nSince an rvalue is going to die at the end of an expression,\
    \ you can <em>steal its data</em>. Instead of <em>copying</em> it into another\
    \ object, you <em>move</em> its data into it. </p>\n<pre><code>class X {\npublic:\
    \ \n  X(X&amp;&amp; rhs) // ctor taking an rvalue reference, so-called move-ctor\n\
    \    : data_()\n  {\n     // since 'x' is an rvalue object, we can steal its data\n\
    \     this-&gt;swap(std::move(rhs));\n     // this will leave rhs with the empty\
    \ data\n  }\n  void swap(X&amp;&amp; rhs);\n  // ... \n};\n\n// ...\n\nX f();\n\
    \nX x = f(); // f() returns result as rvalue, so this calls move-ctor\n</code></pre>\n\
    <p>In the above code, with old compilers the result of <code>f()</code> is <strong><em>copied</em></strong>\
    \ into <code>x</code> using <code>X</code>'s copy constructor. If your compiler\
    \ supports move semantics and <code>X</code> has a move-constructor, then that\
    \ is called instead. Since its <code>rhs</code> argument is an <em>rvalue</em>,\
    \ we know it's not needed any longer and we can steal its value.<br/>\nSo the\
    \ value is <strong><em>moved</em></strong> from the unnamed temporary returned\
    \ from <code>f()</code> to <code>x</code> (while the data of <code>x</code>, initialized\
    \ to an empty <code>X</code>, is moved into the temporary, which will get destroyed\
    \ after the assignment). </p>\n</div>"
- - "Image Processing: Algorithm Improvement for 'Coca-Cola Can' Recognition"
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>An alternative approach would\
    \ be to extract features (keypoints) using the <a href=\"https://en.wikipedia.org/wiki/Scale-invariant_feature_transform\"\
    \ rel=\"noreferrer\">scale-invariant feature transform</a> (SIFT) or <a href=\"\
    https://en.wikipedia.org/wiki/Speeded_up_robust_features\" rel=\"noreferrer\"\
    >Speeded Up Robust Features</a> (SURF).</p>\n<p>It is implemented in <a href=\"\
    https://en.wikipedia.org/wiki/OpenCV\" rel=\"noreferrer\">OpenCV</a> 2.3.1.</p>\n\
    <p>You can find a nice code example using features in <em><a href=\"http://docs.opencv.org/2.4/doc/tutorials/features2d/feature_homography/feature_homography.html\"\
    \ rel=\"noreferrer\">Features2D + Homography to find a known object</a></em></p>\n\
    <p>Both algorithms are invariant to scaling and rotation. Since they work with\
    \ features, you can also handle <a href=\"http://en.wikipedia.org/wiki/Ambient_occlusion\"\
    \ rel=\"noreferrer\">occlusion</a> (as long as enough keypoints are visible).</p>\n\
    <p><img alt=\"Enter image description here\" src=\"https://i.stack.imgur.com/kF63R.jpg\"\
    /></p>\n<p>Image source: tutorial example</p>\n<p>The processing takes a few hundred\
    \ ms for SIFT, SURF is bit faster, but it not suitable for real-time applications.\
    \ ORB uses FAST which is weaker regarding rotation invariance.</p>\n<h3>The original\
    \ papers</h3>\n<ul>\n<li><a href=\"http://www.vision.ee.ethz.ch/~surf/eccv06.pdf\"\
    \ rel=\"noreferrer\">SURF: Speeded Up Robust Features</a></li>\n<li><a href=\"\
    http://www.cs.ubc.ca/~lowe/papers/ijcv04.pdf\" rel=\"noreferrer\">Distinctive\
    \ Image Features\nfrom Scale-Invariant Keypoints</a></li>\n<li><a href=\"http://www.willowgarage.com/sites/default/files/orb_final.pdf\"\
    \ rel=\"noreferrer\">ORB: an efficient alternative to SIFT or SURF</a></li>\n\
    </ul>\n</div>"
- - "Image Processing: Algorithm Improvement for 'Coca-Cola Can' Recognition"
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>To speed things up, I would take\
    \ advantage of the fact that you are not asked to find an arbitrary image/object,\
    \ but specifically one with the Coca-Cola logo. This is significant because this\
    \ logo is very distinctive, and it should have a characteristic, scale-invariant\
    \ signature in the frequency domain, particularly in the red channel of RGB. That\
    \ is to say, the alternating pattern of red-to-white-to-red encountered by a horizontal\
    \ scan line (trained on a horizontally aligned logo) will have a distinctive \"\
    rhythm\" as it passes through the central axis of the logo. That rhythm will \"\
    speed up\" or \"slow down\" at different scales and orientations, but will remain\
    \ proportionally equivalent. You could identify/define a few dozen such scanlines,\
    \ both horizontally and vertically through the logo and several more diagonally,\
    \ in a starburst pattern. Call these the \"signature scan lines.\"</p>\n<p><img\
    \ alt=\"Signature scan line\" src=\"https://i.stack.imgur.com/KWVZw.jpg\"/></p>\n\
    <p>Searching for this signature in the target image is a simple matter of scanning\
    \ the image in horizontal strips. Look for a high-frequency in the red-channel\
    \ (indicating moving from a red region to a white one), and once found, see if\
    \ it is followed by one of the frequency rhythms identified in the training session.\
    \ Once a match is found, you will instantly know the scan-line's orientation and\
    \ location in the logo (if you keep track of those things during training), so\
    \ identifying the boundaries of the logo from there is trivial. </p>\n<p>I would\
    \ be surprised if this weren't a linearly-efficient algorithm, or nearly so. It\
    \ obviously doesn't address your can-bottle discrimination, but at least you'll\
    \ have your logos. </p>\n<p>(Update: for bottle recognition I would look for coke\
    \ (the brown liquid) adjacent to the logo --  that is, <em>inside</em> the bottle.\
    \ Or, in the case of an empty bottle, I would look for a <em>cap</em> which will\
    \ always have the same basic shape, size, and distance from the logo and will\
    \ typically be all white or red. Search for a solid color eliptical shape where\
    \ a cap <em>should</em> be, relative to the logo. Not foolproof of course, but\
    \ your goal here should be to find the <em>easy</em> ones <em>fast</em>.)</p>\n\
    <p>(It's been a few years since my image processing days, so I kept this suggestion\
    \ high-level and conceptual. I think it might slightly approximate how a human\
    \ eye might operate -- or at least how my brain does!)</p>\n</div>"
- - "Image Processing: Algorithm Improvement for 'Coca-Cola Can' Recognition"
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Fun problem: when I glanced at\
    \ your bottle image I thought it was a can too. But, as a human, what I did to\
    \ tell the difference is that I then noticed it was also a bottle...</p>\n<p>So,\
    \ to tell cans and bottles apart, how about simply scanning for bottles first?\
    \ If you find one, mask out the label before looking for cans.</p>\n<p>Not too\
    \ hard to implement if you're already doing cans. The real downside is it doubles\
    \ your processing time. (But thinking ahead to real-world applications, you're\
    \ going to end up wanting to do bottles anyway ;-)</p>\n</div>"
- - Is < faster than <=?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>No, it will not be faster on\
    \ most architectures. You didn't specify, but on x86, all of the integral comparisons\
    \ will be typically implemented in two machine instructions:</p>\n<ul>\n<li>A\
    \ <code>test</code> or <code>cmp</code> instruction, which sets <code>EFLAGS</code></li>\n\
    <li>And a <a href=\"http://www.unixwiz.net/techtips/x86-jumps.html\"><code>Jcc</code>\
    \ (jump) instruction</a>, depending on the comparison type (and code layout):\n\
    <ul>\n<li><code>jne</code> - Jump if not equal --&gt; <code>ZF = 0</code></li>\n\
    <li><code>jz</code> - Jump if zero (equal) --&gt; <code>ZF = 1</code></li>\n<li><code>jg</code>\
    \ - Jump if greater --&gt; <code>ZF = 0 and SF = OF</code></li>\n<li>(etc...)</li>\n\
    </ul></li>\n</ul>\n<hr/>\n<p><strong>Example</strong> (Edited for brevity) Compiled\
    \ with <code>$ gcc -m32 -S -masm=intel test.c</code></p>\n<pre class=\"lang-c\
    \ prettyprint-override\"><code>    if (a &lt; b) {\n        // Do something 1\n\
    \    }\n</code></pre>\n<p>Compiles to:</p>\n<pre class=\"lang-none prettyprint-override\"\
    ><code>    mov     eax, DWORD PTR [esp+24]      ; a\n    cmp     eax, DWORD PTR\
    \ [esp+28]      ; b\n    jge     .L2                          ; jump if a is &gt;=\
    \ b\n    ; Do something 1\n.L2:\n</code></pre>\n<p>And</p>\n<pre class=\"lang-c\
    \ prettyprint-override\"><code>    if (a &lt;= b) {\n        // Do something 2\n\
    \    }\n</code></pre>\n<p>Compiles to:</p>\n<pre class=\"lang-none prettyprint-override\"\
    ><code>    mov     eax, DWORD PTR [esp+24]      ; a\n    cmp     eax, DWORD PTR\
    \ [esp+28]      ; b\n    jg      .L5                          ; jump if a is &gt;\
    \ b\n    ; Do something 2\n.L5:\n</code></pre>\n<p>So the only difference between\
    \ the two is a <code>jg</code> versus a <code>jge</code> instruction. The two\
    \ will take the same amount of time.</p>\n<hr/>\n<p>I'd like to address the comment\
    \ that nothing indicates that the different jump instructions take the same amount\
    \ of time.  This one is a little tricky to answer, but here's what I can give:\
    \ In the <a href=\"http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html\"\
    >Intel Instruction Set Reference</a>, they are all grouped together under one\
    \ common instruction, <code>Jcc</code> (Jump if condition is met). The same grouping\
    \ is made together under the <a href=\"http://www.intel.com/content/www/us/en/architecture-and-technology/64-ia-32-architectures-optimization-manual.html\"\
    >Optimization Reference Manual</a>, in Appendix C. Latency and Throughput.</p>\n\
    <blockquote>\n<p><strong>Latency</strong> — The number of clock cycles that are\
    \ required for the\n  execution core to  complete the execution of all of the\
    \ μops that form\n  an instruction.</p>\n<p><strong>Throughput</strong> — The\
    \ number of clock cycles required to\n  wait before the issue  ports are free\
    \ to accept the same instruction\n  again. For many instructions, the  throughput\
    \ of an instruction can be\n  significantly less than its latency</p>\n</blockquote>\n\
    <p>The values for <code>Jcc</code> are:</p>\n<pre class=\"lang-none prettyprint-override\"\
    ><code>      Latency   Throughput\nJcc     N/A        0.5\n</code></pre>\n<p>with\
    \ the following footnote on <code>Jcc</code>:</p>\n<blockquote>\n<p>7) Selection\
    \ of conditional jump instructions should be based on the recommendation of section\
    \ Section 3.4.1, “Branch Prediction Optimization,” to improve the  predictability\
    \ of branches. When branches are predicted successfully, the latency of <code>jcc</code>\
    \ is effectively zero.</p>\n</blockquote>\n<p>So, nothing in the Intel docs ever\
    \ treats one <code>Jcc</code> instruction any differently from the others.</p>\n\
    <p>If one thinks about the actual circuitry used to implement the instructions,\
    \ one can assume that there would be simple AND/OR gates on the different bits\
    \ in <code>EFLAGS</code>, to determine whether the conditions are met. There is\
    \ then, no reason that an instruction testing two bits should take any more or\
    \ less time than one testing only one (Ignoring gate propagation delay, which\
    \ is much less than the clock period.)</p>\n<hr/>\n<p><strong>Edit: Floating Point</strong></p>\n\
    <p>This holds true for x87 floating point as well:  (Pretty much same code as\
    \ above, but with <code>double</code> instead of <code>int</code>.)</p>\n<pre\
    \ class=\"lang-none prettyprint-override\"><code>        fld     QWORD PTR [esp+32]\n\
    \        fld     QWORD PTR [esp+40]\n        fucomip st, st(1)              ;\
    \ Compare ST(0) and ST(1), and set CF, PF, ZF in EFLAGS\n        fstp    st(0)\n\
    \        seta    al                     ; Set al if above (CF=0 and ZF=0).\n \
    \       test    al, al\n        je      .L2\n        ; Do something 1\n.L2:\n\n\
    \        fld     QWORD PTR [esp+32]\n        fld     QWORD PTR [esp+40]\n    \
    \    fucomip st, st(1)              ; (same thing as above)\n        fstp    st(0)\n\
    \        setae   al                     ; Set al if above or equal (CF=0).\n \
    \       test    al, al\n        je      .L5\n        ; Do something 2\n.L5:\n\
    \        leave\n        ret\n</code></pre>\n</div>"
- - Is < faster than <=?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Historically (we're talking the\
    \ 1980s and early 1990s), there were <em>some</em> architectures in which this\
    \ was true. The root issue is that integer comparison is inherently implemented\
    \ via integer subtractions. This gives rise to the following cases.</p>\n<pre><code>Comparison\
    \     Subtraction\n----------     -----------\nA &lt; B      --&gt; A - B &lt;\
    \ 0\nA = B      --&gt; A - B = 0\nA &gt; B      --&gt; A - B &gt; 0\n</code></pre>\n\
    <p>Now, when <code>A &lt; B</code> the subtraction has to borrow a high-bit for\
    \ the subtraction to be correct, just like you carry and borrow when adding and\
    \ subtracting by hand. This \"borrowed\" bit was usually referred to as the <em>carry\
    \ bit</em> and would be testable by a branch instruction. A second bit called\
    \ the <em>zero bit</em> would be set if the subtraction were identically zero\
    \ which implied equality.</p>\n<p>There were usually at least two conditional\
    \ branch instructions, one to branch on the carry bit and one on the zero bit.</p>\n\
    <p>Now, to get at the heart of the matter, let's expand the previous table to\
    \ include the carry and zero bit results.</p>\n<pre><code>Comparison     Subtraction\
    \  Carry Bit  Zero Bit\n----------     -----------  ---------  --------\nA &lt;\
    \ B      --&gt; A - B &lt; 0    0          0\nA = B      --&gt; A - B = 0    1\
    \          1\nA &gt; B      --&gt; A - B &gt; 0    1          0\n</code></pre>\n\
    <p>So, implementing a branch for <code>A &lt; B</code> can be done in one instruction,\
    \ because the carry bit is clear <em>only</em> in this case, , that is,</p>\n\
    <pre><code>;; Implementation of \"if (A &lt; B) goto address;\"\ncmp  A, B   \
    \       ;; compare A to B\nbcz  address       ;; Branch if Carry is Zero to the\
    \ new address\n</code></pre>\n<p>But, if we want to do a less-than-or-equal comparison,\
    \ we need to do an additional check of the zero flag to catch the case of equality.</p>\n\
    <pre><code>;; Implementation of \"if (A &lt;= B) goto address;\"\ncmp A, B   \
    \        ;; compare A to B\nbcz address        ;; branch if A &lt; B\nbzs address\
    \        ;; also, Branch if the Zero bit is Set\n</code></pre>\n<p>So, on some\
    \ machines, using a \"less than\" comparison <em>might</em> save <em>one machine\
    \ instruction</em>.  This was relevant in the era of sub-megahertz processor speed\
    \ and 1:1 CPU-to-memory speed ratios, but it is almost totally irrelevant today.</p>\n\
    </div>"
- - Is < faster than <=?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Assuming we're talking about\
    \ internal integer types, there's no possible way one could be faster than the\
    \ other. They're obviously semantically identical. They both ask the compiler\
    \ to do precisely the same thing. Only a horribly broken compiler would generate\
    \ inferior code for one of these.</p>\n<p>If there was some platform where <code>&lt;</code>\
    \ was faster than <code>&lt;=</code> for simple integer types, the compiler should\
    \ <em>always</em> convert <code>&lt;=</code> to <code>&lt;</code> for constants.\
    \ Any compiler that didn't would just be a bad compiler (for that platform).</p>\n\
    </div>"
- - Why should I use a pointer rather than the object itself?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>It's very unfortunate that you\
    \ see dynamic allocation so often. That just shows how many bad C++ programmers\
    \ there are.</p>\n<p>In a sense, you have two questions bundled up into one. The\
    \ first is when should we use dynamic allocation (using <code>new</code>)? The\
    \ second is when should we use pointers?</p>\n<p>The important take-home message\
    \ is that you should <strong>always use the appropriate tool for the job</strong>.\
    \ In almost all situations, there is something more appropriate and safer than\
    \ performing manual dynamic allocation and/or using raw pointers.</p>\n<h2>Dynamic\
    \ allocation</h2>\n<p>In your question, you've demonstrated two ways of creating\
    \ an object. The main difference is the storage duration of the object. When doing\
    \ <code>Object myObject;</code> within a block, the object is created with automatic\
    \ storage duration, which means it will be destroyed automatically when it goes\
    \ out of scope. When you do <code>new Object()</code>, the object has dynamic\
    \ storage duration, which means it stays alive until you explicitly <code>delete</code>\
    \ it. You should only use dynamic storage duration when you need it. \nThat is,\
    \ <strong>you should <em>always</em> prefer creating objects with automatic storage\
    \ duration when you can</strong>.</p>\n<p>The main two situations in which you\
    \ might require dynamic allocation:</p>\n<ol>\n<li><strong>You need the object\
    \ to outlive the current scope</strong> - that specific object at that specific\
    \ memory location, not a copy of it. If you're okay with copying/moving the object\
    \ (most of the time you should be), you should prefer an automatic object.</li>\n\
    <li><strong>You need to allocate a lot of memory</strong>, which may easily fill\
    \ up the stack. It would be nice if we didn't have to concern ourselves with this\
    \ (most of the time you shouldn't have to), as it's really outside the purview\
    \ of C++, but unfortunately we have to deal with the reality of the systems we're\
    \ developing for.</li>\n</ol>\n<p>When you do absolutely require dynamic allocation,\
    \ you should encapsulate it in a smart pointer or some other type that performs\
    \ <a href=\"http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\"\
    \ rel=\"noreferrer\">RAII</a> (like the standard containers). Smart pointers provide\
    \ ownership semantics of dynamically allocated objects. Take a look at <a href=\"\
    http://en.cppreference.com/w/cpp/memory/unique_ptr\" rel=\"noreferrer\"><code>std::unique_ptr</code></a>\
    \ and <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"noreferrer\"\
    ><code>std::shared_ptr</code></a>, for example. If you use them appropriately,\
    \ you can almost entirely avoid performing your own memory management (see the\
    \ <a href=\"https://rmf.io/cxx11/rule-of-zero\" rel=\"noreferrer\">Rule of Zero</a>).</p>\n\
    <h2>Pointers</h2>\n<p>However, there are other more general uses for raw pointers\
    \ beyond dynamic allocation, but most have alternatives that you should prefer.\
    \ As before, <strong>always prefer the alternatives unless you really need pointers</strong>.</p>\n\
    <ol>\n<li><p><strong>You need reference semantics</strong>. Sometimes you want\
    \ to pass an object using a pointer (regardless of how it was allocated) because\
    \ you want the function to which you're passing it to have access that that specific\
    \ object (not a copy of it). However, in most situations, you should prefer reference\
    \ types to pointers, because this is specifically what they're designed for. Note\
    \ this is not necessarily about extending the lifetime of the object beyond the\
    \ current scope, as in situation 1 above. As before, if you're okay with passing\
    \ a copy of the object, you don't need reference semantics.</p></li>\n<li><p><strong>You\
    \ need polymorphism</strong>. You can only call functions polymorphically (that\
    \ is, according to the dynamic type of an object) through a pointer or reference\
    \ to the object. If that's the behaviour you need, then you need to use pointers\
    \ or references. Again, references should be preferred.</p></li>\n<li><p><strong>You\
    \ want to represent that an object is optional</strong> by allowing a <code>nullptr</code>\
    \ to be passed when the object is being omitted. If it's an argument, you should\
    \ prefer to use default arguments or function overloads. Otherwise, you should\
    \ prefer use a type that encapsulates this behaviour, such as <code>std::optional</code>\
    \ (introduced in C++17 - with earlier C++ standards, use <code>boost::optional</code>).</p></li>\n\
    <li><p><strong>You want to decouple compilation units to improve compilation time</strong>.\
    \ The useful property of a pointer is that you only require a forward declaration\
    \ of the pointed-to type (to actually use the object, you'll need a definition).\
    \ This allows you to decouple parts of your compilation process, which may significantly\
    \ improve compilation time. See the <a href=\"http://en.wikipedia.org/wiki/Opaque_pointer\"\
    \ rel=\"noreferrer\">Pimpl idiom</a>.</p></li>\n<li><p><strong>You need to interface\
    \ with a C library</strong> or a C-style library. At this point, you're forced\
    \ to use raw pointers. The best thing you can do is make sure you only let your\
    \ raw pointers loose at the last possible moment. You can get a raw pointer from\
    \ a smart pointer, for example, by using its <code>get</code> member function.\
    \ If a library performs some allocation for you which it expects you to deallocate\
    \ via a handle, you can often wrap the handle up in a smart pointer with a custom\
    \ deleter that will deallocate the object appropriately.</p></li>\n</ol>\n</div>"
- - Why should I use a pointer rather than the object itself?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>There are many use cases for\
    \ pointers. </p>\n<p><strong>Polymorphic behavior</strong>. For polymorphic types,\
    \ pointers (or references) are used to avoid slicing:</p>\n<pre><code>class Base\
    \ { ... };\nclass Derived : public Base { ... };\n\nvoid fun(Base b) { ... }\n\
    void gun(Base* b) { ... }\nvoid hun(Base&amp; b) { ... }\n\nDerived d;\nfun(d);\
    \    // oops, all Derived parts silently \"sliced\" off\ngun(&amp;d);   // OK,\
    \ a Derived object IS-A Base object\nhun(d);    // also OK, reference also doesn't\
    \ slice\n</code></pre>\n<p><strong>Reference semantics and avoiding copying</strong>.\
    \ For non-polymorphic types, a pointer (or a reference) will avoid copying a potentially\
    \ expensive object</p>\n<pre><code>Base b;\nfun(b);  // copies b, potentially\
    \ expensive \ngun(&amp;b); // takes a pointer to b, no copying\nhun(b);  // regular\
    \ syntax, behaves as a pointer\n</code></pre>\n<p>Note that C++11 has move semantics\
    \ that can avoid many copies of expensive objects into function argument and as\
    \ return values. But using a pointer will definitely avoid those and will allow\
    \ multiple pointers on the same object (whereas an object can only be moved from\
    \ once).</p>\n<p><strong>Resource acquisition</strong>. Creating a pointer to\
    \ a resource using the <code>new</code> operator is an <strong>anti-pattern</strong>\
    \ in modern C++. Use a special resource class (one of the Standard containers)\
    \ or a <strong>smart pointer</strong> (<code>std::unique_ptr&lt;&gt;</code> or\
    \ <code>std::shared_ptr&lt;&gt;</code>). Consider:   </p>\n<pre><code>{\n    auto\
    \ b = new Base;\n    ...       // oops, if an exception is thrown, destructor\
    \ not called!\n    delete b;\n}\n</code></pre>\n<p>vs. </p>\n<pre><code>{\n  \
    \  auto b = std::make_unique&lt;Base&gt;();\n    ...       // OK, now exception\
    \ safe\n}\n</code></pre>\n<p>A raw pointer should only be used as a \"view\" and\
    \ not in any way involved in ownership, be it through direct creation or implicitly\
    \ through return values. See also <a href=\"https://stackoverflow.com/questions/8706192/which-kind-of-pointer-do-i-use-when?lq=1\"\
    ><strong>this Q&amp;A from the C++ FAQ</strong></a>.</p>\n<p><strong>More fine-grained\
    \ life-time control</strong> Every time a shared pointer is being copied (e.g.\
    \ as a function argument) the resource it points to is being kept alive. Regular\
    \ objects (not created by <code>new</code>, either directly by you or inside a\
    \ resource class) are destroyed when going out of scope.</p>\n</div>"
- - Why should I use a pointer rather than the object itself?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>There are many excellent answers\
    \ to this question, including the important use cases of forward declarations,\
    \ polymorphism etc. but I feel a part of the \"soul\" of your question is not\
    \ answered - namely what the different syntaxes mean across Java and C++.</p>\n\
    <p>Let's examine the situation comparing the two languages:</p>\n<h3>Java:</h3>\n\
    <pre><code>Object object1 = new Object(); //A new object is allocated by Java\n\
    Object object2 = new Object(); //Another new object is allocated by Java\n\nobject1\
    \ = object2; \n//object1 now points to the object originally allocated for object2\n\
    //The object originally allocated for object1 is now \"dead\" - nothing points\
    \ to it, so it\n//will be reclaimed by the Garbage Collector.\n//If either object1\
    \ or object2 is changed, the change will be reflected to the other\n</code></pre>\n\
    <p>The closest equivalent to this, is:</p>\n<h3>C++:</h3>\n<pre><code>Object *\
    \ object1 = new Object(); //A new object is allocated on the heap\nObject * object2\
    \ = new Object(); //Another new object is allocated on the heap\ndelete object1;\n\
    //Since C++ does not have a garbage collector, if we don't do that, the next line\
    \ would \n//cause a \"memory leak\", i.e. a piece of claimed memory that the app\
    \ cannot use \n//and that we have no way to reclaim...\n\nobject1 = object2; //Same\
    \ as Java, object1 points to object2.\n</code></pre>\n<p>Let's see the alternative\
    \ C++ way:</p>\n<pre><code>Object object1; //A new object is allocated on the\
    \ STACK\nObject object2; //Another new object is allocated on the STACK\nobject1\
    \ = object2;//!!!! This is different! The CONTENTS of object2 are COPIED onto\
    \ object1,\n//using the \"copy assignment operator\", the definition of operator\
    \ =.\n//But, the two objects are still different. Change one, the other remains\
    \ unchanged.\n//Also, the objects get automatically destroyed once the function\
    \ returns...\n</code></pre>\n<p>The best way to think of it is that -- more or\
    \ less -- Java (implicitly) handles pointers to objects, while C++ may handle\
    \ either pointers to objects, or the objects themselves.\nThere are exceptions\
    \ to this -- for example, if you declare Java \"primitive\" types, they are actual\
    \ values that are copied, and not pointers.\nSo,</p>\n<h3>Java:</h3>\n<pre><code>int\
    \ object1; //An integer is allocated on the stack.\nint object2; //Another integer\
    \ is allocated on the stack.\nobject1 = object2; //The value of object2 is copied\
    \ to object1.\n</code></pre>\n<p>That said, using pointers is NOT necessarily\
    \ either the correct or the wrong way to handle things; however other answers\
    \ have covered that satisfactorily. The general idea though is that in C++ you\
    \ have much more control on the lifetime of the objects, and on where they will\
    \ live.</p>\n<p>Take home point -- the <code>Object * object = new Object()</code>\
    \ construct is actually what is closest to typical Java (or C# for that matter)\
    \ semantics.</p>\n</div>"
- - What is an undefined reference/unresolved external symbol error and how do I fix
    it?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Compiling a C++ program takes\
    \ place in several steps, as specified by <strong>2.2</strong> <a href=\"https://stackoverflow.com/a/8834196/673730\"\
    >(credits to Keith Thompson for the reference)</a>:</p>\n<blockquote>\n<p>The\
    \ precedence among the syntax rules of translation is specified by the following\
    \ phases <em>[see footnote]</em>.</p>\n<ol>\n<li>Physical source file characters\
    \ are mapped, in an implementation-defined manner, to the basic source character\
    \ set\n  (introducing new-line characters for end-of-line indicators) if\n  necessary.\
    \ <em>[SNIP]</em></li>\n<li>Each instance of a backslash character (\\) immediately\
    \ followed by a new-line character is deleted, splicing physical source lines\
    \ to\n  form logical source lines. <em>[SNIP]</em></li>\n<li>The source file is\
    \ decomposed into preprocessing tokens (2.5) and sequences of white-space characters\
    \ (including comments). <em>[SNIP]</em></li>\n<li>Preprocessing directives are\
    \ executed, macro invocations are expanded, and _Pragma unary operator expressions\
    \ are executed. <em>[SNIP]</em></li>\n<li>Each source character set member in\
    \ a character literal or a string literal, as well as each escape sequence and\
    \ universal-character-name\n  in a character literal or a non-raw string literal,\
    \ is converted to\n  the corresponding member of the execution character set;\
    \ <em>[SNIP]</em></li>\n<li>Adjacent string literal tokens are concatenated.</li>\n\
    <li>White-space characters separating tokens are no longer significant. Each preprocessing\
    \ token is converted into a token. (2.7). The\n  resulting tokens are syntactically\
    \ and semantically analyzed and\n  translated as a translation unit. <em>[SNIP]</em></li>\n\
    <li>Translated translation units and instantiation units are combined as follows:\
    \ <em>[SNIP]</em></li>\n<li><strong>All external entity references are resolved.\
    \ Library components are linked to satisfy external references to entities not\
    \ defined in the\n  current translation. All such translator output is collected\
    \ into a\n  program image which contains information needed for execution in its\n\
    \  execution environment.</strong> (emphasis mine)</li>\n</ol>\n<p><em>[footnote]</em>\
    \ Implementations must behave as if these separate phases occur, although in practice\
    \ different phases might be folded together.</p>\n</blockquote>\n<p>The specified\
    \ errors occur during this last stage of compilation, most commonly referred to\
    \ as linking. It basically means that you compiled a bunch of implementation files\
    \ into object files or libraries and now you want to get them to work together.</p>\n\
    <p>Say you defined symbol <code>a</code> in <code>a.cpp</code>. Now, <code>b.cpp</code>\
    \ <em>declared</em> that symbol and used it. Before linking, it simply assumes\
    \ that that symbol was defined <em>somewhere</em>, but it doesn't yet care where.\
    \ The linking phase is responsible for finding the symbol and correctly linking\
    \ it to <code>b.cpp</code> (well, actually to the object or library that uses\
    \ it).</p>\n<p>If you're using Microsoft Visual Studio, you'll see that projects\
    \ generate <code>.lib</code> files. These contain a table of exported symbols,\
    \ and a table of imported symbols. The imported symbols are resolved against the\
    \ libraries you link against, and the exported symbols are provided for the libraries\
    \ that use that <code>.lib</code> (if any).</p>\n<p>Similar mechanisms exist for\
    \ other compilers/ platforms.</p>\n<p>Common error messages are <code>error LNK2001</code>,\
    \ <code>error LNK1120</code>, <code>error LNK2019</code> for <strong>Microsoft\
    \ Visual Studio</strong> and <code>undefined reference to</code> <em>symbolName</em>\
    \ for <strong>GCC</strong>.</p>\n<p>The code:</p>\n<pre><code>struct X\n{\n  \
    \ virtual void foo();\n};\nstruct Y : X\n{\n   void foo() {}\n};\nstruct A\n{\n\
    \   virtual ~A() = 0;\n};\nstruct B: A\n{\n   virtual ~B(){}\n};\nextern int x;\n\
    void foo();\nint main()\n{\n   x = 0;\n   foo();\n   Y y;\n   B b;\n}\n</code></pre>\n\
    <p>will generate the following errors with <strong>GCC</strong>:</p>\n<pre><code>/home/AbiSfw/ccvvuHoX.o:\
    \ In function `main':\nprog.cpp:(.text+0x10): undefined reference to `x'\nprog.cpp:(.text+0x19):\
    \ undefined reference to `foo()'\nprog.cpp:(.text+0x2d): undefined reference to\
    \ `A::~A()'\n/home/AbiSfw/ccvvuHoX.o: In function `B::~B()':\nprog.cpp:(.text._ZN1BD1Ev[B::~B()]+0xb):\
    \ undefined reference to `A::~A()'\n/home/AbiSfw/ccvvuHoX.o: In function `B::~B()':\n\
    prog.cpp:(.text._ZN1BD0Ev[B::~B()]+0x12): undefined reference to `A::~A()'\n/home/AbiSfw/ccvvuHoX.o:(.rodata._ZTI1Y[typeinfo\
    \ for Y]+0x8): undefined reference to `typeinfo for X'\n/home/AbiSfw/ccvvuHoX.o:(.rodata._ZTI1B[typeinfo\
    \ for B]+0x8): undefined reference to `typeinfo for A'\ncollect2: ld returned\
    \ 1 exit status\n</code></pre>\n<p>and similar errors with <strong>Microsoft Visual\
    \ Studio</strong>:</p>\n<pre><code>1&gt;test2.obj : error LNK2001: unresolved\
    \ external symbol \"void __cdecl foo(void)\" (?foo@@YAXXZ)\n1&gt;test2.obj : error\
    \ LNK2001: unresolved external symbol \"int x\" (?x@@3HA)\n1&gt;test2.obj : error\
    \ LNK2001: unresolved external symbol \"public: virtual __thiscall A::~A(void)\"\
    \ (??1A@@UAE@XZ)\n1&gt;test2.obj : error LNK2001: unresolved external symbol \"\
    public: virtual void __thiscall X::foo(void)\" (?foo@X@@UAEXXZ)\n1&gt;...\\test2.exe\
    \ : fatal error LNK1120: 4 unresolved externals\n</code></pre>\n<p>Common causes\
    \ include:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/a/12574400/673730\"\
    >Failure to link against appropriate libraries/object files or compile implementation\
    \ files</a></li>\n<li><a href=\"https://stackoverflow.com/a/12574403/673730\"\
    >Declared and undefined variable or function.</a></li>\n<li><a href=\"https://stackoverflow.com/a/12574407/673730\"\
    >Common issues with class-type members</a></li>\n<li><a href=\"https://stackoverflow.com/a/12574417/673730\"\
    >Template implementations not visible.</a></li>\n<li><a href=\"https://stackoverflow.com/a/12574420/673730\"\
    >Symbols were defined in a C program and used in C++ code.</a></li>\n<li><a href=\"\
    https://stackoverflow.com/a/12574423/673730\">Incorrectly importing/exporting\
    \ methods/classes across modules/dll. (MSVS specific)</a></li>\n<li><a href=\"\
    https://stackoverflow.com/a/20358542/673730\">Circular library dependency</a></li>\n\
    <li><a href=\"https://stackoverflow.com/questions/5259714/undefined-reference-to-winmain16/5260237#5260237\"\
    >undefined reference to `WinMain@16'</a></li>\n<li><a href=\"https://stackoverflow.com/a/24675715/1356926\"\
    >Interdependent library order</a></li>\n<li><a href=\"https://stackoverflow.com/questions/14364362/visualstudio-project-with-multiple-sourcefiles-of-the-same-name\"\
    >Multiple source files of the same name</a></li>\n<li><a href=\"https://stackoverflow.com/a/25744263/3747990\"\
    >Mistyping or not including the .lib extension when using the <code>#pragma</code>\
    \ (Microsoft Visual Studio)</a></li>\n<li><a href=\"https://stackoverflow.com/a/35891188/3747990\"\
    >Problems with template friends</a></li>\n<li><a href=\"https://stackoverflow.com/a/36475406/3747990\"\
    >Inconsistent <code>UNICODE</code> definitions</a></li>\n</ul>\n</div>"
- - What is an undefined reference/unresolved external symbol error and how do I fix
    it?
  - "<div class=\"post-text\" itemprop=\"text\">\n<h2>Class members:</h2>\n<h3>A pure\
    \ <code>virtual</code> destructor needs an implementation.</h3>\n<p>Declaring\
    \ a destructor pure still requires you to define it (unlike a regular function):</p>\n\
    <pre><code>struct X\n{\n    virtual ~X() = 0;\n};\nstruct Y : X\n{\n    ~Y() {}\n\
    };\nint main()\n{\n    Y y;\n}\n//X::~X(){} //uncomment this line for successful\
    \ definition\n</code></pre>\n<p>This happens because base class destructors are\
    \ called when the object is destroyed implicitly, so a definition is required.\
    \    </p>\n<h3><code>virtual</code> methods must either be implemented or defined\
    \ as pure.</h3>\n<p>This is similar to non-<code>virtual</code> methods with no\
    \ definition, with the added reasoning that \nthe pure declaration generates a\
    \ dummy vtable and you might get the linker error without using the function:</p>\n\
    <pre><code>struct X\n{\n    virtual void foo();\n};\nstruct Y : X\n{\n   void\
    \ foo() {}\n};\nint main()\n{\n   Y y; //linker error although there was no call\
    \ to X::foo\n}\n</code></pre>\n<p>For this to work, declare <code>X::foo()</code>\
    \ as pure:</p>\n<pre><code>struct X\n{\n    virtual void foo() = 0;\n};\n</code></pre>\n\
    <h3>Non-<code>virtual</code> class members</h3>\n<p>Some members need to be defined\
    \ even if not used explicitly:</p>\n<pre><code>struct A\n{ \n    ~A();\n};\n</code></pre>\n\
    <p>The following would yield the error:</p>\n<pre><code>A a;      //destructor\
    \ undefined\n</code></pre>\n<p>The implementation can be inline, in the class\
    \ definition itself:</p>\n<pre><code>struct A\n{ \n    ~A() {}\n};\n</code></pre>\n\
    <p>or outside:</p>\n<pre><code>A::~A() {}\n</code></pre>\n<p>If the implementation\
    \ is outside the class definition, but in a header, the methods have to be marked\
    \ as <code>inline</code> to prevent a multiple definition.</p>\n<p>All used member\
    \ methods need to be defined if used.</p>\n<h3>A common mistake is forgetting\
    \ to qualify the name:</h3>\n<pre><code>struct A\n{\n   void foo();\n};\n\nvoid\
    \ foo() {}\n\nint main()\n{\n   A a;\n   a.foo();\n}\n</code></pre>\n<p>The definition\
    \ should be</p>\n<pre><code>void A::foo() {}\n</code></pre>\n<h3><code>static</code>\
    \ data members must be defined outside the class in a <strong>single translation\
    \ unit</strong>:</h3>\n<pre><code>struct X\n{\n    static int x;\n};\nint main()\n\
    {\n    int x = X::x;\n}\n//int X::x; //uncomment this line to define X::x\n</code></pre>\n\
    <p>An initializer can be provided for a <code>static</code> <code>const</code>\
    \ data member of integral or enumeration type within the class definition; however,\
    \ odr-use of this member will still require a namespace scope definition as described\
    \ above. C++11 allows initialization inside the class for all <code>static const</code>\
    \ data members.</p>\n</div>"
- - What is an undefined reference/unresolved external symbol error and how do I fix
    it?
  - "<div class=\"post-text\" itemprop=\"text\">\n<h3>Failure to link against appropriate\
    \ libraries/object files or compile implementation files</h3>\n<p>Commonly, each\
    \ translation unit will generate an object file that contains the definitions\
    \ of the symbols defined in that translation unit. \nTo use those symbols, you\
    \ have to link against those object files.</p>\n<p>Under <strong>gcc</strong>\
    \ you would specify all object files that are to be linked together in the command\
    \ line, or compile the implementation files together.</p>\n<pre><code>g++ -o test\
    \ objectFile1.o objectFile2.o -lLibraryName\n</code></pre>\n<p>The <code>libraryName</code>\
    \ here is just the bare name of the library, without platform-specific additions.\
    \ So e.g. on Linux library files are usually called <code>libfoo.so</code> but\
    \ you'd only write <code>-lfoo</code>. On Windows that same file might be called\
    \ <code>foo.lib</code>, but you'd use the same argument. You might have to add\
    \ the directory where those files can be found using <code>-L‹directory›</code>.\
    \ Make sure to not write a space after <code>-l</code> or <code>-L</code>.</p>\n\
    <p>For <strong>XCode</strong>:  Add the User Header Search Paths -&gt; add the\
    \ Library Search Path -&gt; drag and drop the actual library reference into the\
    \ project folder.</p>\n<p>Under <strong>MSVS</strong>, files added to a project\
    \ automatically have their object files linked together and a <code>lib</code>\
    \ file would be generated (in common usage). To use the symbols in a separate\
    \ project, you'd \nneed to include the <code>lib</code> files in the project settings.\
    \ This is done in the Linker section of the project properties, in <code>Input\
    \ -&gt; Additional Dependencies</code>. (the path to the <code>lib</code> file\
    \ should be\nadded in <code>Linker -&gt; General -&gt; Additional Library Directories</code>)\
    \ When using a third-party library that is provided with a <code>lib</code> file,\
    \ failure to do so usually results in the error.</p>\n<p>It can also happen that\
    \ you forget to add the file to the compilation, in which case the object file\
    \ won't be generated. In <strong>gcc</strong> you'd add the files to the command\
    \ line. In <strong>MSVS</strong> adding the file to the project will make it compile\
    \ it automatically (albeit files can, manually, be individually excluded from\
    \ the build).</p>\n<p>In Windows programming, the tell-tale sign that you did\
    \ not link a necessary library is that the name of the unresolved symbol begins\
    \ with <code>__imp_</code>. Look up the name of the function in the documentation,\
    \ and it should say which library you need to use. For example, MSDN puts the\
    \ information in a box at the bottom of each function in a section called \"Library\"\
    .</p>\n</div>"
- - What is a lambda expression in C++11?
  - "<div class=\"post-text\" itemprop=\"text\">\n<h1>The problem</h1>\n<p>C++ includes\
    \ useful generic functions like <code>std::for_each</code> and <code>std::transform</code>,\
    \ which can be very handy. Unfortunately they can also be quite cumbersome to\
    \ use, particularly if the <a href=\"https://stackoverflow.com/questions/356950/c-functors-and-their-uses\"\
    >functor</a> you would like to apply is unique to the particular function.</p>\n\
    <pre><code>#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nnamespace {\n\
    \  struct f {\n    void operator()(int) {\n      // do something\n    }\n  };\n\
    }\n\nvoid func(std::vector&lt;int&gt;&amp; v) {\n  f f;\n  std::for_each(v.begin(),\
    \ v.end(), f);\n}\n</code></pre>\n<p>If you only use <code>f</code> once and in\
    \ that specific place it seems overkill to be writing a whole class just to do\
    \ something trivial and one off.</p>\n<p>In C++03 you might be tempted to write\
    \ something like the following, to keep the functor local:</p>\n<pre><code>void\
    \ func2(std::vector&lt;int&gt;&amp; v) {\n  struct {\n    void operator()(int)\
    \ {\n       // do something\n    }\n  } f;\n  std::for_each(v.begin(), v.end(),\
    \ f);\n}\n</code></pre>\n<p>however this is not allowed, <code>f</code> cannot\
    \ be passed to a <a href=\"https://en.cppreference.com/w/cpp/language/function_template\"\
    \ rel=\"noreferrer\">template</a> function in C++03.</p>\n<h1>The new solution</h1>\n\
    <p>C++11 introduces lambdas allow you to write an inline, anonymous functor to\
    \ replace the <code>struct f</code>. For small simple examples this can be cleaner\
    \ to read (it keeps everything in one place) and potentially simpler to maintain,\
    \ for example in the simplest form:</p>\n<pre><code>void func3(std::vector&lt;int&gt;&amp;\
    \ v) {\n  std::for_each(v.begin(), v.end(), [](int) { /* do something here*/ });\n\
    }\n</code></pre>\n<p>Lambda functions are just syntactic sugar for anonymous functors.</p>\n\
    <h2>Return types</h2>\n<p>In simple cases the return type of the lambda is deduced\
    \ for you, e.g.:</p>\n<pre><code>void func4(std::vector&lt;double&gt;&amp; v)\
    \ {\n  std::transform(v.begin(), v.end(), v.begin(),\n                 [](double\
    \ d) { return d &lt; 0.00001 ? 0 : d; }\n                 );\n}\n</code></pre>\n\
    <p>however when you start to write more complex lambdas you will quickly encounter\
    \ cases where the return type cannot be deduced by the compiler, e.g.:</p>\n<pre><code>void\
    \ func4(std::vector&lt;double&gt;&amp; v) {\n    std::transform(v.begin(), v.end(),\
    \ v.begin(),\n        [](double d) {\n            if (d &lt; 0.0001) {\n     \
    \           return 0;\n            } else {\n                return d;\n     \
    \       }\n        });\n}\n</code></pre>\n<p>To resolve this you are allowed to\
    \ explicitly specify a return type for a lambda function, using <code>-&gt; T</code>:</p>\n\
    <pre><code>void func4(std::vector&lt;double&gt;&amp; v) {\n    std::transform(v.begin(),\
    \ v.end(), v.begin(),\n        [](double d) -&gt; double {\n            if (d\
    \ &lt; 0.0001) {\n                return 0;\n            } else {\n          \
    \      return d;\n            }\n        });\n}\n</code></pre>\n<h2>\"Capturing\"\
    \ variables</h2>\n<p>So far we've not used anything other than what was passed\
    \ to the lambda within it, but we can also use other variables, within the lambda.\
    \ If you want to access other variables you can use the capture clause (the <code>[]</code>\
    \ of the expression), which has so far been unused in these examples, e.g.:</p>\n\
    <pre><code>void func5(std::vector&lt;double&gt;&amp; v, const double&amp; epsilon)\
    \ {\n    std::transform(v.begin(), v.end(), v.begin(),\n        [epsilon](double\
    \ d) -&gt; double {\n            if (d &lt; epsilon) {\n                return\
    \ 0;\n            } else {\n                return d;\n            }\n       \
    \ });\n}\n</code></pre>\n<p>You can capture by both reference and value, which\
    \ you can specify using <code>&amp;</code> and <code>=</code> respectively:</p>\n\
    <ul>\n<li><code>[&amp;epsilon]</code> capture by reference</li>\n<li><code>[&amp;]</code>\
    \ captures all variables used in the lambda by reference</li>\n<li><code>[=]</code>\
    \ captures all variables used in the lambda by value</li>\n<li><code>[&amp;, epsilon]</code>\
    \ captures variables like with [&amp;], but epsilon by value</li>\n<li><code>[=,\
    \ &amp;epsilon]</code> captures variables like with [=], but epsilon by reference</li>\n\
    </ul>\n<p>The generated <code>operator()</code> is <code>const</code> by default,\
    \ with the implication that captures will be <code>const</code> when you access\
    \ them by default. This has the effect that each call with the same input would\
    \ produce the same result, however you can <a href=\"https://stackoverflow.com/questions/5501959/why-does-c0xs-lambda-require-mutable-keyword-for-capture-by-value-by-defaul\"\
    >mark the lambda as <code>mutable</code></a> to request that the <code>operator()</code>\
    \ that is produced is not <code>const</code>.</p>\n</div>"
- - What is a lambda expression in C++11?
  - "<div class=\"post-text\" itemprop=\"text\">\n<h1>What is a lambda function?</h1>\n\
    <p>The C++ concept of a lambda function originates in the lambda calculus and\
    \ functional programming. A lambda is an unnamed function that is useful (in actual\
    \ programming, not theory) for short snippets of code that are impossible to reuse\
    \ and are not worth naming.</p>\n<p>In C++ a lambda function is defined like this</p>\n\
    <pre><code>[]() { } // barebone lambda\n</code></pre>\n<p>or in all its glory</p>\n\
    <pre><code>[]() mutable -&gt; T { } // T is the return type, still lacking throw()\n\
    </code></pre>\n<p><code>[]</code> is the capture list, <code>()</code> the argument\
    \ list and <code>{}</code> the function body.</p>\n<h2>The capture list</h2>\n\
    <p>The capture list defines what from the outside of the lambda should be available\
    \ inside the function body and how.\nIt can be either:</p>\n<ol>\n<li>a value:\
    \ [x]</li>\n<li>a reference [&amp;x]</li>\n<li>any variable currently in scope\
    \ by reference [&amp;]</li>\n<li>same as 3, but by value [=]</li>\n</ol>\n<p>You\
    \ can mix any of the above in a comma separated list <code>[x, &amp;y]</code>.</p>\n\
    <h2>The argument list</h2>\n<p>The argument list is the same as in any other C++\
    \ function. </p>\n<h2>The function body</h2>\n<p>The code that will be executed\
    \ when the lambda is actually called.</p>\n<h2>Return type deduction</h2>\n<p>If\
    \ a lambda has only one return statement, the return type can be omitted and has\
    \ the implicit type of <code>decltype(return_statement)</code>.</p>\n<h2>Mutable</h2>\n\
    <p>If a lambda is marked mutable (e.g. <code>[]() mutable { }</code>) it is allowed\
    \ to mutate the values that have been captured by value.</p>\n<h1>Use cases</h1>\n\
    <p>The library defined by the ISO standard benefits heavily from lambdas and raises\
    \ the usability several bars as now users don't have to clutter their code with\
    \ small functors in some accessible scope.</p>\n<h1>C++14</h1>\n<p>In C++14 lambdas\
    \ have been extended by various proposals.</p>\n<h2>Initialized Lambda Captures</h2>\n\
    <p>An element of the capture list can now be initialized with <code>=</code>.\
    \ This allows renaming of variables and to capture by moving. An example taken\
    \ from the standard:</p>\n<pre><code>int x = 4;\nauto y = [&amp;r = x, x = x+1]()-&gt;int\
    \ {\n            r += 2;\n            return x+2;\n         }();  // Updates ::x\
    \ to 6, and initializes y to 7.\n</code></pre>\n<p>and one taken from Wikipedia\
    \ showing how to capture with <code>std::move</code>:</p>\n<pre><code>auto ptr\
    \ = std::make_unique&lt;int&gt;(10); // See below for std::make_unique\nauto lambda\
    \ = [ptr = std::move(ptr)] {return *ptr;};\n</code></pre>\n<h2>Generic Lambdas</h2>\n\
    <p>Lambdas can now be generic (<code>auto</code> would be equivalent to <code>T</code>\
    \ here if\n<code>T</code> were a type template argument somewhere in the surrounding\
    \ scope):</p>\n<pre><code>auto lambda = [](auto x, auto y) {return x + y;};\n\
    </code></pre>\n<h2>Improved Return Type Deduction</h2>\n<p>C++14 allows deduced\
    \ return types for every function and does not restrict it to functions of the\
    \ form <code>return expression;</code>. This is also extended to lambdas.</p>\n\
    </div>"
- - What is a lambda expression in C++11?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Lambda expressions are typically\
    \ used to encapsulate algorithms so that they can be passed to another function.\
    \  However, <strong>it is possible to execute a lambda immediately upon definition</strong>:</p>\n\
    <pre><code>[&amp;](){ ...your code... }(); // immediately executed lambda expression\n\
    </code></pre>\n<p>is functionally equivalent to</p>\n<pre><code>{ ...your code...\
    \ } // simple code block\n</code></pre>\n<p>This makes lambda expressions <strong>a\
    \ powerful tool for refactoring complex functions</strong>.  You start by wrapping\
    \ a code section in a lambda function as shown above.  The process of explicit\
    \ parameterization can then be performed gradually with intermediate testing after\
    \ each step.  Once you have the code-block fully parameterized (as demonstrated\
    \ by the removal of the <code>&amp;</code>), you can move the code to an external\
    \ location and make it a normal function.</p>\n<p>Similarly, you can use lambda\
    \ expressions to <strong>initialize variables based on the result of an algorithm</strong>...</p>\n\
    <pre><code>int a = []( int b ){ int r=1; while (b&gt;0) r*=b--; return r; }(5);\
    \ // 5!\n</code></pre>\n<p>As <strong>a way of partitioning your program logic</strong>,\
    \ you might even find it useful to pass a lambda expression as an argument to\
    \ another lambda expression...</p>\n<pre><code>[&amp;]( std::function&lt;void()&gt;\
    \ algorithm ) // wrapper section\n   {\n   ...your wrapper code...\n   algorithm();\n\
    \   ...your wrapper code...\n   }\n([&amp;]() // algorithm section\n   {\n   ...your\
    \ algorithm code...\n   });\n</code></pre>\n<p>Lambda expressions also let you\
    \ create named <a href=\"http://en.wikipedia.org/wiki/Nested_function\" rel=\"\
    noreferrer\"><strong>nested functions</strong></a>, which can be a convenient\
    \ way of avoiding duplicate logic.  Using named lambdas also tends to be a little\
    \ easier on the eyes (compared to anonymous inline lambdas) when passing a non-trivial\
    \ function as a parameter to another function.  <em>Note: don't forget the semicolon\
    \ after the closing curly brace.</em></p>\n<pre><code>auto algorithm = [&amp;](\
    \ double x, double m, double b ) -&gt; double\n   {\n   return m*x+b;\n   };\n\
    \nint a=algorithm(1,2,3), b=algorithm(4,5,6);\n</code></pre>\n<p>If subsequent\
    \ profiling reveals significant initialization overhead for the function object,\
    \ you might choose to rewrite this as a normal function.</p>\n</div>"
- - Replacing a 32-bit loop counter with 64-bit introduces crazy performance deviations
  - "<div class=\"post-text\" itemprop=\"text\">\n<p><strong>Culprit: False Data Dependency</strong>\
    \ (and the compiler isn't even aware of it)</p>\n<p>On Sandy/Ivy Bridge and Haswell\
    \ processors, the instruction:</p>\n<pre><code>popcnt  src, dest\n</code></pre>\n\
    <p>appears to have a false dependency on the destination register <code>dest</code>.\
    \ Even though the instruction only writes to it, the instruction will wait until\
    \ <code>dest</code> is ready before executing.</p>\n<p>This dependency doesn't\
    \ just hold up the 4 <code>popcnt</code>s from a single loop iteration. It can\
    \ carry across loop iterations making it impossible for the processor to parallelize\
    \ different loop iterations.</p>\n<p>The <code>unsigned</code> vs. <code>uint64_t</code>\
    \ and other tweaks don't directly affect the problem. But they influence the register\
    \ allocator which assigns the registers to the variables.</p>\n<p>In your case,\
    \ the speeds are a direct result of what is stuck to the (false) dependency chain\
    \ depending on what the register allocator decided to do.</p>\n<ul>\n<li>13 GB/s\
    \ has a chain: <code>popcnt</code>-<code>add</code>-<code>popcnt</code>-<code>popcnt</code>\
    \ → next iteration</li>\n<li>15 GB/s has a chain: <code>popcnt</code>-<code>add</code>-<code>popcnt</code>-<code>add</code>\
    \ → next iteration</li>\n<li>20 GB/s has a chain: <code>popcnt</code>-<code>popcnt</code>\
    \ → next iteration</li>\n<li>26 GB/s has a chain: <code>popcnt</code>-<code>popcnt</code>\
    \ → next iteration</li>\n</ul>\n<p>The difference between 20 GB/s and 26 GB/s\
    \ seems to be a minor artifact of the indirect addressing. Either way, the processor\
    \ starts to hit other bottlenecks once you reach this speed.</p>\n<hr/>\n<p>To\
    \ test this, I used inline assembly to bypass the compiler and get exactly the\
    \ assembly I want. I also split up the <code>count</code> variable to break all\
    \ other dependencies that might mess with the benchmarks.</p>\n<p>Here are the\
    \ results:</p>\n<p><strong>Sandy Bridge Xeon @ 3.5 GHz:</strong> (full test code\
    \ can be found at the bottom)</p>\n<ul>\n<li>GCC 4.6.3: <code>g++ popcnt.cpp -std=c++0x\
    \ -O3 -save-temps -march=native</code></li>\n<li>Ubuntu 12</li>\n</ul>\n<p>Different\
    \ Registers: <strong>18.6195 GB/s</strong></p>\n<pre><code>.L4:\n    movq    (%rbx,%rax,8),\
    \ %r8\n    movq    8(%rbx,%rax,8), %r9\n    movq    16(%rbx,%rax,8), %r10\n  \
    \  movq    24(%rbx,%rax,8), %r11\n    addq    $4, %rax\n\n    popcnt %r8, %r8\n\
    \    add    %r8, %rdx\n    popcnt %r9, %r9\n    add    %r9, %rcx\n    popcnt %r10,\
    \ %r10\n    add    %r10, %rdi\n    popcnt %r11, %r11\n    add    %r11, %rsi\n\n\
    \    cmpq    $131072, %rax\n    jne .L4\n</code></pre>\n<p>Same Register: <strong>8.49272\
    \ GB/s</strong></p>\n<pre><code>.L9:\n    movq    (%rbx,%rdx,8), %r9\n    movq\
    \    8(%rbx,%rdx,8), %r10\n    movq    16(%rbx,%rdx,8), %r11\n    movq    24(%rbx,%rdx,8),\
    \ %rbp\n    addq    $4, %rdx\n\n    # This time reuse \"rax\" for all the popcnts.\n\
    \    popcnt %r9, %rax\n    add    %rax, %rcx\n    popcnt %r10, %rax\n    add \
    \   %rax, %rsi\n    popcnt %r11, %rax\n    add    %rax, %r8\n    popcnt %rbp,\
    \ %rax\n    add    %rax, %rdi\n\n    cmpq    $131072, %rdx\n    jne .L9\n</code></pre>\n\
    <p>Same Register with broken chain: <strong>17.8869 GB/s</strong></p>\n<pre><code>.L14:\n\
    \    movq    (%rbx,%rdx,8), %r9\n    movq    8(%rbx,%rdx,8), %r10\n    movq  \
    \  16(%rbx,%rdx,8), %r11\n    movq    24(%rbx,%rdx,8), %rbp\n    addq    $4, %rdx\n\
    \n    # Reuse \"rax\" for all the popcnts.\n    xor    %rax, %rax    # Break the\
    \ cross-iteration dependency by zeroing \"rax\".\n    popcnt %r9, %rax\n    add\
    \    %rax, %rcx\n    popcnt %r10, %rax\n    add    %rax, %rsi\n    popcnt %r11,\
    \ %rax\n    add    %rax, %r8\n    popcnt %rbp, %rax\n    add    %rax, %rdi\n\n\
    \    cmpq    $131072, %rdx\n    jne .L14\n</code></pre>\n<hr/>\n<p><strong>So\
    \ what went wrong with the compiler?</strong></p>\n<p>It seems that neither GCC\
    \ nor Visual Studio are aware that <code>popcnt</code> has such a false dependency.\
    \ Nevertheless, these false dependencies aren't uncommon. It's just a matter of\
    \ whether the compiler is aware of it.</p>\n<p><code>popcnt</code> isn't exactly\
    \ the most used instruction. So it's not really a surprise that a major compiler\
    \ could miss something like this. There also appears to be no documentation anywhere\
    \ that mentions this problem. If Intel doesn't disclose it, then nobody outside\
    \ will know until someone runs into it by chance.</p>\n<p>(<strong>Update:</strong>\
    \ <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=62011#c13\">As of version\
    \ 4.9.2</a>, GCC is aware of this false-dependency and generates code to compensate\
    \ it when optimizations are enabled. Major compilers from other vendors, including\
    \ Clang, MSVC, and even Intel's own ICC are not yet aware of this microarchitectural\
    \ erratum and will not emit code that compensates for it.)</p>\n<p><strong>Why\
    \ does the CPU have such a false dependency?</strong></p>\n<p>We can only speculate,\
    \ but it's likely that Intel has the same handling for a lot of two-operand instructions.\
    \ Common instructions like <code>add</code>, <code>sub</code> take two operands\
    \ both of which are inputs. So Intel probably shoved <code>popcnt</code> into\
    \ the same category to keep the processor design simple.</p>\n<p>AMD processors\
    \ do not appear to have this false dependency.</p>\n<hr/>\n<p>The full test code\
    \ is below for reference:</p>\n<pre><code>#include &lt;iostream&gt;\n#include\
    \ &lt;chrono&gt;\n#include &lt;x86intrin.h&gt;\n\nint main(int argc, char* argv[])\
    \ {\n\n   using namespace std;\n   uint64_t size=1&lt;&lt;20;\n\n   uint64_t*\
    \ buffer = new uint64_t[size/8];\n   char* charbuffer=reinterpret_cast&lt;char*&gt;(buffer);\n\
    \   for (unsigned i=0;i&lt;size;++i) charbuffer[i]=rand()%256;\n\n   uint64_t\
    \ count,duration;\n   chrono::time_point&lt;chrono::system_clock&gt; startP,endP;\n\
    \   {\n      uint64_t c0 = 0;\n      uint64_t c1 = 0;\n      uint64_t c2 = 0;\n\
    \      uint64_t c3 = 0;\n      startP = chrono::system_clock::now();\n      for(\
    \ unsigned k = 0; k &lt; 10000; k++){\n         for (uint64_t i=0;i&lt;size/8;i+=4)\
    \ {\n            uint64_t r0 = buffer[i + 0];\n            uint64_t r1 = buffer[i\
    \ + 1];\n            uint64_t r2 = buffer[i + 2];\n            uint64_t r3 = buffer[i\
    \ + 3];\n            __asm__(\n                \"popcnt %4, %4  \\n\\t\"\n   \
    \             \"add %4, %0     \\n\\t\"\n                \"popcnt %5, %5  \\n\\\
    t\"\n                \"add %5, %1     \\n\\t\"\n                \"popcnt %6, %6\
    \  \\n\\t\"\n                \"add %6, %2     \\n\\t\"\n                \"popcnt\
    \ %7, %7  \\n\\t\"\n                \"add %7, %3     \\n\\t\"\n              \
    \  : \"+r\" (c0), \"+r\" (c1), \"+r\" (c2), \"+r\" (c3)\n                : \"\
    r\"  (r0), \"r\"  (r1), \"r\"  (r2), \"r\"  (r3)\n            );\n         }\n\
    \      }\n      count = c0 + c1 + c2 + c3;\n      endP = chrono::system_clock::now();\n\
    \      duration=chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(endP-startP).count();\n\
    \      cout &lt;&lt; \"No Chain\\t\" &lt;&lt; count &lt;&lt; '\\t' &lt;&lt; (duration/1.0E9)\
    \ &lt;&lt; \" sec \\t\"\n            &lt;&lt; (10000.0*size)/(duration) &lt;&lt;\
    \ \" GB/s\" &lt;&lt; endl;\n   }\n   {\n      uint64_t c0 = 0;\n      uint64_t\
    \ c1 = 0;\n      uint64_t c2 = 0;\n      uint64_t c3 = 0;\n      startP = chrono::system_clock::now();\n\
    \      for( unsigned k = 0; k &lt; 10000; k++){\n         for (uint64_t i=0;i&lt;size/8;i+=4)\
    \ {\n            uint64_t r0 = buffer[i + 0];\n            uint64_t r1 = buffer[i\
    \ + 1];\n            uint64_t r2 = buffer[i + 2];\n            uint64_t r3 = buffer[i\
    \ + 3];\n            __asm__(\n                \"popcnt %4, %%rax   \\n\\t\"\n\
    \                \"add %%rax, %0      \\n\\t\"\n                \"popcnt %5, %%rax\
    \   \\n\\t\"\n                \"add %%rax, %1      \\n\\t\"\n                \"\
    popcnt %6, %%rax   \\n\\t\"\n                \"add %%rax, %2      \\n\\t\"\n \
    \               \"popcnt %7, %%rax   \\n\\t\"\n                \"add %%rax, %3\
    \      \\n\\t\"\n                : \"+r\" (c0), \"+r\" (c1), \"+r\" (c2), \"+r\"\
    \ (c3)\n                : \"r\"  (r0), \"r\"  (r1), \"r\"  (r2), \"r\"  (r3)\n\
    \                : \"rax\"\n            );\n         }\n      }\n      count =\
    \ c0 + c1 + c2 + c3;\n      endP = chrono::system_clock::now();\n      duration=chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(endP-startP).count();\n\
    \      cout &lt;&lt; \"Chain 4   \\t\"  &lt;&lt; count &lt;&lt; '\\t' &lt;&lt;\
    \ (duration/1.0E9) &lt;&lt; \" sec \\t\"\n            &lt;&lt; (10000.0*size)/(duration)\
    \ &lt;&lt; \" GB/s\" &lt;&lt; endl;\n   }\n   {\n      uint64_t c0 = 0;\n    \
    \  uint64_t c1 = 0;\n      uint64_t c2 = 0;\n      uint64_t c3 = 0;\n      startP\
    \ = chrono::system_clock::now();\n      for( unsigned k = 0; k &lt; 10000; k++){\n\
    \         for (uint64_t i=0;i&lt;size/8;i+=4) {\n            uint64_t r0 = buffer[i\
    \ + 0];\n            uint64_t r1 = buffer[i + 1];\n            uint64_t r2 = buffer[i\
    \ + 2];\n            uint64_t r3 = buffer[i + 3];\n            __asm__(\n    \
    \            \"xor %%rax, %%rax   \\n\\t\"   // &lt;--- Break the chain.\n   \
    \             \"popcnt %4, %%rax   \\n\\t\"\n                \"add %%rax, %0 \
    \     \\n\\t\"\n                \"popcnt %5, %%rax   \\n\\t\"\n              \
    \  \"add %%rax, %1      \\n\\t\"\n                \"popcnt %6, %%rax   \\n\\t\"\
    \n                \"add %%rax, %2      \\n\\t\"\n                \"popcnt %7,\
    \ %%rax   \\n\\t\"\n                \"add %%rax, %3      \\n\\t\"\n          \
    \      : \"+r\" (c0), \"+r\" (c1), \"+r\" (c2), \"+r\" (c3)\n                :\
    \ \"r\"  (r0), \"r\"  (r1), \"r\"  (r2), \"r\"  (r3)\n                : \"rax\"\
    \n            );\n         }\n      }\n      count = c0 + c1 + c2 + c3;\n    \
    \  endP = chrono::system_clock::now();\n      duration=chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(endP-startP).count();\n\
    \      cout &lt;&lt; \"Broken Chain\\t\"  &lt;&lt; count &lt;&lt; '\\t' &lt;&lt;\
    \ (duration/1.0E9) &lt;&lt; \" sec \\t\"\n            &lt;&lt; (10000.0*size)/(duration)\
    \ &lt;&lt; \" GB/s\" &lt;&lt; endl;\n   }\n\n   free(charbuffer);\n}\n</code></pre>\n\
    <hr/>\n<p>An equally interesting benchmark can be found here: <a href=\"http://pastebin.com/kbzgL8si\"\
    >http://pastebin.com/kbzgL8si</a>\n<br/>\nThis benchmark varies the number of\
    \ <code>popcnt</code>s that are in the (false) dependency chain.</p>\n<pre><code>False\
    \ Chain 0:  41959360000 0.57748 sec     18.1578 GB/s\nFalse Chain 1:  41959360000\
    \ 0.585398 sec    17.9122 GB/s\nFalse Chain 2:  41959360000 0.645483 sec    16.2448\
    \ GB/s\nFalse Chain 3:  41959360000 0.929718 sec    11.2784 GB/s\nFalse Chain\
    \ 4:  41959360000 1.23572 sec     8.48557 GB/s\n</code></pre>\n</div>"
- - Replacing a 32-bit loop counter with 64-bit introduces crazy performance deviations
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>I coded up an equivalent C program\
    \ to experiment, and I can confirm this strange behaviour. What's more, <code>gcc</code>\
    \ believes the 64-bit integer (which should probably be a <code>size_t</code>\
    \ anyway...) to be better, as using <code>uint_fast32_t</code> causes gcc to use\
    \ a 64-bit uint.<br/><br/>\nI did a bit of mucking around with the assembly:<br/>\n\
    Simply take the 32-bit version, replace all 32-bit instructions/registers with\
    \ the 64-bit version in the inner popcount-loop of the program. Observation: the\
    \ code is <strong>just as fast as the 32-bit version!</strong><br/><br/>\nThis\
    \ is obviously a hack, as the size of the variable isn't really 64 bit, as other\
    \ parts of the program still use the 32-bit version, but as long as the inner\
    \ popcount-loop dominates performance, this is a good start.<br/><br/>\nI then\
    \ copied the inner loop code from the 32-bit version of the program, hacked it\
    \ up to be 64 bit, fiddled with the registers to make it a replacement for the\
    \ inner loop of the 64-bit version. <strong>This code also runs as fast as the\
    \ 32-bit version.</strong><br/><br/>\nMy conclusion is that this is bad instruction\
    \ scheduling by the compiler, not actual speed/latency advantage of 32-bit instructions.<br/><br/>\
    \ (Caveat: I hacked up assembly, could have broken something without noticing.\
    \ I don't think so.)</p>\n</div>"
- - Replacing a 32-bit loop counter with 64-bit introduces crazy performance deviations
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>This is not an answer, but it's\
    \ hard to read if I put results in comment.</p>\n<p>I get these results with a\
    \ <a href=\"http://en.wikipedia.org/wiki/Mac_Pro\" rel=\"noreferrer\">Mac Pro</a>\
    \ (<a href=\"http://en.wikipedia.org/wiki/Westmere_%28microarchitecture%29\" rel=\"\
    noreferrer\">Westmere</a> 6-Cores <a href=\"http://en.wikipedia.org/wiki/Xeon\"\
    \ rel=\"noreferrer\">Xeon</a> 3.33 GHz). I compiled it with <code>clang -O3 -msse4\
    \ -lstdc++ a.cpp -o a</code> (-O2 get same result).</p>\n<h3>clang with <code>uint64_t\
    \ size=atol(argv[1])&lt;&lt;20;</code></h3>\n<pre><code>unsigned    41950110000\
    \ 0.811198 sec    12.9263 GB/s\nuint64_t    41950110000 0.622884 sec    16.8342\
    \ GB/s\n</code></pre>\n<h3>clang with <code>uint64_t size=1&lt;&lt;20;</code></h3>\n\
    <pre><code>unsigned    41950110000 0.623406 sec    16.8201 GB/s\nuint64_t    41950110000\
    \ 0.623685 sec    16.8126 GB/s\n</code></pre>\n<p>I also tried to:</p>\n<ol>\n\
    <li>Reverse the test order, the result is the same so it rules out the cache factor.</li>\n\
    <li>Have the <code>for</code> statement in reverse: <code>for (uint64_t i=size/8;i&gt;0;i-=4)</code>.\
    \ This gives the same result and proves the compile is smart enough to not divide\
    \ size by 8 every iteration (as expected).</li>\n</ol>\n<p>Here is my wild guess:</p>\n\
    <p>The speed factor comes in three parts:</p>\n<ul>\n<li><p>code cache: <code>uint64_t</code>\
    \ version has larger code size, but this does not have an effect on my Xeon CPU.\
    \ This makes the 64-bit version slower.</p></li>\n<li><p>Instructions used. Note\
    \ not only the loop count, but the buffer is accessed with a 32-bit and 64-bit\
    \ index on the two versions. Accessing a pointer with a 64-bit offset requests\
    \ a dedicated 64-bit register and addressing, while you can use immediate for\
    \ a 32-bit offset. This may make the 32-bit version faster.</p></li>\n<li><p>Instructions\
    \ are only emitted on the 64-bit compile (that is, prefetch). This makes 64-bit\
    \ faster.</p></li>\n</ul>\n<p>The three factors together match with the observed\
    \ seemingly conflicting results.</p>\n</div>"
- - What are rvalues, lvalues, xvalues, glvalues, and prvalues?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>I guess this document might serve\
    \ as a not so short introduction : <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf\"\
    \ rel=\"noreferrer\">n3055</a></p>\n<p>The whole massacre began with the move\
    \ semantics. Once we have expressions that can be moved and not copied, suddenly\
    \ easy to grasp rules demanded distinction between expressions that can be moved,\
    \ and in which direction.</p>\n<p>From what I guess based on the draft, the r/l\
    \ value distinction stays the same, only in the context of moving things get messy.\
    \ </p>\n<p>Are they needed? Probably not if we wish to forfeit the new features.\
    \ But to allow better optimization we should probably embrace them.</p>\n<p><strong>Quoting\
    \ <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf\"\
    \ rel=\"noreferrer\">n3055</a>:</strong></p>\n<ul>\n<li>An <strong>lvalue</strong>\
    \ (so-called, historically,\nbecause lvalues could appear on the\nleft-hand side\
    \  of an assignment\nexpression) designates a function or\nan object.  <em>[Example:\
    \ If <code>E</code> is  an\nexpression of pointer type, then <code>*E</code>\n\
    is an lvalue expression referring to\nthe object  or function to which <code>E</code>\n\
    points.  As another example, the\nresult of calling a function  whose\nreturn\
    \ type is an lvalue reference is\nan lvalue.]</em> </li>\n<li>An <strong>xvalue</strong>\
    \ (an\n“eXpiring” value) also refers to an\nobject, usually near the end of its\
    \ \nlifetime (so that its resources may\nbe moved, for example).  An xvalue is\n\
    the result  of certain kinds of\nexpressions involving rvalue\nreferences.  <em>[Example:\
    \ The \nresult of calling a function whose\nreturn type is an rvalue reference\
    \ is\nan xvalue.]</em></li>\n<li>A <strong>glvalue</strong>   (“generalized” lvalue)\
    \ is an <strong>lvalue</strong>\nor an <strong>xvalue</strong>. </li>\n<li>An\
    \ <strong>rvalue</strong> (so-called,\nhistorically, because rvalues could\nappear\
    \ on the right-hand  side of an\nassignment expression) is an xvalue,\na temporary\
    \ object or\nsubobject thereof, or a value that is\nnot associated with an object.\
    \ </li>\n<li>A\n<strong>prvalue</strong> (“pure” rvalue) is an rvalue\nthat is\
    \ not an xvalue.  <em>[Example: The\nresult  of calling a function whose\nreturn\
    \ type is not a reference is a\nprvalue]</em></li>\n</ul>\n<p>The document in\
    \ question is a great reference for this question, because it shows the exact\
    \ changes in the standard that have happened as a result of the introduction of\
    \ the new nomenclature.</p>\n</div>"
- - What are rvalues, lvalues, xvalues, glvalues, and prvalues?
  - "<div class=\"post-text\" itemprop=\"text\">\n<blockquote>\n<p>What are these\
    \ new categories of expressions?</p>\n</blockquote>\n<p>The <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2010/n3092.pdf\"\
    \ rel=\"noreferrer\">FCD (n3092)</a> has an excellent description:</p>\n<blockquote>\n\
    <p>— An lvalue (so called, historically, because lvalues could appear on the\n\
    \  left-hand side of an assignment\n  expression) designates a function or\n \
    \ an object. [ Example: If E is an\n  expression of pointer type, then\n  *E is\
    \ an lvalue expression referring to the object or function to which E\n  points.\
    \ As another example, the result\n  of calling a function whose return\n  type\
    \ is an lvalue reference is an\n  lvalue. —end example ] </p>\n<p>— An xvalue\
    \ (an\n  “eXpiring” value) also refers to an\n  object, usually near the end of\
    \ its\n  lifetime (so that its resources may be\n  moved, for example). An xvalue\
    \ is the\n  result of certain kinds of expressions\n  involving rvalue references\
    \ (8.3.2). [\n  Example: The result of calling a\n  function whose return type\
    \ is an\n  rvalue reference is an xvalue. —end\n  example ] </p>\n<p>— A glvalue\
    \ (“generalized”\n  lvalue) is an lvalue or an xvalue.</p>\n<p>—\n  An rvalue\
    \ (so called, historically,\n  because rvalues could appear on the\n  right-hand\
    \ side of an assignment\n  expressions) is an xvalue, a temporary\n  object (12.2)\
    \ or subobject thereof, or\n  a value that is not associated with an\n  object.</p>\n\
    <p>— A prvalue (“pure” rvalue) is\n  an rvalue that is not an xvalue. [\n  Example:\
    \ The result of calling a\n  function whose return type is not a\n  reference\
    \ is a prvalue. The value of a\n  literal such as 12, 7.3e5, or true is\n  also\
    \ a prvalue. —end example ]</p>\n<p>Every\n  expression belongs to exactly one\
    \ of\n  the fundamental classifications in\n  this taxonomy: lvalue, xvalue, or\n\
    \  prvalue. This property of an\n  expression is called its value\n  category.\
    \ [ Note: The discussion of\n  each built-in operator in Clause 5\n  indicates\
    \ the category of the value it\n  yields and the value categories of the\n  operands\
    \ it expects. For example, the\n  built-in assignment operators expect\n  that\
    \ the left operand is an lvalue and\n  that the right operand is a prvalue\n \
    \ and yield an lvalue as the result.\n  User-defined operators are functions,\n\
    \  and the categories of values they\n  expect and yield are determined by\n \
    \ their parameter and return types. —end\n  note</p>\n</blockquote>\n<p>I suggest\
    \ you read the entire section <strong>3.10 Lvalues and rvalues</strong> though.</p>\n\
    <blockquote>\n<p>How do these new categories relate to the existing rvalue and\
    \ lvalue categories? </p>\n</blockquote>\n<p>Again: </p>\n<p><img alt=\"Taxonomy\"\
    \ src=\"https://i.stack.imgur.com/GNhBF.png\"/></p>\n<blockquote>\n<p>Are the\
    \ rvalue and lvalue categories in C++0x the same as they are in C++03?</p>\n</blockquote>\n\
    <p>The semantics of rvalues has evolved particularly with the introduction of\
    \ move semantics.</p>\n<blockquote>\n<p>Why are these new categories needed?</p>\n\
    </blockquote>\n<p>So that move construction/assignment could be defined and supported.</p>\n\
    </div>"
- - What are rvalues, lvalues, xvalues, glvalues, and prvalues?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>I'll start with your last question:</p>\n\
    <blockquote>\n<p>Why are these new categories needed? </p>\n</blockquote>\n<p>The\
    \ C++ standard contains many rules that deal with the value category of an expression.\
    \ Some rules make a distinction between lvalue and rvalue. For example, when it\
    \ comes to overload resolution. Other rules make a distinction between glvalue\
    \ and prvalue. For example, you can have a glvalue with an incomplete or abstract\
    \ type but there is no prvalue with an incomplete or abstract type. Before we\
    \ had this terminology the rules that actually need to distinguish between glvalue/prvalue\
    \ referred to lvalue/rvalue and they were either unintentionally wrong or contained\
    \ lots of explaining and exceptions to the rule a la \"...unless the rvalue is\
    \ due to unnamed rvalue reference...\". So, it seems like a good idea to just\
    \ give the concepts of glvalues and prvalues their own name.</p>\n<blockquote>\n\
    <p>What are these new categories of expressions?\n  How do these new categories\
    \ relate to the existing rvalue and lvalue categories?</p>\n</blockquote>\n<p>We\
    \ still have the terms lvalue and rvalue that are compatible with C++98. We just\
    \ divided the rvalues into two subgroups, xvalues and prvalues, and we refer to\
    \ lvalues and xvalues as glvalues. Xvalues are a new kind of value category for\
    \ unnamed rvalue references. Every expression is one of these three: lvalue, xvalue,\
    \ prvalue. A Venn diagram would look like this:</p>\n<pre><code>    ______ ______\n\
    \   /      X      \\\n  /      / \\      \\\n |   l  | x |  pr  |\n  \\      \\\
    \ /      /\n   \\______X______/\n       gl    r\n</code></pre>\n<p>Examples with\
    \ functions:</p>\n<pre><code>int   prvalue();\nint&amp;  lvalue();\nint&amp;&amp;\
    \ xvalue();\n</code></pre>\n<p>But also don't forget that named rvalue references\
    \ are lvalues:</p>\n<pre><code>void foo(int&amp;&amp; t) {\n  // t is initialized\
    \ with an rvalue expression\n  // but is actually an lvalue expression itself\n\
    }\n</code></pre>\n</div>"
- - What is the difference between const int*, const int * const, and int const *?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Read it backwards (as driven\
    \ by <a href=\"http://c-faq.com/decl/spiral.anderson.html\" rel=\"noreferrer\"\
    >Clockwise/Spiral Rule</a>):</p>\n<ul>\n<li><code>int*</code> - pointer to int</li>\n\
    <li><code>int const *</code> - pointer to const int</li>\n<li><code>int * const</code>\
    \ - const pointer to int</li>\n<li><code>int const * const</code> - const pointer\
    \ to const int</li>\n</ul>\n<p>Now the first <code>const</code> can be on either\
    \ side of the type so:</p>\n<ul>\n<li><code>const int *</code> == <code>int const\
    \ *</code></li>\n<li><code>const int * const</code> == <code>int const * const</code></li>\n\
    </ul>\n<p>If you want to go really crazy you can do things like this:</p>\n<ul>\n\
    <li><code>int **</code> - pointer to pointer to int</li>\n<li><code>int ** const</code>\
    \ - a const pointer to a pointer to an int</li>\n<li><code>int * const *</code>\
    \ - a pointer to a const pointer to an int</li>\n<li><code>int const **</code>\
    \ - a pointer to a pointer to a const int</li>\n<li><code>int * const * const</code>\
    \ - a const pointer to a const pointer to an int</li>\n<li>...</li>\n</ul>\n<p>And\
    \ to make sure we are clear on the meaning of const</p>\n<pre><code>const int*\
    \ foo;\nint *const bar; //note, you actually need to set the pointer \n      \
    \          //here because you can't change it later ;)\n</code></pre>\n<p><code>foo</code>\
    \ is a variable pointer to a constant integer. This lets you change what you point\
    \ to but not the value that you point to. Most often this is seen with C-style\
    \ strings where you have a pointer to a <code>const char</code>. You may change\
    \ which string you point to but you can't change the content of these strings.\
    \ This is important when the string itself is in the data segment of a program\
    \ and shouldn't be changed.</p>\n<p><code>bar</code> is a constant or fixed pointer\
    \ to a value that can be changed. This is like a reference without the extra syntactic\
    \ sugar. Because of this fact, usually you would use a reference where you would\
    \ use a <code>T* const</code> pointer unless you need to allow <code>NULL</code>\
    \ pointers.</p>\n</div>"
- - What is the difference between const int*, const int * const, and int const *?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>For those who don't know about\
    \ Clockwise/Spiral Rule:\nStart from the name of the variable, move clockwisely\
    \ (in this case, move backward) to the next <strong>pointer</strong> or <strong>type</strong>.\
    \ Repeat until expression ends.</p>\n<p>here is a demo:</p>\n<p><img alt=\"pointer\
    \ to int\" src=\"https://i.stack.imgur.com/sT6ng.png\"/></p>\n<p><img alt=\"const\
    \ pointer to int const\" src=\"https://i.stack.imgur.com/Zt0G2.png\"/></p>\n<p><img\
    \ alt=\"pointer to int const\" src=\"https://i.stack.imgur.com/kXH8P.png\"/></p>\n\
    <p><img alt=\"pointer to const int\" src=\"https://i.stack.imgur.com/UeqZO.png\"\
    /></p>\n<p><img alt=\"const pointer to int\" src=\"https://i.stack.imgur.com/f5ftV.png\"\
    /></p>\n</div>"
- - What is the difference between const int*, const int * const, and int const *?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>I think everything is answered\
    \ here already, but I just want to add that you should beware of <code>typedef</code>s!\
    \ They're NOT just text replacements.</p>\n<p>For example:</p>\n<pre><code>typedef\
    \ char *ASTRING;\nconst ASTRING astring;\n</code></pre>\n<p>The type of <code>astring</code>\
    \ is <code>char * const</code>, not <code>const char *</code>. This is one reason\
    \ I always tend to put <code>const</code> to the right of the type, and never\
    \ at the start.</p>\n</div>"
- - Why do we need virtual functions in C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Here is how I understood not\
    \ just what <a href=\"https://www.ibm.com/support/knowledgecenter/en/SSLTBW_2.3.0/com.ibm.zos.v2r3.cbclx01/cplr139.htm\"\
    \ rel=\"noreferrer\"><code>virtual</code></a> functions are, but why they're required:</p>\n\
    <p>Let's say you have these two classes:</p>\n<pre><code>class Animal\n{\n   \
    \ public:\n        void eat() { std::cout &lt;&lt; \"I'm eating generic food.\"\
    ; }\n};\n\nclass Cat : public Animal\n{\n    public:\n        void eat() { std::cout\
    \ &lt;&lt; \"I'm eating a rat.\"; }\n};\n</code></pre>\n<p>In your main function:</p>\n\
    <pre><code>Animal *animal = new Animal;\nCat *cat = new Cat;\n\nanimal-&gt;eat();\
    \ // Outputs: \"I'm eating generic food.\"\ncat-&gt;eat();    // Outputs: \"I'm\
    \ eating a rat.\"\n</code></pre>\n<p>So far so good, right? Animals eat generic\
    \ food, cats eat rats, all without <code>virtual</code>.</p>\n<p>Let's change\
    \ it a little now so that <code>eat()</code> is called via an intermediate function\
    \ (a trivial function just for this example):</p>\n<pre><code>// This can go at\
    \ the top of the main.cpp file\nvoid func(Animal *xyz) { xyz-&gt;eat(); }\n</code></pre>\n\
    <p>Now our main function is:</p>\n<pre><code>Animal *animal = new Animal;\nCat\
    \ *cat = new Cat;\n\nfunc(animal); // Outputs: \"I'm eating generic food.\"\n\
    func(cat);    // Outputs: \"I'm eating generic food.\"\n</code></pre>\n<p>Uh oh...\
    \ we passed a Cat into <code>func()</code>, but it won't eat rats. Should you\
    \ overload <code>func()</code> so it takes a <code>Cat*</code>? If you have to\
    \ derive more animals from Animal they would all need their own <code>func()</code>.</p>\n\
    <p>The solution is to make <code>eat()</code> from the <code>Animal</code> class\
    \ a virtual function:</p>\n<pre><code>class Animal\n{\n    public:\n        virtual\
    \ void eat() { std::cout &lt;&lt; \"I'm eating generic food.\"; }\n};\n\nclass\
    \ Cat : public Animal\n{\n    public:\n        void eat() { std::cout &lt;&lt;\
    \ \"I'm eating a rat.\"; }\n};\n</code></pre>\n<p>Main:</p>\n<pre><code>func(animal);\
    \ // Outputs: \"I'm eating generic food.\"\nfunc(cat);    // Outputs: \"I'm eating\
    \ a rat.\"\n</code></pre>\n<p>Done.</p>\n</div>"
- - Why do we need virtual functions in C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Without \"virtual\" you get \"\
    early binding\". Which implementation of the method is used gets decided at compile\
    \ time based on the type of the pointer that you call through.</p>\n<p>With \"\
    virtual\" you get \"late binding\". Which implementation of the method is used\
    \ gets decided at run time based on the type of the pointed-to object - what it\
    \ was originally constructed as. This is not necessarily what you'd think based\
    \ on the type of the pointer that points to that object.</p>\n<pre><code>class\
    \ Base\n{\n  public:\n            void Method1 ()  {  std::cout &lt;&lt; \"Base::Method1\"\
    \ &lt;&lt; std::endl;  }\n    virtual void Method2 ()  {  std::cout &lt;&lt; \"\
    Base::Method2\" &lt;&lt; std::endl;  }\n};\n\nclass Derived : public Base\n{\n\
    \  public:\n    void Method1 ()  {  std::cout &lt;&lt; \"Derived::Method1\" &lt;&lt;\
    \ std::endl;  }\n    void Method2 ()  {  std::cout &lt;&lt; \"Derived::Method2\"\
    \ &lt;&lt; std::endl;  }\n};\n\nBase* obj = new Derived ();\n  //  Note - constructed\
    \ as Derived, but pointer stored as Base*\n\nobj-&gt;Method1 ();  //  Prints \"\
    Base::Method1\"\nobj-&gt;Method2 ();  //  Prints \"Derived::Method2\"\n</code></pre>\n\
    <p><strong>EDIT</strong> - see <a href=\"https://stackoverflow.com/questions/10580/what-are-early-and-late-binding\"\
    >this question</a>.</p>\n<p>Also - <a href=\"http://www.learncpp.com/cpp-tutorial/124-early-binding-and-late-binding/\"\
    \ rel=\"noreferrer\">this tutorial</a> covers early and late binding in C++.</p>\n\
    </div>"
- - Why do we need virtual functions in C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>You need at least 1 level of\
    \ inheritance and a downcast to demonstrate it. Here is a very simple  example:</p>\n\
    <pre><code>class Animal\n{        \n    public: \n      // turn the following\
    \ virtual modifier on/off to see what happens\n      //virtual   \n      std::string\
    \ Says() { return \"?\"; }  \n};\n\nclass Dog: public Animal\n{\n    public: std::string\
    \ Says() { return \"Woof\"; }\n};\n\nvoid test()\n{\n    Dog* d = new Dog();\n\
    \    Animal* a = d;       // refer to Dog instance with Animal pointer\n\n   \
    \ cout &lt;&lt; d-&gt;Says();   // always Woof\n    cout &lt;&lt; a-&gt;Says();\
    \   // Woof or ?, depends on virtual\n}\n</code></pre>\n</div>"
- - Where and why do I have to put the “template” and “typename” keywords?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>In order to parse a C++ program,\
    \ the compiler needs to know whether certain names are types or not. The following\
    \ example demonstrates that:</p>\n<pre><code>t * f;\n</code></pre>\n<p>How should\
    \ this be parsed? For many languages a compiler doesn't need to know the meaning\
    \ of a name in order to parse and basically know what action a line of code does.\
    \ In C++, the above however can yield vastly different interpretations depending\
    \ on what <code>t</code> means. If it's a type, then it will be a declaration\
    \ of a pointer <code>f</code>. However if it's not a type, it will be a multiplication.\
    \ So the C++ Standard says at paragraph (3/7):</p>\n<blockquote>\n<p>Some names\
    \ denote types or templates. In general, whenever a name is encountered it is\
    \ necessary to determine whether that name denotes one of these entities before\
    \ continuing to parse the program that contains it. The process that determines\
    \ this is called name lookup.</p>\n</blockquote>\n<p>How will the compiler find\
    \ out what a name <code>t::x</code> refers to, if <code>t</code> refers to a template\
    \ type parameter? <code>x</code> could be a static int data member that could\
    \ be multiplied or could equally well be a nested class or typedef that could\
    \ yield to a declaration. If a name has this property - that it can't be looked\
    \ up until the actual template arguments are known - then it's called a <em>dependent\
    \ name</em> (it \"depends\" on the template parameters). </p>\n<p>You might recommend\
    \ to just wait till the user instantiates the template: </p>\n<blockquote>\n<p><em>Let's\
    \ wait until the user instantiates the template, and then later find out the real\
    \ meaning of <code>t::x * f;</code>.</em> </p>\n</blockquote>\n<p>This will work\
    \ and actually is allowed by the Standard as a possible implementation approach.\
    \ These compilers basically copy the template's text into an internal buffer,\
    \ and only when an instantiation is needed, they parse the template and possibly\
    \ detect errors in the definition. But instead of bothering the template's users\
    \ (poor colleagues!) with errors made by a template's author, other implementations\
    \ choose to check templates early on and give errors in the definition as soon\
    \ as possible, before an instantiation even takes place. </p>\n<p>So there has\
    \ to be a way to tell the compiler that certain names are types and that certain\
    \ names aren't. </p>\n<h2>The \"typename\" keyword</h2>\n<p>The answer is: <em>We</em>\
    \ decide how the compiler should parse this. If <code>t::x</code> is a dependent\
    \ name, then we need to prefix it by <code>typename</code> to tell the compiler\
    \ to parse it in a certain way. The Standard says at (14.6/2):</p>\n<blockquote>\n\
    <p>A name used in a template declaration or definition and that is dependent on\
    \ a template-parameter is\n  assumed not to name a type unless the applicable\
    \ name lookup finds a type name or the name is qualified\n  by the keyword typename.\
    \ </p>\n</blockquote>\n<p>There are many names for which <code>typename</code>\
    \ is not necessary, because the compiler can, with the applicable name lookup\
    \ in the template definition, figure out how to parse a construct itself - for\
    \ example with <code>T *f;</code>, when <code>T</code> is a type template parameter.\
    \ But for <code>t::x * f;</code> to be a declaration, it must be written as <code>typename\
    \ t::x *f;</code>. If you omit the keyword and the name is taken to be a non-type,\
    \ but when instantiation finds it denotes a type, the usual error messages are\
    \ emitted by the compiler. Sometimes, the error consequently is given at definition\
    \ time:</p>\n<pre><code>// t::x is taken as non-type, but as an expression the\
    \ following misses an\n// operator between the two names or a semicolon separating\
    \ them.\nt::x f;\n</code></pre>\n<p><em>The syntax allows <code>typename</code>\
    \ only before qualified names</em> - it is therefor taken as granted that unqualified\
    \ names are always known to refer to types if they do so.</p>\n<p>A similar gotcha\
    \ exists for names that denote templates, as hinted at by the introductory text.</p>\n\
    <h2>The \"template\" keyword</h2>\n<p>Remember the initial quote above and how\
    \ the Standard requires special handling for templates as well? Let's take the\
    \ following innocent-looking example: </p>\n<pre><code>boost::function&lt; int()\
    \ &gt; f;\n</code></pre>\n<p>It might look obvious to a human reader. Not so for\
    \ the compiler. Imagine the following arbitrary definition of <code>boost::function</code>\
    \ and <code>f</code>:</p>\n<pre><code>namespace boost { int function = 0; }\n\
    int main() { \n  int f = 0;\n  boost::function&lt; int() &gt; f; \n}\n</code></pre>\n\
    <p>That's actually a valid <em>expression</em>! It uses the less-than operator\
    \ to compare <code>boost::function</code> against zero (<code>int()</code>), and\
    \ then uses the greater-than operator to compare the resulting <code>bool</code>\
    \ against <code>f</code>. However as you might well know, <code>boost::function</code>\
    \ <a href=\"http://www.boost.org/doc/libs/1_54_0/doc/html/function.html\" rel=\"\
    noreferrer\">in real life</a> is a template, so the compiler knows (14.2/3):</p>\n\
    <blockquote>\n<p>After name lookup (3.4) finds that a name is a template-name,\
    \ if this name is followed by a &lt;, the &lt; is\n  always taken as the beginning\
    \ of a template-argument-list and never as a name followed by the less-than\n\
    \  operator.</p>\n</blockquote>\n<p>Now we are back to the same problem as with\
    \ <code>typename</code>. What if we can't know yet whether the name is a template\
    \ when parsing the code? We will need to insert <code>template</code> immediately\
    \ before the template name, as specified by <code>14.2/4</code>. This looks like:</p>\n\
    <pre><code>t::template f&lt;int&gt;(); // call a function template\n</code></pre>\n\
    <p>Template names can not only occur after a <code>::</code> but also after a\
    \ <code>-&gt;</code> or <code>.</code> in a class member access. You need to insert\
    \ the keyword there too:</p>\n<pre><code>this-&gt;template f&lt;int&gt;(); //\
    \ call a function template\n</code></pre>\n<hr/>\n<h2>Dependencies</h2>\n<p>For\
    \ the people that have thick Standardese books on their shelf and that want to\
    \ know what exactly I was talking about, I'll talk a bit about how this is specified\
    \ in the Standard.</p>\n<p>In template declarations some constructs have different\
    \ meanings depending on what template arguments you use to instantiate the template:\
    \ Expressions may have different types or values, variables may have different\
    \ types or function calls might end up calling different functions. Such constructs\
    \ are generally said to <em>depend</em> on template parameters.</p>\n<p>The Standard\
    \ defines precisely the rules by whether a construct is dependent or not. It separates\
    \ them into logically different groups: One catches types, another catches expressions.\
    \ Expressions may depend by their value and/or their type. So we have, with typical\
    \ examples appended:</p>\n<ul>\n<li>Dependent types (e.g: a type template parameter\
    \ <code>T</code>)</li>\n<li>Value-dependent expressions (e.g: a non-type template\
    \ parameter <code>N</code>)</li>\n<li>Type-dependent expressions (e.g: a cast\
    \ to a type template parameter <code>(T)0</code>)</li>\n</ul>\n<p>Most of the\
    \ rules are intuitive and are built up recursively: For example, a type constructed\
    \ as <code>T[N]</code> is a dependent type if <code>N</code> is a value-dependent\
    \ expression or <code>T</code> is a dependent type. The details of this can be\
    \ read in section <code>(14.6.2/1</code>) for dependent types, <code>(14.6.2.2)</code>\
    \ for type-dependent expressions and <code>(14.6.2.3)</code> for value-dependent\
    \ expressions. </p>\n<h3>Dependent names</h3>\n<p>The Standard is a bit unclear\
    \ about what <em>exactly</em> is a <em>dependent name</em>. On a simple read (you\
    \ know, the principle of least surprise), all it defines as a <em>dependent name</em>\
    \ is the special case for function names below. But since clearly <code>T::x</code>\
    \ also needs to be looked up in the instantiation context, it also needs to be\
    \ a dependent name (fortunately, as of mid C++14 the committee has started to\
    \ look into how to fix this confusing definition). </p>\n<p>To avoid this problem,\
    \ I have resorted to a simple interpretation of the Standard text. Of all the\
    \ constructs that denote dependent types or expressions, a subset of them represent\
    \ names. Those names are therefore \"dependent names\". A name can take different\
    \ forms - the Standard says:</p>\n<blockquote>\n<p>A name is a use of an identifier\
    \ (2.11), operator-function-id (13.5), conversion-function-id (12.3.2), or template-id\
    \ (14.2) that denotes an entity or label (6.6.4, 6.1)</p>\n</blockquote>\n<p>An\
    \ identifier is just a plain sequence of characters / digits, while the next two\
    \ are the <code>operator +</code> and <code>operator type</code> form. The last\
    \ form is <code>template-name &lt;argument list&gt;</code>. All these are names,\
    \ and by conventional use in the Standard, a name can also include qualifiers\
    \ that say what namespace or class a name should be looked up in.</p>\n<p>A value\
    \ dependent expression <code>1 + N</code> is not a name, but <code>N</code> is.\
    \ The subset of all dependent constructs that are names is called <em>dependent\
    \ name</em>. Function names, however, may have different meaning in different\
    \ instantiations of a template, but unfortunately are not caught by this general\
    \ rule. </p>\n<h3>Dependent function names</h3>\n<p>Not primarily a concern of\
    \ this article, but still worth mentioning: Function names are an exception that\
    \ are handled separately. An identifier function name is dependent not by itself,\
    \ but by the type dependent argument expressions used in a call. In the example\
    \ <code>f((T)0)</code>, <code>f</code> is a dependent name. In the Standard, this\
    \ is specified at <code>(14.6.2/1)</code>.</p>\n<h2>Additional notes and examples</h2>\n\
    <p>In enough cases we need both of <code>typename</code> and <code>template</code>.\
    \ Your code should look like the following</p>\n<pre><code>template &lt;typename\
    \ T, typename Tail&gt;\nstruct UnionNode : public Tail {\n    // ...\n    template&lt;typename\
    \ U&gt; struct inUnion {\n        typedef typename Tail::template inUnion&lt;U&gt;\
    \ dummy;\n    };\n    // ...\n};\n</code></pre>\n<p>The keyword <code>template</code>\
    \ doesn't always have to appear in the last part of a name. It can appear in the\
    \ middle before a class name that's used as a scope, like in the following example</p>\n\
    <pre><code>typename t::template iterator&lt;int&gt;::value_type v;\n</code></pre>\n\
    <p>In some cases, the keywords are forbidden, as detailed below</p>\n<ul>\n<li><p>On\
    \ the name of a dependent base class you are not allowed to write <code>typename</code>.\
    \ It's assumed that the name given is a class type name. This is true for both\
    \ names in the base-class list and the constructor initializer list:</p>\n<pre><code>\
    \ template &lt;typename T&gt;\n struct derive_from_Has_type : /* typename */ SomeBase&lt;T&gt;::type\
    \ \n { };\n</code></pre></li>\n<li><p>In using-declarations it's not possible\
    \ to use <code>template</code> after the last <code>::</code>, and the C++ committee\
    \ <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#109\"\
    \ rel=\"noreferrer\">said</a> not to work on a solution. </p>\n<pre><code> template\
    \ &lt;typename T&gt;\n struct derive_from_Has_type : SomeBase&lt;T&gt; {\n   \
    \ using SomeBase&lt;T&gt;::template type; // error\n    using typename SomeBase&lt;T&gt;::type;\
    \ // typename *is* allowed\n };\n</code></pre></li>\n</ul>\n</div>"
- - Where and why do I have to put the “template” and “typename” keywords?
  - "<div class=\"post-text\" itemprop=\"text\">\n<h2>C++11</h2>\n<h3>Problem</h3>\n\
    <p>While the rules in C++03 about when you need <code>typename</code> and <code>template</code>\
    \ are largely reasonable, there is one annoying disadvantage of its formulation</p>\n\
    <pre><code>template&lt;typename T&gt;\nstruct A {\n  typedef int result_type;\n\
    \n  void f() {\n    // error, \"this\" is dependent, \"template\" keyword needed\n\
    \    this-&gt;g&lt;float&gt;();\n\n    // OK\n    g&lt;float&gt;();\n\n    //\
    \ error, \"A&lt;T&gt;\" is dependent, \"typename\" keyword needed\n    A&lt;T&gt;::result_type\
    \ n1;\n\n    // OK\n    result_type n2; \n  }\n\n  template&lt;typename U&gt;\n\
    \  void g();\n};\n</code></pre>\n<p>As can be seen, we need the disambiguation\
    \ keyword even if the compiler could perfectly figure out itself that <code>A::result_type</code>\
    \ can only be <code>int</code> (and is hence a type), and <code>this-&gt;g</code>\
    \ can only be the member template <code>g</code> declared later (even if <code>A</code>\
    \ is explicitly specialized somewhere, that would not affect the code within that\
    \ template, so its meaning cannot be affected by a later specialization of <code>A</code>!).\
    \ </p>\n<h3>Current instantiation</h3>\n<p>To improve the situation, in C++11\
    \ the language tracks when a type refers to the enclosing template. To know that,\
    \ the type must have been formed by using a certain form of name, which is its\
    \ own name (in the above, <code>A</code>, <code>A&lt;T&gt;</code>, <code>::A&lt;T&gt;</code>).\
    \ A type referenced by such a name is known to be  the <em>current instantiation</em>.\
    \ There may be multiple types that are all the current instantiation if the type\
    \ from which the name is formed is a member/nested class (then, <code>A::NestedClass</code>\
    \ and <code>A</code> are both current instantiations). </p>\n<p>Based on this\
    \ notion, the language says that <code>CurrentInstantiation::Foo</code>, <code>Foo</code>\
    \ and <code>CurrentInstantiationTyped-&gt;Foo</code> (such as <code>A *a = this;\
    \ a-&gt;Foo</code>) are all <em>member of the current instantiation</em> <strong>if</strong>\
    \ they are found to be members of a class that is the current instantiation or\
    \ one of its non-dependent base classes (by just doing the name lookup immediately).\
    \ </p>\n<p>The keywords <code>typename</code> and <code>template</code> are now\
    \ not required anymore if the qualifier is a member of the current instantiation.\
    \ A keypoint here to remember is that <code>A&lt;T&gt;</code> is <em>still</em>\
    \ a type-dependent name (after all <code>T</code> is also type dependent). But\
    \ <code>A&lt;T&gt;::result_type</code> is known to be a type - the compiler will\
    \ \"magically\" look into this kind of dependent types to figure this out. </p>\n\
    <pre><code>struct B {\n  typedef int result_type;\n};\n\ntemplate&lt;typename\
    \ T&gt;\nstruct C { }; // could be specialized!\n\ntemplate&lt;typename T&gt;\n\
    struct D : B, C&lt;T&gt; {\n  void f() {\n    // OK, member of current instantiation!\n\
    \    // A::result_type is not dependent: int\n    D::result_type r1;\n\n    //\
    \ error, not a member of the current instantiation\n    D::questionable_type r2;\n\
    \n    // OK for now - relying on C&lt;T&gt; to provide it\n    // But not a member\
    \ of the current instantiation\n    typename D::questionable_type r3;        \n\
    \  }\n};\n</code></pre>\n<p>That's impressive, but can we do better? The language\
    \ even goes further and <em>requires</em> that an implementation again looks up\
    \ <code>D::result_type</code> when instantiating <code>D::f</code> (even if it\
    \ found its meaning already at definition time). When now the lookup result differs\
    \ or results in ambiguity, the program is ill-formed and a diagnostic must be\
    \ given. Imagine what happens if we defined <code>C</code> like this</p>\n<pre><code>template&lt;&gt;\n\
    struct C&lt;int&gt; {\n  typedef bool result_type;\n  typedef int questionable_type;\n\
    };\n</code></pre>\n<p>A compiler is required to catch the error when instantiating\
    \ <code>D&lt;int&gt;::f</code>. So you get the best of the two worlds: \"Delayed\"\
    \ lookup protecting you if you could get in trouble with dependent base classes,\
    \ and also \"Immediate\" lookup that frees you from <code>typename</code> and\
    \ <code>template</code>. </p>\n<h3>Unknown specializations</h3>\n<p>In the code\
    \ of <code>D</code>, the name <code>typename D::questionable_type</code> is not\
    \ a member of the current instantiation. Instead the language marks it as a <em>member\
    \ of an unknown specialization</em>. In particular, this is always the case when\
    \ you are doing <code>DependentTypeName::Foo</code> or <code>DependentTypedName-&gt;Foo</code>\
    \ and either the dependent type is <em>not</em> the current instantiation (in\
    \ which case the compiler can give up and say \"we will look later what <code>Foo</code>\
    \ is) or it <em>is</em> the current instantiation and the name was not found in\
    \ it or its non-dependent base classes and there are also dependent base classes.\
    \ </p>\n<p>Imagine what happens if we had a member function <code>h</code> within\
    \ the above defined <code>A</code> class template</p>\n<pre><code>void h() {\n\
    \  typename A&lt;T&gt;::questionable_type x;\n}\n</code></pre>\n<p>In C++03, the\
    \ language allowed to catch this error because there could never be a valid way\
    \ to instantiate <code>A&lt;T&gt;::h</code> (whatever argument you give to <code>T</code>).\
    \ In C++11, the language now has a further check to give more reason for compilers\
    \ to implement this rule. Since <code>A</code> has no dependent base classes,\
    \ and <code>A</code> declares no member <code>questionable_type</code>, the name\
    \ <code>A&lt;T&gt;::questionable_type</code> is <em>neither</em> a member of the\
    \ current instantiation <em>nor</em> a member of an unknown specialization. In\
    \ that case, there should be no way that that code could validly compile at instantiation\
    \ time, so the language forbids a name where the qualifier is the current instantiation\
    \ to be neither a member of an unknown specialization nor a member of the current\
    \ instantiation (however, this violation is still not required to be diagnosed).</p>\n\
    <h3>Examples and trivia</h3>\n<p>You can try this knowledge on <a href=\"https://stackoverflow.com/a/14005063/34509\"\
    >this answer</a> and see whether the above definitions make sense for you on a\
    \ real-world example (they are repeated slightly less detailed in that answer).\
    \  </p>\n<p>The C++11 rules make the following valid C++03 code ill-formed (which\
    \ was not intended by the C++ committee, but will probably not be fixed)</p>\n\
    <pre><code>struct B { void f(); };\nstruct A : virtual B { void f(); };\n\ntemplate&lt;typename\
    \ T&gt;\nstruct C : virtual B, T {\n  void g() { this-&gt;f(); }\n};\n\nint main()\
    \ { \n  C&lt;A&gt; c; c.g(); \n}\n</code></pre>\n<p>This valid C++03 code would\
    \ bind <code>this-&gt;f</code> to <code>A::f</code> at instantiation time and\
    \ everything is fine. C++11 however immediately binds it to <code>B::f</code>\
    \ and requires a double-check when instantiating, checking whether the lookup\
    \ still matches. However when instantiating <code>C&lt;A&gt;::g</code>, the <a\
    \ href=\"http://en.wikipedia.org/wiki/Dominance_(C%2B%2B)\" rel=\"noreferrer\"\
    >Dominance Rule</a> applies and lookup will find <code>A::f</code> instead.</p>\n\
    </div>"
- - Where and why do I have to put the “template” and “typename” keywords?
  - "<div class=\"post-text\" itemprop=\"text\">\n<blockquote>\n<p><strong>PREFACE</strong></p>\n\
    <p>This post is meant to be an <em>easy-to-read</em> alternative to <a href=\"\
    https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords/17579889#17579889\"\
    >litb's post</a>.</p>\n<p>The underlying purpose is the same; an explanation to\
    \ \"When?\" and \"Why?\" <code>typename</code> and <code>template</code> must\
    \ be applied.</p>\n</blockquote>\n<hr/>\n<h1>What's the purpose of <code>typename</code>\
    \ and <code>template</code>?</h1>\n<p><code>typename</code> and <code>template</code>\
    \ are usable in circumstances other than when declaring a template.</p>\n<p>There\
    \ are certain contexts in <em>C++</em> where the compiler must explicitly be told\
    \ how to treat a name, and all these contexts have one thing in common; they depend\
    \ on at least one <em>template-parameter</em>.</p>\n<p>We refer to such names,\
    \ where there can be an ambiguity in interpretation, as; \"<em>dependent names</em>\"\
    .</p>\n<p>This post will offer an explanation to the relationship between <em>dependent-names</em>,\
    \ and the two keywords.</p>\n<hr/>\n<h2>A SNIPPET SAYS MORE THAN 1000 WORDS</h2>\n\
    <p>Try to explain what is going on in the following <em>function-template</em>,\
    \ either to yourself, a friend, or perhaps your cat; what is happening in the\
    \ statement marked (<em>A</em>)?</p>\n<pre><code>template&lt;class T&gt; void\
    \ f_tmpl () { T::foo * x; /* &lt;-- (A) */ }\n</code></pre>\n<p><sup><br/></sup>\n\
    It might not be as easy as one thinks, more specifically the result of evaluating\
    \ (<em>A</em>) heavily <em>depends</em> on the definition of the type passed as\
    \ template-parameter <code>T</code>.</p>\n<p>Different <code>T</code>s can drastically\
    \ change the semantics involved.</p>\n<pre><code>struct X { typedef int      \
    \ foo;       }; /* (C) --&gt; */ f_tmpl&lt;X&gt; ();\nstruct Y { static  int const\
    \ foo = 123; }; /* (D) --&gt; */ f_tmpl&lt;Y&gt; ();\n</code></pre>\n<p><sup><br/></sup></p>\n\
    <p><strong>The two different scenarios</strong>:</p>\n<ul>\n<li><p>If we instantiate\
    \ the function-template with type <em>X</em>, as in (<em>C</em>), we will have\
    \ a declaration of a <em>pointer-to int</em> named <em>x</em>, but;</p></li>\n\
    <li><p>if we instantiate the template with type <em>Y</em>, as in (<em>D</em>),\
    \ (<em>A</em>) would instead consist of an expression that calculates the product\
    \ of <em>123</em> multiplied with some already declared variable <em>x</em>.</p></li>\n\
    </ul>\n<p><br/></p>\n<hr/>\n<h2>THE RATIONALE</h2>\n<p>The C++ Standard cares\
    \ about our safety and well-being, at least in this case.</p>\n<p>To prevent an\
    \ implementation from potentially suffering from nasty surprises, the Standard\
    \ mandates that we sort out the ambiguity of a <em>dependent-name</em> by <em>explicitly</em>\
    \ stating the intent anywhere we'd like to treat the name as either a <em>type-name</em>,\
    \ or a <em>template-id</em>.</p>\n<p>If nothing is stated, the <em>dependent-name</em>\
    \ will be considered to be either a variable, or a function.</p>\n<p><br/></p>\n\
    <hr/>\n<h2>HOW TO HANDLE <em>DEPENDENT NAMES</em>?</h2>\n<p>If this was a Hollywood\
    \ film, <em>dependent-names</em> would be the disease that spreads through body\
    \ contact, instantly affects its host to make it confused. Confusion that could,\
    \ possibly, lead to an ill-formed perso-, erhm.. program.</p>\n<p>A <em>dependent-name</em>\
    \ is <strong>any</strong> name that directly, or indirectly, depends on a <em>template-parameter</em>.\n\
    <sup><br/><br/></sup></p>\n<pre><code>template&lt;class T&gt; void g_tmpl () {\n\
    \   SomeTrait&lt;T&gt;::type                   foo; // (E), ill-formed\n   SomeTrait&lt;T&gt;::NestedTrait&lt;int&gt;::type\
    \ bar; // (F), ill-formed\n   foo.data&lt;int&gt; ();                        \
    \ // (G), ill-formed    \n}\n</code></pre>\n<p>We have four <em>dependent</em>\
    \ names in the above snippet:</p>\n<ul>\n<li><strong>E</strong>)\n\n<ul>\n<li><strong>\"\
    type\"</strong> depends on the instantiation of <code>SomeTrait&lt;T&gt;</code>,\
    \ which include <code>T</code>, and;</li>\n</ul></li>\n<li><strong>F</strong>)\n\
    \n<ul>\n<li><strong>\"NestedTrait\"</strong>, which is a <em>template-id</em>,\
    \ depends on <code>SomeTrait&lt;T&gt;</code>, and;</li>\n<li><strong>\"type\"\
    </strong> at the end of (<em>F</em>) depends on <em>NestedTrait</em>, which depends\
    \ on <code>SomeTrait&lt;T&gt;</code>, and;</li>\n</ul></li>\n<li><strong>G</strong>)\n\
    \n<ul>\n<li><strong>\"data\"</strong>, which looks like a <em>member-function\
    \ template</em>, is indirectly a <em>dependent-name</em> since the type of <em>foo</em>\
    \ depends on the instantiation of <code>SomeTrait&lt;T&gt;</code>.</li>\n</ul></li>\n\
    </ul>\n<p>Neither of statement (<em>E</em>), (<em>F</em>) or (<em>G</em>) is valid\
    \ if the compiler would interpret the <em>dependent-names</em> as variables/functions\
    \ (which as stated earlier is what happens if we don't explicitly say otherwise).\n\
    <sup><br/><br/></sup></p>\n<h3>THE SOLUTION</h3>\n<p>To make <code>g_tmpl</code>\
    \ have a valid definition we must explicitly tell the compiler that we expect\
    \ a type in (<em>E</em>), a <em>template-id</em> and a <em>type</em> in (<em>F</em>),\
    \ and a <em>template-id</em> in (<em>G</em>).</p>\n<pre><code>template&lt;class\
    \ T&gt; void g_tmpl () {\n   typename SomeTrait&lt;T&gt;::type foo;          \
    \                  // (G), legal\n   typename SomeTrait&lt;T&gt;::template NestedTrait&lt;int&gt;::type\
    \ bar; // (H), legal\n   foo.template data&lt;int&gt; ();                    \
    \              // (I), legal\n}\n</code></pre>\n<p>Every time a <em>name</em>\
    \ denotes a type, <strong>all</strong> <em>names</em> involved must be either\
    \ <em>type-names</em> or <em>namespaces</em>, with this in mind it's quite easy\
    \ to see that we apply <code>typename</code> at the beginning of our fully <em>qualified\
    \ name</em>.</p>\n<p><code>template</code> however, is different in this regard,\
    \ since there's no way of coming to a conclusion such as; <em>\"oh, this is a\
    \ template, than this other thing must also be a template\"</em>. This means that\
    \ we apply <code>template</code> directly in front of any <em>name</em> that we'd\
    \ like to treat as such.</p>\n<p><br/></p>\n<hr/>\n<h2>CAN I JUST STICK THE <em>KEYWORDS</em>\
    \ IN FRONT OF ANY NAME?</h2>\n<blockquote>\n<p>\"<em>Can I just stick <code>typename</code>\
    \ and <code>template</code> in front of any name? I don't want to worry about\
    \ the context in which they appear...</em>\" - <code>Some C++ Developer</code></p>\n\
    </blockquote>\n<p>The rules in the Standard states that you may apply the keywords\
    \ as long as you are dealing with a <em>qualified-name</em> (<em>K</em>), but\
    \ if the name isn't <em>qualified</em> the application is ill-formed (<em>L</em>).</p>\n\
    <pre><code>namespace N {\n  template&lt;class T&gt;\n  struct X { };\n}\n</code></pre>\n\
    <p><sup></sup></p>\n<pre><code>         N::         X&lt;int&gt; a; // ...  legal\n\
    typename N::template X&lt;int&gt; b; // (K), legal\ntypename template    X&lt;int&gt;\
    \ c; // (L), ill-formed\n</code></pre>\n<p><sup><strong>Note</strong>: Applying\
    \ <code>typename</code> or <code>template</code> in a context where it is not\
    \ required is not considered good practice; just because you can do something,\
    \ doesn't mean that you should.</sup></p>\n<p><br/></p>\n<p>Additionally there\
    \ are contexts where <code>typename</code> and <code>template</code> are <strong>explicitly</strong>\
    \ disallowed:</p>\n<ul>\n<li><p><strong>When specifying the bases of which a class\
    \ inherits</strong></p>\n<p>Every name written in a derived class's <em>base-specifier-list</em>\
    \ is already treated as a <em>type-name</em>, explicitly specifying <code>typename</code>\
    \ is both ill-formed, and redundant.</p>\n<pre><code>                   // .-------\
    \ the base-specifier-list\n template&lt;class T&gt; // v\n struct Derived    \
    \  : typename SomeTrait&lt;T&gt;::type /* &lt;- ill-formed */ {\n   ...\n };\n\
    </code></pre>\n<p><br/></p></li>\n<li><p><strong>When the <em>template-id</em>\
    \ is the one being referred to in a derived class's <em>using-directive</em></strong></p>\n\
    <pre><code> struct Base {\n   template&lt;class T&gt;\n   struct type { };\n };\n\
    \n struct Derived : Base {\n   using Base::template type; // ill-formed\n   using\
    \ Base::type;          // legal\n };\n</code></pre></li>\n</ul>\n</div>"
- - Undefined behavior and sequence points
  - "<div class=\"post-text\" itemprop=\"text\">\n<h3>C++98 and C++03</h3>\n<p>This\
    \ answer is for the older versions of the C++ standard.  The C++11 and C++14 versions\
    \ of the standard do not formally contain 'sequence points'; operations are 'sequenced\
    \ before' or 'unsequenced' or 'indeterminately sequenced' instead.  The net effect\
    \ is essentially the same, but the terminology is different.</p>\n<hr/>\n<p><strong>Disclaimer</strong>\
    \ : Okay. This answer is a bit long. So have patience while reading it. If you\
    \ already know these things, reading them again won't make you crazy. </p>\n<p><strong>Pre-requisites</strong>\
    \ : An elementary knowledge of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/\"\
    \ rel=\"noreferrer\">C++ Standard</a> </p>\n<hr/>\n<h2>What are Sequence Points?</h2>\n\
    <p>The Standard says </p>\n<blockquote>\n<p>At  certain specified points in the\
    \ execution sequence called <strong>sequence points</strong>, all <em>side effects</em>\
    \ of previous evaluations \n  shall be complete and no <em>side effects</em> of\
    \ subsequent evaluations shall have taken place. (§1.9/7)</p>\n</blockquote>\n\
    <h2>Side effects? What are side effects?</h2>\n<p>Evaluation  of  an  expression\
    \ produces something and if in addition there is a change in the state of the\
    \ execution environment it is said that the expression (its evaluation) has some\
    \ side effect(s).</p>\n<p>For example:</p>\n<pre><code>int x = y++; //where y\
    \ is also an int\n</code></pre>\n<p>In addition to the initialization operation\
    \ the value of <code>y</code> gets changed due to the side effect of <code>++</code>\
    \ operator. </p>\n<p>So far so good. Moving on to sequence points. An alternation\
    \ definition of seq-points given by the comp.lang.c author <code>Steve Summit</code>:</p>\n\
    <blockquote>\n<p>Sequence point is a point in time at which the dust has settled\
    \ and all side effects which have been seen so far are guaranteed to be complete.</p>\n\
    </blockquote>\n<hr/>\n<h2>What are the common sequence points listed in the C++\
    \ Standard ?</h2>\n<p>Those are:</p>\n<ul>\n<li>at the end of the evaluation of\
    \ full expression (<code>§1.9/16</code>) (A full-expression is an expression that\
    \ is not a subexpression of another expression.)<sup>1</sup></li>\n</ul>\n<p>Example\
    \ :</p>\n<pre><code>int a = 5; // ; is a sequence point here\n</code></pre>\n\
    <ul>\n<li><p>in the evaluation of each of the following expressions after the\
    \ evaluation of the first expression(<code>§1.9/18</code>) <sup>2</sup></p>\n\
    <ul>\n<li><code>a &amp;&amp; b (§5.14)</code> </li>\n<li><code>a || b (§5.15)</code></li>\n\
    <li><code>a ? b : c (§5.16)</code></li>\n<li><code>a , b (§5.18)</code> (here\
    \ a , b is a comma operator; in <code>func(a,a++)</code> <code>,</code> is not\
    \ a comma operator, it's merely a separator between the arguments <code>a</code>\
    \ and <code>a++</code>. Thus the behaviour is undefined in that case (if <code>a</code>\
    \ is considered to be a primitive type)) <br/></li>\n</ul></li>\n<li><p>at a function\
    \ call (whether or not the function is inline), after the evaluation of all function\
    \ arguments (if any) which \ntakes place before execution of any expressions or\
    \ statements in the function body (<code>§1.9/17</code>).</p></li>\n</ul>\n<p><sub>1\
    \ : Note : the evaluation of a full-expression can include the evaluation of subexpressions\
    \ that are not lexically\npart of the full-expression.  For example, subexpressions\
    \ involved in evaluating default argument expressions (8.3.6) are considered to\
    \ be created in the expression that calls the function, not the expression that\
    \ defines the default argument</sub></p>\n<p><sub>2 : The operators indicated\
    \ are the built-in operators, as described in clause 5.  When one of these operators\
    \ is overloaded (clause 13) in a valid context, thus designating a user-defined\
    \ operator function, the expression designates a function invocation and the operands\
    \ form an argument list, without an implied sequence point between them.</sub></p>\n\
    <hr/>\n<h2>What is Undefined Behaviour?</h2>\n<p>The Standard defines Undefined\
    \ Behaviour in Section <code>§1.3.12</code> as</p>\n<blockquote>\n<p>behaviour,\
    \ such as might arise upon use of an erroneous program construct or erroneous\
    \ data, for which this International Standard imposes <strong>no  requirements\
    \ <sup>3</sup></strong>.</p>\n<p>Undefined  behaviour  may  also  be  expected\
    \  when  this\n  International Standard omits the description of any explicit\
    \ definition of behavior.</p>\n</blockquote>\n<p><sub> 3 : permissible undefined\
    \ behavior ranges from ignoring the situation completely with unpredictable results,\
    \ to behaving during translation or program execution in a documented manner characteristic\
    \ of the environment (with or with-\nout the issuance of a diagnostic message),\
    \ to terminating a translation or execution (with the issuance of a diagnostic\
    \ message).</sub></p>\n<p>In short, undefined behaviour means <strong>anything</strong>\
    \ can happen from daemons flying out of your nose to  your girlfriend getting\
    \ pregnant.</p>\n<hr/>\n<h2>What is the relation between Undefined Behaviour and\
    \ Sequence Points?</h2>\n<p>Before I get into that you must know the difference(s)\
    \ between <a href=\"https://stackoverflow.com/questions/2397984/undefined-unspecified-and-implementation-defined-behavior\"\
    >Undefined Behaviour, Unspecified Behaviour and Implementation Defined Behaviour</a>.</p>\n\
    <p>You must also know that <code>the order of evaluation of operands of individual\
    \ operators and subexpressions of individual expressions, and the order in which\
    \ side effects take place, is unspecified</code>.</p>\n<p>For example:</p>\n<pre><code>int\
    \ x = 5, y = 6;\n\nint z = x++ + y++; //it is unspecified whether x++ or y++ will\
    \ be evaluated first.\n</code></pre>\n<p>Another example <a href=\"https://stackoverflow.com/questions/3457967/what-belongs-in-an-educational-tool-to-demonstrate-the-unwarranted-assumptions-pe/3458842#3458842\"\
    >here</a>.</p>\n<hr/>\n<p>Now the Standard in <code>§5/4</code> says</p>\n<ul>\n\
    <li>1) <strong>Between the previous and next sequence point a scalar object shall\
    \ have its stored value modified at most once by the evaluation of an expression.</strong>\
    \ </li>\n</ul>\n<p>What does it mean?</p>\n<p>Informally it means that between\
    \ two sequence points a variable must not be modified more than once.\nIn an expression\
    \ statement, the <code>next sequence point</code> is usually at the terminating\
    \ semicolon, and the <code>previous sequence point</code> is at the end of the\
    \ previous statement. An expression may also contain intermediate <code>sequence\
    \ points</code>.</p>\n<p>From the above sentence the following expressions invoke\
    \ Undefined Behaviour:</p>\n<pre><code>i++ * ++i;   // UB, i is modified more\
    \ than once btw two SPs\ni = ++i;     // UB, same as above\n++i = 2;     // UB,\
    \ same as above\ni = ++i + 1; // UB, same as above\n++++++i;     // UB, parsed\
    \ as (++(++(++i)))\n\ni = (i, ++i, ++i); // UB, there's no SP between `++i` (right\
    \ most) and assignment to `i` (`i` is modified more than once btw two SPs)\n</code></pre>\n\
    <p>But the following expressions are fine:</p>\n<pre><code>i = (i, ++i, 1) + 1;\
    \ // well defined (AFAIK)\ni = (++i, i++, i);   // well defined \nint j = i;\n\
    j = (++i, i++, j*i); // well defined\n</code></pre>\n<hr/>\n<ul>\n<li>2) <strong>Furthermore,\
    \ the prior value shall be accessed only to determine the value to be stored.</strong></li>\n\
    </ul>\n<p>What does it mean? It means if an object is written to within a full\
    \ expression, any and all accesses to it within the same expression <strong>must\
    \ be directly involved in the computation of the value to be written</strong>.\
    \ </p>\n<p>For example in <code>i = i + 1</code> all the access of <code>i</code>\
    \ (in L.H.S and in R.H.S) are <strong>directly involved in computation</strong>\
    \ of the value to be written. So it is fine.</p>\n<p>This rule effectively constrains\
    \ legal expressions to those in which the accesses demonstrably precede the modification.</p>\n\
    <p>Example 1:</p>\n<pre><code>std::printf(\"%d %d\", i,++i); // invokes Undefined\
    \ Behaviour because of Rule no 2\n</code></pre>\n<p>Example 2:</p>\n<pre><code>a[i]\
    \ = i++ // or a[++i] = i or a[i++] = ++i etc\n</code></pre>\n<p>is disallowed\
    \ because one of the accesses of <code>i</code> (the one in <code>a[i]</code>)\
    \ has nothing to do with the value which ends up being stored in i (which happens\
    \ over in <code>i++</code>), and so there's no good way to define--either for\
    \ our understanding or the compiler's--whether the access should take place before\
    \ or after the incremented value is stored. So the behaviour is undefined.</p>\n\
    <p>Example 3 :</p>\n<pre><code>int x = i + i++ ;// Similar to above\n</code></pre>\n\
    <hr/>\n<p><strong>Follow up answer for C++11 <a href=\"https://stackoverflow.com/questions/4176328/faq-undefined-behavior-and-sequence-points/4183735#4183735\"\
    >here</a>.</strong> </p>\n</div>"
- - Undefined behavior and sequence points
  - "<div class=\"post-text\" itemprop=\"text\">\n<p><strong>This is a follow up to\
    \ my <a href=\"https://stackoverflow.com/questions/4176328/faq-undefined-behavior-and-sequence-points/4176333#4176333\"\
    >previous answer</a> and contains C++11 related material.</strong>.</p>\n<hr/>\n\
    <p><strong>Pre-requisites</strong> : An elementary knowledge of Relations (Mathematics).</p>\n\
    <hr/>\n<h2>Is it true that there are no Sequence Points in C++11?</h2>\n<p><strong>Yes!</strong>\
    \ This is very true. </p>\n<p><strong>Sequence Points</strong> have been replaced\
    \ by <strong>Sequenced Before</strong> and <strong>Sequenced After</strong> (and\
    \ <strong>Unsequenced</strong> and <strong>Indeterminately Sequenced</strong>)\
    \ <a href=\"http://en.wikipedia.org/wiki/Relation_(mathematics)\" rel=\"noreferrer\"\
    >relations</a> in C++11.</p>\n<hr/>\n<h2>What exactly is this 'Sequenced before'\
    \ thing?</h2>\n<p><strong>Sequenced Before</strong><sup>(§1.9/13)</sup> is a relation\
    \ which is: </p>\n<ul>\n<li><a href=\"http://en.wikipedia.org/wiki/Asymmetric_relation\"\
    \ rel=\"noreferrer\"><strong>Asymmetric</strong></a> </li>\n<li><a href=\"http://en.wikipedia.org/wiki/Transitive_relation\"\
    \ rel=\"noreferrer\"><strong>Transitive</strong></a></li>\n</ul>\n<p>between evaluations\
    \ executed by a single <a href=\"http://en.wikipedia.org/wiki/Thread_(computer_science)\"\
    \ rel=\"noreferrer\">thread</a> and induces a <strong>strict partial order</strong><sup>1</sup><br/></p>\n\
    <p>Formally it means given any two evaluations<sup>(See below)</sup> <code>A</code>\
    \ and <code>B</code>, if <code>A</code> is <strong>sequenced before</strong> <code>B</code>,\
    \ then the execution of <code>A</code> <em>shall precede</em> the execution of\
    \ <code>B</code>. If <code>A</code> is not sequenced before <code>B</code> and\
    \ <code>B</code> is not sequenced before <code>A</code>, then <code>A</code> and\
    \ <code>B</code> are <strong>unsequenced</strong> <sup>2</sup>.</p>\n<p>Evaluations\
    \ <code>A</code> and <code>B</code> are <strong>indeterminately sequenced</strong>\
    \ when either <code>A</code> is sequenced before <code>B</code> or <code>B</code>\
    \ is sequenced before <code>A</code>, but it is unspecified which<sup>3</sup>.</p>\n\
    <p><sub>[NOTES]</sub>\n<sub><br/>\n  1 :  A strict partial order is a <a href=\"\
    http://en.wikipedia.org/wiki/Binary_relation\" rel=\"noreferrer\"><strong>binary\
    \ relation</strong></a> <code>\"&lt;\"</code> over a set <code>P</code> which\
    \ is <a href=\"http://en.wikipedia.org/wiki/Asymmetric_relation\" rel=\"noreferrer\"\
    ><code>asymmetric</code></a>, and <a href=\"http://en.wikipedia.org/wiki/Transitive_relation\"\
    \ rel=\"noreferrer\"><code>transitive</code></a>, i.e., for all <code>a</code>,\
    \ <code>b</code>, and <code>c</code> in <code>P</code>, we have that:<br/> </sub>\n\
    <sub>  ........(i). if a &lt; b then ¬ (b &lt; a) (<code>asymmetry</code>);<br/>\n\
    \  ........(ii). if a &lt; b and b &lt; c then a &lt; c (<code>transitivity</code>).<br/>\n\
    \  2 : The execution of <strong>unsequenced evaluations</strong> can <em>overlap</em>.<br/>\n\
    \  3 : <strong>Indeterminately sequenced evaluations</strong> cannot <em>overlap</em>,\
    \ but either could be executed first.\n</sub></p>\n<hr/>\n<h2> What is the meaning\
    \ of the word 'evaluation' in context of C++11? </h2>\n<p>In C++11, evaluation\
    \ of an expression (or a sub-expression) in general includes: </p>\n<ul>\n<li><p><strong>value\
    \ computations</strong> (including determining the identity of an object for <a\
    \ href=\"https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues\"\
    >glvalue evaluation</a> and fetching a value previously assigned to an object\
    \ for <a href=\"https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues\"\
    >prvalue evaluation</a>) and</p></li>\n<li><p>initiation of <strong>side effects</strong>.</p></li>\n\
    </ul>\n<p>Now  (§1.9/14) says:</p>\n<blockquote>\n<p>Every value computation and\
    \ side effect associated with a full-expression is <strong>sequenced before</strong>\
    \ every value computation and side effect associated with the <strong>next full-expression\
    \ to be evaluated</strong>.</p>\n</blockquote>\n<ul>\n<li><p>Trivial example:\
    \ </p>\n<p><code>int x;</code>\n<code>x = 10;</code>\n<code>++x;</code></p>\n\
    <p>Value computation and side effect associated with <code>++x</code> is sequenced\
    \ after the value computation and side effect of <code>x = 10;</code> </p></li>\n\
    </ul>\n<hr/>\n<h2>So there must be some relation between Undefined Behaviour and\
    \ the above-mentioned things, right? </h2>\n<p><strong>Yes!</strong> Right.</p>\n\
    <p>In (§1.9/15) it has been mentioned that </p>\n<blockquote>\n<p>Except where\
    \ noted, evaluations of operands of individual operators and of subexpressions\
    \ of individual expressions are <strong>unsequenced</strong><sup>4</sup>.</p>\n\
    </blockquote>\n<p>For example :</p>\n<pre><code>int main()\n{\n     int num =\
    \ 19 ;\n     num = (num &lt;&lt; 3) + (num &gt;&gt; 3);\n} \n</code></pre>\n<ol>\n\
    <li>Evaluation of operands of <code>+</code> operator are unsequenced relative\
    \ to each other.</li>\n<li>Evaluation of operands of <code>&lt;&lt;</code> and\
    \ <code>&gt;&gt;</code> operators are unsequenced relative to each other.</li>\n\
    </ol>\n<p><sub> 4: In an expression that is evaluated more than once during the\
    \ execution\nof a program, <strong>unsequenced</strong> and <strong>indeterminately\
    \ sequenced</strong> evaluations of its subexpressions need not be performed consistently\
    \ in different evaluations. </sub></p>\n<blockquote>\n<p>(§1.9/15)\n  The value\
    \ computations of the operands of an\n  operator are sequenced before the value\
    \ computation of the result of the operator.</p>\n</blockquote>\n<p>That means\
    \ in <code>x + y</code> the value computation of <code>x</code> and <code>y</code>\
    \ are sequenced before the value computation of <code>(x + y)</code>.</p>\n<p>More\
    \ importantly</p>\n<blockquote>\n<p>(§1.9/15) If a side effect on a scalar object\
    \ is unsequenced relative to either</p>\n<p>(a) <strong>another side effect on\
    \ the same scalar object</strong> </p>\n<p>or </p>\n<p>(b) <strong>a value computation\
    \ using the value of the same scalar object.</strong></p>\n<p>the behaviour is\
    \ <strong>undefined</strong>.</p>\n</blockquote>\n<p>Examples:</p>\n<pre><code>int\
    \ i = 5, v[10] = { };\nvoid  f(int,  int);\n</code></pre>\n<ol>\n<li><code>i =\
    \ i++ * ++i;  // Undefined Behaviour</code></li>\n<li><code>i = ++i + i++;  //\
    \ Undefined Behaviour</code> </li>\n<li><code>i = ++i + ++i;  // Undefined Behaviour</code></li>\n\
    <li><code>i = v[i++];     // Undefined Behaviour</code></li>\n<li><code>i = v[++i]:\
    \     // Well-defined Behavior</code></li>\n<li><code>i = i++ + 1;    // Undefined\
    \ Behaviour</code></li>\n<li><code>i = ++i + 1;    // Well-defined Behaviour</code></li>\n\
    <li><code>++++i;          // Well-defined Behaviour</code></li>\n<li><code>f(i\
    \ = -1, i = -1); // Undefined Behaviour (see below)</code></li>\n</ol>\n<blockquote>\n\
    <p>When calling a function (whether or not the function is inline), every value\
    \ computation and side effect associated with any argument expression, or with\
    \ the postfix expression designating the called function, is sequenced before\
    \ execution of every expression or statement in the body of the called function.\
    \ [<em>Note:</em> <strong>Value computations and side effects associated with\
    \ different argument expressions are unsequenced</strong>.  — <em>end note</em>]</p>\n\
    </blockquote>\n<p>Expressions <code>(5)</code>, <code>(7)</code> and <code>(8)</code>\
    \ do not invoke undefined behaviour. Check out the following answers for a more\
    \ detailed explanation.</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/3690141/multiple-preincrement-operations-on-a-variable-in-cc/3691469#3691469\"\
    >Multiple preincrement operations on a variable in C++0x</a></li>\n<li><a href=\"\
    https://stackoverflow.com/questions/3852768/unsequenced-value-computations-a-k-a-sequence-points/3852774#3852774\"\
    >Unsequenced Value Computations</a></li>\n</ul>\n<hr/>\n<p><strong>Final Note</strong>\
    \ : </p>\n<p>If you find any flaw in the post please leave a comment. Power-users\
    \ (With rep &gt;20000) please do not hesitate to edit the post for correcting\
    \ typos and other mistakes.</p>\n</div>"
- - Undefined behavior and sequence points
  - "<div class=\"post-text\" itemprop=\"text\">\n<p><strong>C++17</strong> (<code>N4659</code>)\
    \ includes a proposal <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0145r3.pdf\"\
    \ rel=\"noreferrer\">Refining Expression Evaluation Order for Idiomatic C++</a>\n\
    which defines a stricter order of expression evaluation.</p>\n<p>In particular,\
    \ the <strong><em>following sentence</em></strong> was added:</p>\n<blockquote>\n\
    <p><strong>8.18 Assignment and compound assignment operators</strong>:<br/>....</p>\n\
    <p>In all cases, the assignment is sequenced after the value\n  computation of\
    \ the right and left operands, and before the value computation of the assignment\
    \ expression.\n  <strong><em>The right operand is sequenced before the left operand.</em></strong></p>\n\
    </blockquote>\n<p>It makes several cases of previously undefined behavior valid,\
    \ including the one in question:</p>\n<pre><code>a[++i] = i;\n</code></pre>\n\
    <p>However several other similar cases still lead to undefined behavior.</p>\n\
    <p>In <code>N4140</code>:</p>\n<pre><code>i = i++ + 1; // the behavior is undefined\n\
    </code></pre>\n<p>But in <code>N4659</code></p>\n<pre><code>i = i++ + 1; // the\
    \ value of i is incremented\ni = i++ + i; // the behavior is undefined\n</code></pre>\n\
    <p>Of course, using a C++17 compliant compiler does not necessarily mean that\
    \ one should start writing such expressions.</p>\n</div>"
- - Can a local variable's memory be accessed outside its scope?
  - "<div class=\"post-text\" itemprop=\"text\">\n<blockquote>\n<p>How can it be?\
    \ Isn't the memory of a local variable inaccessible outside its function?</p>\n\
    </blockquote>\n<p>You rent a hotel room. You put a book in the top drawer of the\
    \ bedside table and go to sleep.  You check out the next morning, but \"forget\"\
    \ to give back your key. You steal the key!</p>\n<p>A week later, you return to\
    \ the hotel, do not check in, sneak into your old room with your stolen key, and\
    \ look in the drawer. Your book is still there. Astonishing!</p>\n<p><strong>How\
    \ can that be? Aren't the contents of a hotel room drawer inaccessible if you\
    \ haven't rented the room?</strong></p>\n<p>Well, obviously that scenario can\
    \ happen in the real world no problem. There is no mysterious force that causes\
    \ your book to disappear when you are no longer authorized to be in the room.\
    \ Nor is there a mysterious force that prevents you from entering a room with\
    \ a stolen key.</p>\n<p>The hotel management is not <em>required</em> to remove\
    \ your book. You didn't make a contract with them that said that if you leave\
    \ stuff behind, they'll shred it for you. If you illegally re-enter your room\
    \ with a stolen key to get it back, the hotel security staff is not <em>required</em>\
    \ to catch you sneaking in. You didn't make a contract with them that said \"\
    if I try to sneak back into my room later, you are required to stop me.\" Rather,\
    \ you signed a contract with them that said \"I promise not to sneak back into\
    \ my room later\", a contract which <em>you broke</em>.</p>\n<p>In this situation\
    \ <strong>anything can happen</strong>. The book can be there -- you got lucky.\
    \ Someone else's book can be there and yours could be in the hotel's furnace.\
    \ Someone could be there right when you come in, tearing your book to pieces.\
    \ The hotel could have removed the table and book entirely and replaced it with\
    \ a wardrobe. The entire hotel could be just about to be torn down and replaced\
    \ with a football stadium, and you are going to die in an explosion while you\
    \ are sneaking around. </p>\n<p>You don't know what is going to happen; when you\
    \ checked out of the hotel and stole a key to illegally use later, you gave up\
    \ the right to live in a predictable, safe world because <em>you</em> chose to\
    \ break the rules of the system.</p>\n<p><strong>C++ is not a safe language</strong>.\
    \ It will cheerfully allow you to break the rules of the system. If you try to\
    \ do something illegal and foolish like going back into a room you're not authorized\
    \ to be in and rummaging through a desk that might not even be there anymore,\
    \ C++ is not going to stop you. Safer languages than C++ solve this problem by\
    \ restricting your power -- by having much stricter control over keys, for example.</p>\n\
    <h2>UPDATE</h2>\n<p>Holy goodness, this answer is getting a lot of attention.\
    \ (I'm not sure why -- I considered it to be just a \"fun\" little analogy, but\
    \ whatever.)</p>\n<p>I thought it might be germane to update this a bit with a\
    \ few more technical thoughts.</p>\n<p>Compilers are in the business of generating\
    \ code which manages the storage of the data manipulated by that program. There\
    \ are lots of different ways of generating code to manage memory, but over time\
    \ two basic techniques have become entrenched. </p>\n<p>The first is to have some\
    \ sort of \"long lived\" storage area where the \"lifetime\" of each byte in the\
    \ storage -- that is, the period of time when it is validly associated with some\
    \ program variable -- cannot be easily predicted ahead of time. The compiler generates\
    \ calls into a \"heap manager\" that knows how to dynamically allocate storage\
    \ when it is needed and reclaim it when it is no longer needed.</p>\n<p>The second\
    \ method is to have a “short-lived” storage area where the lifetime of each byte\
    \ is well known. Here, the lifetimes follow a “nesting” pattern. The longest-lived\
    \ of these short-lived variables will be allocated before any other short-lived\
    \ variables, and will be freed last. Shorter-lived variables will be allocated\
    \ after the longest-lived ones, and will be freed before them. The lifetime of\
    \ these shorter-lived variables is “nested” within the lifetime of longer-lived\
    \ ones.</p>\n<p>Local variables follow the latter pattern; when a method is entered,\
    \ its local variables come alive. When that method calls another method, the new\
    \ method's local variables come alive. They'll be dead before the first method's\
    \ local variables are dead.  The relative order of the beginnings and endings\
    \ of lifetimes of storages associated with local variables can be worked out ahead\
    \ of time.</p>\n<p>For this reason, local variables are usually generated as storage\
    \ on a \"stack\" data structure, because a stack has the property that the first\
    \ thing pushed on it is going to be the last thing popped off. </p>\n<p>It's like\
    \ the hotel decides to only rent out rooms sequentially, and you can't check out\
    \ until everyone with a room number higher than you has checked out. </p>\n<p>So\
    \ let's think about the stack. In many operating systems you get one stack per\
    \ thread and the stack is allocated to be a certain fixed size. When you call\
    \ a method, stuff is pushed onto the stack. If you then pass a pointer to the\
    \ stack back out of your method, as the original poster does here, that's just\
    \ a pointer to the middle of some entirely valid million-byte memory block. In\
    \ our analogy, you check out of the hotel; when you do, you just checked out of\
    \ the highest-numbered occupied room.  If no one else checks in after you, and\
    \ you go back to your room illegally, all your stuff is guaranteed to still be\
    \ there <em>in this particular hotel</em>.</p>\n<p>We use stacks for temporary\
    \ stores because they are really cheap and easy. An implementation of C++ is not\
    \ required to use a stack for storage of locals; it could use the heap. It doesn't,\
    \ because that would make the program slower. </p>\n<p>An implementation of C++\
    \ is not required to leave the garbage you left on the stack untouched so that\
    \ you can come back for it later illegally; it is perfectly legal for the compiler\
    \ to generate code that turns back to zero everything in the \"room\" that you\
    \ just vacated. It doesn't because again, that would be expensive.</p>\n<p>An\
    \ implementation of C++ is not required to ensure that when the stack logically\
    \ shrinks, the addresses that used to be valid are still mapped into memory. The\
    \ implementation is allowed to tell the operating system \"we're done using this\
    \ page of stack now. Until I say otherwise, issue an exception that destroys the\
    \ process if anyone touches the previously-valid stack page\".  Again, implementations\
    \ do not actually do that because it is slow and unnecessary.</p>\n<p>Instead,\
    \ implementations let you make mistakes and get away with it. Most of the time.\
    \ Until one day something truly awful goes wrong and the process explodes.</p>\n\
    <p>This is problematic. There are a lot of rules and it is very easy to break\
    \ them accidentally. I certainly have many times. And worse, the problem often\
    \ only surfaces when memory is detected to be corrupt billions of nanoseconds\
    \ after the corruption happened, when it is very hard to figure out who messed\
    \ it up.</p>\n<p>More memory-safe languages solve this problem by restricting\
    \ your power. In \"normal\" C# there simply is no way to take the address of a\
    \ local and return it or store it for later. You can take the address of a local,\
    \ but the language is cleverly designed so that it is impossible to use it after\
    \ the lifetime of the local ends. In order to take the address of a local and\
    \ pass it back, you have to put the compiler in a special \"unsafe\" mode, <em>and</em>\
    \ put the word \"unsafe\" in your program, to call attention to the fact that\
    \ you are probably doing something dangerous that could be breaking the rules.\
    \ </p>\n<p>For further reading:</p>\n<ul>\n<li><p>What if C# did allow returning\
    \ references? Coincidentally that is the subject of today's blog post:</p>\n<p><a\
    \ href=\"http://blogs.msdn.com/b/ericlippert/archive/2011/06/23/ref-returns-and-ref-locals.aspx\"\
    \ rel=\"noreferrer\">http://blogs.msdn.com/b/ericlippert/archive/2011/06/23/ref-returns-and-ref-locals.aspx</a></p></li>\n\
    <li><p>Why do we use stacks to manage memory? Are value types in C# always stored\
    \ on the stack? How does virtual memory work? And many more topics in how the\
    \ C# memory manager works. Many of these articles are also germane to C++ programmers:</p>\n\
    <p><a href=\"https://blogs.msdn.microsoft.com/ericlippert/tag/memory-management/\"\
    \ rel=\"noreferrer\">https://blogs.msdn.microsoft.com/ericlippert/tag/memory-management/</a></p></li>\n\
    </ul>\n</div>"
- - Can a local variable's memory be accessed outside its scope?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>What you're doing here is simply\
    \ reading and writing to memory that <i>used to</i> be the address of <code>a</code>.\
    \ Now that you're outside of <code>foo</code>, it's just a pointer to some random\
    \ memory area. It just so happens that in your example, that memory area does\
    \ exist and nothing else is using it at the moment. You don't break anything by\
    \ continuing to use it, and nothing else has overwritten it yet. Therefore, the\
    \ <code>5</code> is still there. In a real program, that memory would be re-used\
    \ almost immediately and you'd break something by doing this (though the symptoms\
    \ may not appear until much later!)</p>\n<p>When you return from <code>foo</code>,\
    \ you tell the OS that you're no longer using that memory and it can be reassigned\
    \ to something else. If you're lucky and it never does get reassigned, and the\
    \ OS doesn't catch you using it again, then you'll get away with the lie. Chances\
    \ are though you'll end up writing over whatever else ends up with that address.</p>\n\
    <p>Now if you're wondering why the compiler doesn't complain, it's probably because\
    \ <code>foo</code> got eliminated by optimization. It usually will warn you about\
    \ this sort of thing. C assumes you know what you're doing though, and technically\
    \ you haven't violated scope here (there's no reference to <code>a</code> itself\
    \ outside of <code>foo</code>), only memory access rules, which only triggers\
    \ a warning rather than an error.</p>\n<p>In short: this won't usually work, but\
    \ sometimes will by chance.</p>\n</div>"
- - Can a local variable's memory be accessed outside its scope?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Because the storage space wasn't\
    \ stomped on just yet. Don't count on that behavior.</p>\n</div>"
- - Do the parentheses after the type name make a difference with new?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Let's get pedantic, because there\
    \ are differences that can actually affect your code's behavior. Much of the following\
    \ is taken from comments made to an <a href=\"http://blogs.msdn.com/oldnewthing/archive/2006/12/14/1285437.aspx\"\
    \ rel=\"noreferrer\">\"Old New Thing\" article</a>.</p>\n<p>Sometimes the memory\
    \ returned by the new operator will be initialized, and sometimes it won't depending\
    \ on whether the type you're newing up is a <a href=\"https://stackoverflow.com/questions/146452/what-are-pod-types-in-c\"\
    >POD (plain old data)</a>, or if it's a class that contains POD members and is\
    \ using a compiler-generated default constructor.</p>\n<ul>\n<li>In C++1998 there\
    \ are 2 types of initialization: zero and default</li>\n<li>In C++2003 a 3rd type\
    \ of initialization, value initialization was added.</li>\n</ul>\n<p>Assume:</p>\n\
    <pre><code>struct A { int m; }; // POD\nstruct B { ~B(); int m; }; // non-POD,\
    \ compiler generated default ctor\nstruct C { C() : m() {}; ~C(); int m; }; //\
    \ non-POD, default-initialising m\n</code></pre>\n<p>In a C++98 compiler, the\
    \ following should occur:</p>\n<ul>\n<li><code>new A</code>   - indeterminate\
    \ value</li>\n<li><p><code>new A()</code> - zero-initialize</p></li>\n<li><p><code>new\
    \ B</code>   - default construct (B::m is uninitialized)</p></li>\n<li><p><code>new\
    \ B()</code> - default construct (B::m is uninitialized)</p></li>\n<li><p><code>new\
    \ C</code>   - default construct (C::m is zero-initialized)</p></li>\n<li><code>new\
    \ C()</code> - default construct (C::m is zero-initialized)</li>\n</ul>\n<p>In\
    \ a C++03 conformant compiler, things should work like so:</p>\n<ul>\n<li><code>new\
    \ A</code>    - indeterminate value</li>\n<li><p><code>new A()</code>  - value-initialize\
    \ A, which is zero-initialization since it's a POD.</p></li>\n<li><p><code>new\
    \ B</code>    - default-initializes (leaves B::m uninitialized)</p></li>\n<li><p><code>new\
    \ B()</code>  - value-initializes B which zero-initializes all fields since its\
    \ default ctor is compiler generated as opposed to user-defined.</p></li>\n<li><p><code>new\
    \ C</code>    - default-initializes C, which calls the default ctor.</p></li>\n\
    <li><code>new C()</code>  - value-initializes C, which calls the default ctor.</li>\n\
    </ul>\n<p>So in all versions of C++ there's a difference between <code>new A</code>\
    \ and <code>new A()</code> because A is a POD.</p>\n<p>And there's a difference\
    \ in behavior between C++98 and C++03 for the case <code>new B()</code>.</p>\n\
    <p>This is one of the dusty corners of C++ that can drive you crazy. When constructing\
    \ an object, sometimes you want/need the parens, sometimes you absolutely cannot\
    \ have them, and sometimes it doesn't matter.</p>\n</div>"
- - Do the parentheses after the type name make a difference with new?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p><code>new Thing();</code> is\
    \ explicit that you want a constructor called whereas <code>new Thing;</code>\
    \ is taken to imply you don't mind if the constructor isn't called.</p>\n<p>If\
    \ used on a struct/class with a user-defined constructor, there is no difference.\
    \ If called on a trivial struct/class (e.g. <code>struct Thing { int i; };</code>)\
    \ then <code>new Thing;</code> is like <code>malloc(sizeof(Thing));</code> whereas\
    \ <code>new Thing();</code> is like <code>calloc(sizeof(Thing));</code> - it gets\
    \ zero initialized.</p>\n<p>The gotcha lies in-between:</p>\n<pre><code>struct\
    \ Thingy {\n  ~Thingy(); // No-longer a trivial class\n  virtual WaxOn();\n  int\
    \ i;\n};\n</code></pre>\n<p>The behavior of <code>new Thingy;</code> vs <code>new\
    \ Thingy();</code> in this case changed between C++98 and C++2003. See Michael\
    \ Burr's explanation for how and why.</p>\n</div>"
- - Do the parentheses after the type name make a difference with new?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>No, they are the same. But there\
    \ is a difference between:</p>\n<pre><code>Test t;      // create a Test called\
    \ t\n</code></pre>\n<p>and</p>\n<pre><code>Test t();   // declare a function called\
    \ t which returns a Test\n</code></pre>\n<p>This is because of the basic C++ (and\
    \ C) rule: If something can possibly be a declaration, then it is a declaration.</p>\n\
    <p><strong>Edit:</strong> Re the initialisation issues regarding POD and non-POD\
    \ data, while I agree with everything that has been said, I would just like to\
    \ point out that these issues only apply if the thing being new'd or otherwise\
    \ constructed does not have a user-defined constructor. If there is such a constructor\
    \ it will be used. For 99.99% of sensibly designed classes there will be such\
    \ a constructor, and so the issues can be ignored.  </p>\n</div>"
- - How to convert a std::string to const char* or char*?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>If you just want to pass a <a\
    \ href=\"http://en.cppreference.com/w/cpp/string/basic_string\" rel=\"noreferrer\"\
    ><code>std::string</code></a> to a function that needs <code>const char*</code>\
    \ you can use </p>\n<pre><code>std::string str;\nconst char * c = str.c_str();\n\
    </code></pre>\n<p>If you want to get a writable copy, like <code>char *</code>,\
    \ you can do that with this:</p>\n<pre><code>std::string str;\nchar * writable\
    \ = new char[str.size() + 1];\nstd::copy(str.begin(), str.end(), writable);\n\
    writable[str.size()] = '\\0'; // don't forget the terminating 0\n\n// don't forget\
    \ to free the string after finished using it\ndelete[] writable;\n</code></pre>\n\
    <p><strong>Edit</strong>: Notice that the above is not exception safe. If anything\
    \ between the <code>new</code> call and the <code>delete</code> call throws, you\
    \ will leak memory, as nothing will call <code>delete</code> for you automatically.\
    \ There are two immediate ways to solve this.</p>\n<h3>boost::scoped_array</h3>\n\
    <p><a href=\"http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_array.htm\"\
    \ rel=\"noreferrer\"><code>boost::scoped_array</code></a> will delete the memory\
    \ for you upon going out of scope:</p>\n<pre><code>std::string str;\nboost::scoped_array&lt;char&gt;\
    \ writable(new char[str.size() + 1]);\nstd::copy(str.begin(), str.end(), writable.get());\n\
    writable[str.size()] = '\\0'; // don't forget the terminating 0\n\n// get the\
    \ char* using writable.get()\n\n// memory is automatically freed if the smart\
    \ pointer goes \n// out of scope\n</code></pre>\n<h3>std::vector</h3>\n<p>This\
    \ is the standard way (does not require any external library). You use <a href=\"\
    http://en.cppreference.com/w/cpp/container/vector\" rel=\"noreferrer\"><code>std::vector</code></a>,\
    \ which completely manages the memory for you.</p>\n<pre><code>std::string str;\n\
    std::vector&lt;char&gt; writable(str.begin(), str.end());\nwritable.push_back('\\\
    0');\n\n// get the char* using &amp;writable[0] or &amp;*writable.begin()\n</code></pre>\n\
    </div>"
- - How to convert a std::string to const char* or char*?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Given say...</p>\n<pre><code>std::string\
    \ x = \"hello\";\n</code></pre>\n<h2> Getting a `char *` or `const char*` from\
    \ a `string`</h2>\n<p><strong>How to get a character pointer that's valid while\
    \ <code>x</code> remains in scope and isn't modified further</strong></p>\n<p><strong>C++11</strong>\
    \ simplifies things; the following all give access to the same internal string\
    \ buffer:</p>\n<pre><code>const char* p_c_str = x.c_str();\nconst char* p_data\
    \  = x.data();\nconst char* p_x0    = &amp;x[0];\n\n      char* p_x0_rw = &amp;x[0];\
    \  // compiles iff x is not const...\n</code></pre>\n<p>All the above pointers\
    \ will hold the <em>same value</em> - the address of the first character in the\
    \ buffer.  Even an empty string has a \"first character in the buffer\", because\
    \ C++11 guarantees to always keep an extra NUL/0 terminator character after the\
    \ explicitly assigned string content (e.g. <code>std::string(\"this\\0that\",\
    \ 9)</code> will have a buffer holding <code>\"this\\0that\\0\"</code>).</p>\n\
    <p>Given any of the above pointers:</p>\n<pre><code>char c = p[n];   // valid\
    \ for n &lt;= x.size()\n                 // i.e. you can safely read the NUL at\
    \ p[x.size()]\n</code></pre>\n<p>Only for the non-<code>const</code> pointer from\
    \ <code>&amp;x[0]</code>:</p>\n<pre><code>p_x0_rw[n] = c;  // valid for n &lt;=\
    \ x.size() - 1\n                 // i.e. don't overwrite the implementation maintained\
    \ NUL\n</code></pre>\n<p>Writing a NUL elsewhere in the string does <em>not</em>\
    \ change the <code>string</code>'s <code>size()</code>; <code>string</code>'s\
    \ are allowed to contain any number of NULs - they are given no special treatment\
    \ by <code>std::string</code> (same in C++03).</p>\n<p>In <strong>C++03</strong>,\
    \ things were considerably more complicated (key differences <strong><em>highlighted</em></strong>):</p>\n\
    <ul>\n<li><p><code>x.data()</code></p>\n<ul>\n<li>returns <code>const char*</code>\
    \ to the string's internal buffer <strong><em>which wasn't required by the Standard\
    \ to conclude with a NUL</em></strong> (i.e. might be <code>['h', 'e', 'l', 'l',\
    \ 'o']</code> followed by uninitialised or garbage values, with accidental accesses\
    \ thereto having <em>undefined behaviour</em>).\n\n<ul>\n<li><code>x.size()</code>\
    \ characters are safe to read, i.e. <code>x[0]</code> through <code>x[x.size()\
    \ - 1]</code></li>\n<li>for empty strings, you're guaranteed some non-NULL pointer\
    \ to which 0 can be safely added (hurray!), but you shouldn't dereference that\
    \ pointer.</li>\n</ul></li>\n</ul></li>\n<li><p><code>&amp;x[0]</code></p>\n<ul>\n\
    <li><strong><em>for empty strings this has undefined behaviour</em></strong> (21.3.4)\n\
    \n<ul>\n<li>e.g. given <code>f(const char* p, size_t n) { if (n == 0) return;\
    \ ...whatever... }</code> you mustn't call <code>f(&amp;x[0], x.size());</code>\
    \ when <code>x.empty()</code> - just use <code>f(x.data(), ...)</code>.</li>\n\
    </ul></li>\n<li>otherwise, as per <code>x.data()</code> but:\n\n<ul>\n<li>for\
    \ non-<code>const</code> <code>x</code> this yields a non-<code>const</code> <code>char*</code>\
    \ pointer; you can overwrite string content</li>\n</ul></li>\n</ul></li>\n<li><p><code>x.c_str()</code></p>\n\
    <ul>\n<li>returns <code>const char*</code> to an ASCIIZ (NUL-terminated) representation\
    \ of the value (i.e. ['h', 'e', 'l', 'l', 'o', '\\0']).</li>\n<li>although few\
    \ if any implementations chose to do so, the C++03 Standard was worded to allow\
    \ the string implementation the freedom to create a <strong><em>distinct NUL-terminated\
    \ buffer</em></strong> <em>on the fly</em>, from the potentially non-NUL terminated\
    \ buffer \"exposed\" by <code>x.data()</code> and <code>&amp;x[0]</code></li>\n\
    <li><code>x.size()</code> + 1 characters are safe to read.</li>\n<li>guaranteed\
    \ safe even for empty strings (['\\0']).</li>\n</ul></li>\n</ul>\n<h2>Consequences\
    \ of accessing outside legal indices</h2>\n<p>Whichever way you get a pointer,\
    \ you must not access memory further along from the pointer than the characters\
    \ guaranteed present in the descriptions above.  Attempts to do so have <em>undefined\
    \ behaviour</em>, with a very real chance of application crashes and garbage results\
    \ even for reads, and additionally wholesale data, stack corruption and/or security\
    \ vulnerabilities for writes.</p>\n<h2>When do those pointers get invalidated?</h2>\n\
    <p>If you call some <code>string</code> member function that modifies the <code>string</code>\
    \ or reserves further capacity, any pointer values returned beforehand by any\
    \ of the above methods are <em>invalidated</em>.  You can use those methods again\
    \ to get another pointer.  (The rules are the same as for iterators into <code>string</code>s).</p>\n\
    <p>See also <em>How to get a character pointer valid even after <code>x</code>\
    \ leaves scope or is modified further</em> below....</p>\n<h2>So, which is <em>better</em>\
    \ to use?</h2>\n<p>From C++11, use <code>.c_str()</code> for ASCIIZ data, and\
    \ <code>.data()</code> for \"binary\" data (explained further below).</p>\n<p>In\
    \ C++03, use <code>.c_str()</code> unless certain that <code>.data()</code> is\
    \ adequate, and prefer <code>.data()</code> over <code>&amp;x[0]</code> as it's\
    \ safe for empty strings....</p>\n<p><em>...try to understand the program enough\
    \ to use <code>data()</code> when appropriate, or you'll probably make other mistakes...</em></p>\n\
    <p>The ASCII NUL '\\0' character guaranteed by <code>.c_str()</code> is used by\
    \ many functions as a sentinel value denoting the end of relevant and safe-to-access\
    \ data.  This applies to both C++-only functions like say <code>fstream::fstream(const\
    \ char* filename, ...)</code> and shared-with-C functions like <code>strchr()</code>,\
    \ and <code>printf()</code>.</p>\n<p>Given C++03's <code>.c_str()</code>'s guarantees\
    \ about the returned buffer are a super-set of <code>.data()</code>'s, you can\
    \ always safely use <code>.c_str()</code>, but people sometimes don't because:</p>\n\
    <ul>\n<li>using <code>.data()</code> communicates to other programmers reading\
    \ the source code that the data is not ASCIIZ (rather, you're using the string\
    \ to store a block of data (which sometimes isn't even really textual)), or that\
    \ you're passing it to another function that treats it as a block of \"binary\"\
    \ data.  This can be a crucial insight in ensuring that other programmers' code\
    \ changes continue to handle the data properly.</li>\n<li>C++03 only: there's\
    \ a slight chance that your <code>string</code> implementation will need to do\
    \ some extra memory allocation and/or data copying in order to prepare the NUL\
    \ terminated buffer</li>\n</ul>\n<p>As a further hint, if a function's parameters\
    \ require the (<code>const</code>) <code>char*</code> but don't insist on getting\
    \ <code>x.size()</code>, the function <em>probably</em> needs an ASCIIZ input,\
    \ so <code>.c_str()</code> is a good choice (the function needs to know where\
    \ the text terminates somehow, so if it's not a separate parameter it can only\
    \ be a convention like a length-prefix or sentinel or some fixed expected length).</p>\n\
    <h2>How to get a character pointer valid even after <code>x</code> leaves scope\
    \ or is modified further</h2>\n<p>You'll need to <strong><em>copy</em></strong>\
    \ the contents of the <code>string</code> <code>x</code> to a new memory area\
    \ outside <code>x</code>.  This external buffer could be in many places such as\
    \ another <code>string</code> or character array variable, it may or may not have\
    \ a different lifetime than <code>x</code> due to being in a different scope (e.g.\
    \ namespace, global, static, heap, shared memory, memory mapped file).</p>\n<p>To\
    \ copy the text from <code>std::string x</code> into an independent character\
    \ array:</p>\n<pre><code>// USING ANOTHER STRING - AUTO MEMORY MANAGEMENT, EXCEPTION\
    \ SAFE\nstd::string old_x = x;\n// - old_x will not be affected by subsequent\
    \ modifications to x...\n// - you can use `&amp;old_x[0]` to get a writable char*\
    \ to old_x's textual content\n// - you can use resize() to reduce/expand the string\n\
    //   - resizing isn't possible from within a function passed only the char* address\n\
    \nstd::string old_x = x.c_str(); // old_x will terminate early if x embeds NUL\n\
    // Copies ASCIIZ data but could be less efficient as it needs to scan memory to\n\
    // find the NUL terminator indicating string length before allocating that amount\n\
    // of memory to copy into, or more efficient if it ends up allocating/copying\
    \ a\n// lot less content.\n// Example, x == \"ab\\0cd\" -&gt; old_x == \"ab\"\
    .\n\n// USING A VECTOR OF CHAR - AUTO, EXCEPTION SAFE, HINTS AT BINARY CONTENT,\
    \ GUARANTEED CONTIGUOUS EVEN IN C++03\nstd::vector&lt;char&gt; old_x(x.data(),\
    \ x.data() + x.size());       // without the NUL\nstd::vector&lt;char&gt; old_x(x.c_str(),\
    \ x.c_str() + x.size() + 1);  // with the NUL\n\n// USING STACK WHERE MAXIMUM\
    \ SIZE OF x IS KNOWN TO BE COMPILE-TIME CONSTANT \"N\"\n// (a bit dangerous, as\
    \ \"known\" things are sometimes wrong and often become wrong)\nchar y[N + 1];\n\
    strcpy(y, x.c_str());\n\n// USING STACK WHERE UNEXPECTEDLY LONG x IS TRUNCATED\
    \ (e.g. Hello\\0-&gt;Hel\\0)\nchar y[N + 1];\nstrncpy(y, x.c_str(), N);  // copy\
    \ at most N, zero-padding if shorter\ny[N] = '\\0';               // ensure NUL\
    \ terminated\n\n// USING THE STACK TO HANDLE x OF UNKNOWN (BUT SANE) LENGTH\n\
    char* y = alloca(x.size() + 1);\nstrcpy(y, x.c_str());\n\n// USING THE STACK TO\
    \ HANDLE x OF UNKNOWN LENGTH (NON-STANDARD GCC EXTENSION)\nchar y[x.size() + 1];\n\
    strcpy(y, x.c_str());\n\n// USING new/delete HEAP MEMORY, MANUAL DEALLOC, NO INHERENT\
    \ EXCEPTION SAFETY\nchar* y = new char[x.size() + 1];\nstrcpy(y, x.c_str());\n\
    //     or as a one-liner: char* y = strcpy(new char[x.size() + 1], x.c_str());\n\
    // use y...\ndelete[] y; // make sure no break, return, throw or branching bypasses\
    \ this\n\n// USING new/delete HEAP MEMORY, SMART POINTER DEALLOCATION, EXCEPTION\
    \ SAFE\n// see boost shared_array usage in Johannes Schaub's answer\n\n// USING\
    \ malloc/free HEAP MEMORY, MANUAL DEALLOC, NO INHERENT EXCEPTION SAFETY\nchar*\
    \ y = strdup(x.c_str());\n// use y...\nfree(y);\n</code></pre>\n<h2>Other reasons\
    \ to want a <code>char*</code> or <code>const char*</code> generated from a <code>string</code></h2>\n\
    <p>So, above you've seen how to get a (<code>const</code>) <code>char*</code>,\
    \ and how to make a copy of the text independent of the original <code>string</code>,\
    \ but what can you <em>do</em> with it?  A random smattering of examples...</p>\n\
    <ul>\n<li>give \"C\" code access to the C++ <code>string</code>'s text, as in\
    \ <code>printf(\"x is '%s'\", x.c_str());</code></li>\n<li>copy <code>x</code>'s\
    \ text to a buffer specified by your function's caller (e.g. <code>strncpy(callers_buffer,\
    \ callers_buffer_size, x.c_str())</code>), or volatile memory used for device\
    \ I/O (e.g. <code>for (const char* p = x.c_str(); *p; ++p) *p_device = *p;</code>)</li>\n\
    <li>append <code>x</code>'s text to an character array already containing some\
    \ ASCIIZ text (e.g. <code>strcat(other_buffer, x.c_str())</code>) - be careful\
    \ not to overrun the buffer (in many situations you may need to use <code>strncat</code>)</li>\n\
    <li>return a <code>const char*</code> or <code>char*</code> from a function (perhaps\
    \ for historical reasons - client's using your existing API - or for C compatibility\
    \ you don't want to return a <code>std::string</code>, but do want to copy your\
    \ <code>string</code>'s data somewhere for the caller)\n\n<ul>\n<li>be careful\
    \ not to return a pointer that may be dereferenced by the caller after a local\
    \ <code>string</code> variable to which that pointer pointed has left scope</li>\n\
    <li>some projects with shared objects compiled/linked for different <code>std::string</code>\
    \ implementations (e.g. STLport and compiler-native) may pass data as ASCIIZ to\
    \ avoid conflicts</li>\n</ul></li>\n</ul>\n</div>"
- - How to convert a std::string to const char* or char*?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Use the <code>.c_str()</code>\
    \ method for <code>const char *</code>.</p>\n<p>You can use <code>&amp;mystring[0]</code>\
    \ to get a <code>char *</code> pointer, but there are a couple of gotcha's: you\
    \ won't necessarily get a zero terminated string, and you won't be able to change\
    \ the string's size. You especially have to be careful not to add characters past\
    \ the end of the string or you'll get a buffer overrun (and probable crash).</p>\n\
    <p>There was no guarantee that all of the characters would be part of the same\
    \ contiguous buffer until C++11, but in practice all known implementations of\
    \ <code>std::string</code> worked that way anyway; see <a href=\"https://stackoverflow.com/questions/1986966/does-s0-point-to-contiguous-characters-in-a-stdstring\"\
    >Does “&amp;s[0]” point to contiguous characters in a std::string?</a>.</p>\n\
    <p>Note that many <code>string</code> member functions will reallocate the internal\
    \ buffer and invalidate any pointers you might have saved. Best to use them immediately\
    \ and then discard.</p>\n</div>"
- - Can I call a constructor from another constructor (do constructor chaining) in
    C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p><strong>C++11: Yes!</strong></p>\n\
    <p>C++11 and onwards has this same feature (called <a href=\"https://secure.wikimedia.org/wikipedia/en/wiki/C++11#Object_construction_improvement\"\
    \ rel=\"noreferrer\">delegating constructors</a>). </p>\n<p>The syntax is slightly\
    \ different from C#:</p>\n<pre><code>class Foo {\npublic: \n  Foo(char x, int\
    \ y) {}\n  Foo(int y) : Foo('a', y) {}\n};\n</code></pre>\n<p><strong>C++03: No</strong></p>\n\
    <p>Unfortunately, there's no way to do this in C++03, but there are two ways of\
    \ simulating this:</p>\n<ol>\n<li><p>You can combine two (or more) constructors\
    \ via default parameters:</p>\n<pre><code>class Foo {\npublic:\n  Foo(char x,\
    \ int y=0);  // combines two constructors (char) and (char, int)\n  // ...\n};\n\
    </code></pre></li>\n<li><p>Use an init method to share common code:</p>\n<pre><code>class\
    \ Foo {\npublic:\n  Foo(char x);\n  Foo(char x, int y);\n  // ...\nprivate:\n\
    \  void init(char x, int y);\n};\n\nFoo::Foo(char x)\n{\n  init(x, int(x) + 7);\n\
    \  // ...\n}\n\nFoo::Foo(char x, int y)\n{\n  init(x, y);\n  // ...\n}\n\nvoid\
    \ Foo::init(char x, int y)\n{\n  // ...\n}\n</code></pre></li>\n</ol>\n<p>See\
    \ <a href=\"https://isocpp.org/wiki/faq/ctors#init-methods\" rel=\"noreferrer\"\
    >the C++FAQ entry</a> for reference.</p>\n</div>"
- - Can I call a constructor from another constructor (do constructor chaining) in
    C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>No, you can't call one constructor\
    \ from another in C++03 (called a delegating constructor).</p>\n<p>This changed\
    \ in C++11 (aka C++0x), which added support for the following syntax:<br/>\n(example\
    \ taken from <a href=\"http://en.wikipedia.org/wiki/C%2B%2B11#Object_construction_improvement\"\
    \ rel=\"noreferrer\">Wikipedia</a>)</p>\n<pre><code>class SomeType\n{\n  int number;\n\
    \npublic:\n  SomeType(int newNumber) : number(newNumber) {}\n  SomeType() : SomeType(42)\
    \ {}\n};\n</code></pre>\n</div>"
- - Can I call a constructor from another constructor (do constructor chaining) in
    C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>I believe you can call a constructor\
    \ from a constructor. It will compile and run. I recently saw someone do this\
    \ and it ran on both Windows and Linux.</p>\n<p>It just doesn't do what you want.\
    \ The inner constructor will construct a temporary local object which gets deleted\
    \ once the outer constructor returns. They would have to be different constructors\
    \ as well or you would create a recursive call.</p>\n<p>Ref: <a href=\"https://isocpp.org/wiki/faq/ctors#init-methods\"\
    \ rel=\"noreferrer\">https://isocpp.org/wiki/faq/ctors#init-methods</a></p>\n\
    </div>"
- - When should you use a class vs a struct in C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Differences between a <code>class</code>\
    \ and a <code>struct</code> in C++ are that structs have default <code>public</code>\
    \ members and bases and classes have default <code>private</code> members and\
    \ bases. Both classes and structs can have a mixture of <code>public</code>, <code>protected</code>\
    \ and <code>private</code> members, can use inheritance and can have member functions.</p>\n\
    <p>I would recommend using structs as plain-old-data structures without any class-like\
    \ features, and using classes as aggregate data structures with <code>private</code>\
    \ data and member functions.</p>\n</div>"
- - When should you use a class vs a struct in C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>As everyone else notes there\
    \ are really only two actual language differences:</p>\n<ul>\n<li><code>struct</code>\
    \ defaults to public access and <code>class</code> defaults to private access.</li>\n\
    <li>When inheriting, <code>struct</code> defaults to <code>public</code> inheritance\
    \ and <code>class</code> defaults to <code>private</code> inheritance.  (Ironically,\
    \ as with so many things in C++, the default is backwards: <code>public</code>\
    \ inheritance is by far the more common choice, but people rarely declare <code>struct</code>s\
    \ just to save on typing the \"<code>public</code>\" keyword.</li>\n</ul>\n<p>But\
    \ the real difference in practice is between a <code>class</code>/<code>struct</code>\
    \ that declares a constructor/destructor and one that doesn't.  There are certain\
    \ guarantees to a \"plain-old-data\" POD type, that no longer apply once you take\
    \ over the class's construction.  To keep this distinction clear, many people\
    \ deliberately only use <code>struct</code>s for POD types, and, if they are going\
    \ to add any methods at all, use <code>class</code>es.  The difference between\
    \ the two fragments below is otherwise meaningless:</p>\n<pre><code>class X\n\
    {\n  public:\n\n  // ...\n};\n\nstruct X\n{\n  // ...\n};\n</code></pre>\n<p>(Incidentally,\
    \ here's a thread with some good explanations about what \"POD type\" actually\
    \ means: <a href=\"https://stackoverflow.com/questions/146452/what-are-pod-types-in-c\"\
    >What are POD types in C++?</a>)</p>\n</div>"
- - When should you use a class vs a struct in C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>There are lots of misconceptions\
    \ in the existing answers.</p>\n<p><a href=\"https://stackoverflow.com/a/34108140/560648\"\
    ><strong>Both <code>class</code> and <code>struct</code> declare a class.</strong></a></p>\n\
    <p>Yes, you may have to rearrange your access modifying keywords inside the class\
    \ definition, depending on which keyword you used to declare the class.</p>\n\
    <p>But, beyond syntax, the <em>only</em> reason to choose one over the other is\
    \ convention/style/preference.</p>\n<p>Some people like to stick with the <code>struct</code>\
    \ keyword for classes without member functions, because the resulting definition\
    \ \"looks like\" a simple structure from C.</p>\n<p>Similarly, some people like\
    \ to use the <code>class</code> keyword for classes with member functions and\
    \ <code>private</code> data, because it says \"class\" on it and therefore looks\
    \ like examples from their favourite book on object-oriented programming.</p>\n\
    <p>The reality is that this completely up to you and your team, and it'll make\
    \ literally no difference whatsoever to your program.</p>\n<p>The following two\
    \ classes are absolutely equivalent in every way except their name:</p>\n<pre><code>struct\
    \ Foo\n{\n   int x;\n};\n\nclass Bar\n{\npublic:\n   int x;\n};\n</code></pre>\n\
    <p>You can even switch keywords when redeclaring:</p>\n<pre><code>class Foo;\n\
    struct Bar;\n</code></pre>\n<p>(although some compilers will emit a warning when\
    \ you do this, on the assumption that you probably didn't <em>intend</em> to do\
    \ something so confusing and that you should therefore be prompted to double-check\
    \ your code.)</p>\n<p>and the following expressions both evaluate to true:</p>\n\
    <pre><code>std::is_class&lt;Foo&gt;::value\nstd::is_class&lt;Bar&gt;::value\n\
    </code></pre>\n<p>Do note, though, that you can't switch the keywords when <em>redefining</em>;\
    \ this is only because (per the one-definition rule) duplicate class definitions\
    \ across translation units must <em>\"consist of the same sequence of tokens\"\
    </em>. This means you can't even exchange <code>const int member;</code> with\
    \ <code>int const member;</code>, and has nothing to do with the semantics of\
    \ <code>class</code> or <code>struct</code>.</p>\n</div>"
- - Why should C++ programmers minimize use of 'new'?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>There are two widely-used memory\
    \ allocation techniques: automatic allocation and dynamic allocation.  Commonly,\
    \ there is a corresponding region of memory for each: the stack and the heap.</p>\n\
    <h3>Stack</h3>\n<p>The stack always allocates memory in a sequential fashion.\
    \  It can do so because it requires you to release the memory in the reverse order\
    \ (First-In, Last-Out: FILO).  This is the memory allocation technique for local\
    \ variables in many programming languages.  It is very, very fast because it requires\
    \ minimal bookkeeping and the next address to allocate is implicit.</p>\n<p>In\
    \ C++, this is called <em>automatic storage</em> because the storage is claimed\
    \ automatically at the end of scope.  As soon as execution of current code block\
    \ (delimited using <code>{}</code>) is completed, memory for all variables in\
    \ that block is automatically collected.  This is also the moment where <em>destructors</em>\
    \ are invoked to clean up resources.</p>\n<h3>Heap</h3>\n<p>The heap allows for\
    \ a more flexible memory allocation mode.  Bookkeeping is more complex and allocation\
    \ is slower.  Because there is no implicit release point, you must release the\
    \ memory manually, using <code>delete</code> or <code>delete[]</code> (<code>free</code>\
    \ in C).  However, the absence of an implicit release point is the key to the\
    \ heap's flexibility.</p>\n<h3>Reasons to use dynamic allocation</h3>\n<p>Even\
    \ if using the heap is slower and potentially leads to memory leaks or memory\
    \ fragmentation, there are perfectly good use cases for dynamic allocation, as\
    \ it's less limited.</p>\n<p>Two key reasons to use dynamic allocation:</p>\n\
    <ul>\n<li><p>You don't know how much memory you need at compile time.  For instance,\
    \ when reading a text file into a string, you usually don't know what size the\
    \ file has, so you can't decide how much memory to allocate until you run the\
    \ program.</p></li>\n<li><p>You want to allocate memory which will persist after\
    \ leaving the current block.  For instance, you may want to write a function <code>string\
    \ readfile(string path)</code> that returns the contents of a file.  In this case,\
    \ even if the stack could hold the entire file contents, you could not return\
    \ from a function and keep the allocated memory block.</p></li>\n</ul>\n<h3>Why\
    \ dynamic allocation is often unnecessary</h3>\n<p>In C++ there's a neat construct\
    \ called a <em>destructor</em>.  This mechanism allows you to manage resources\
    \ by aligning the lifetime of the resource with the lifetime of a variable. This\
    \ technique is called <a href=\"http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\"\
    >RAII</a> and is the distinguishing point of C++. It \"wraps\" resources into\
    \ objects.  <code>std::string</code> is a perfect example.  This snippet:</p>\n\
    <pre><code>int main ( int argc, char* argv[] )\n{\n    std::string program(argv[0]);\n\
    }\n</code></pre>\n<p>actually allocates a variable amount of memory.  The <code>std::string</code>\
    \ object allocates memory using the heap and releases it in its destructor.  In\
    \ this case, you did <em>not</em> need to manually manage any resources and still\
    \ got the benefits of dynamic memory allocation.</p>\n<p>In particular, it implies\
    \ that in this snippet:</p>\n<pre><code>int main ( int argc, char* argv[] )\n\
    {\n    std::string * program = new std::string(argv[0]);  // Bad!\n    delete\
    \ program;\n}\n</code></pre>\n<p>there is unneeded dynamic memory allocation.\
    \  The program requires more typing (!) and introduces the risk of forgetting\
    \ to deallocate the memory.  It does this with no apparent benefit.</p>\n<h3>Why\
    \ you should use automatic storage as often as possible</h3>\n<p>Basically, the\
    \ last paragraph sums it up.  Using automatic storage as often as possible makes\
    \ your programs:</p>\n<ul>\n<li>faster to type;</li>\n<li>faster when run;</li>\n\
    <li>less prone to memory/resource leaks.</li>\n</ul>\n<h3>Bonus points</h3>\n\
    <p>In the referenced question, there are additional concerns.  In particular,\
    \ the following class:</p>\n<pre><code>class Line {\npublic:\n    Line();\n  \
    \  ~Line();\n    std::string* mString;\n};\n\nLine::Line() {\n    mString = new\
    \ std::string(\"foo_bar\");\n}\n\nLine::~Line() {\n    delete mString;\n}\n</code></pre>\n\
    <p>Is actually a lot more risky to use than the following one:</p>\n<pre><code>class\
    \ Line {\npublic:\n    Line();\n    std::string mString;\n};\n\nLine::Line() {\n\
    \    mString = \"foo_bar\";\n    // note: there is a cleaner way to write this.\n\
    }\n</code></pre>\n<p>The reason is that <code>std::string</code> properly defines\
    \ a copy constructor.  Consider the following program:</p>\n<pre><code>int main\
    \ ()\n{\n    Line l1;\n    Line l2 = l1;\n}\n</code></pre>\n<p>Using the original\
    \ version, this program will likely crash, as it uses <code>delete</code> on the\
    \ same string twice.  Using the modified version, each <code>Line</code> instance\
    \ will own its own string <em>instance</em>, each with its own memory and both\
    \ will be released at the end of the program.</p>\n<h3>Other notes</h3>\n<p>Extensive\
    \ use of <a href=\"http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\"\
    >RAII</a> is considered a best practice in C++ because of all the reasons above.\
    \  However, there is an additional benefit which is not immediately obvious. \
    \ Basically, it's better than the sum of its parts.  The whole mechanism <em>composes</em>.\
    \  It scales.</p>\n<p>If you use the <code>Line</code> class as a building block:</p>\n\
    <pre><code> class Table\n {\n      Line borders[4];\n };\n</code></pre>\n<p>Then</p>\n\
    <pre><code> int main ()\n {\n     Table table;\n }\n</code></pre>\n<p>allocates\
    \ four <code>std::string</code> instances, four <code>Line</code> instances, one\
    \ <code>Table</code> instance and all the string's contents and <em>everything\
    \ is freed automagically</em>.</p>\n</div>"
- - Why should C++ programmers minimize use of 'new'?
  - "<div class=\"post-text\" itemprop=\"text\">\n<h3>Because the stack is fast and\
    \ foolproof</h3>\n<p>In C++, it takes but a single instruction to allocate space\
    \ -- on the stack -- for every local scope object in a given function, and it's\
    \ impossible to leak any of that memory. That comment intended (or should have\
    \ intended) to say something like <em>\"use the stack and not the heap\".</em></p>\n\
    </div>"
- - Why should C++ programmers minimize use of 'new'?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>It's complicated.</p>\n<p>First,\
    \ C++ is not garbage collected. Therefore, for every new, there must be a corresponding\
    \ delete. If you fail to put this delete in, then you have a memory leak. Now,\
    \ for a simple case like this:</p>\n<pre><code>std::string *someString = new std::string(...);\n\
    //Do stuff\ndelete someString;\n</code></pre>\n<p>This is simple. But what happens\
    \ if \"Do stuff\" throws an exception? Oops: memory leak. What happens if \"Do\
    \ stuff\" issues <code>return</code> early? Oops: memory leak.</p>\n<p>And this\
    \ is for the <em>simplest case</em>. If you happen to return that string to someone,\
    \ now they have to delete it. And if they pass it as an argument, does the person\
    \ receiving it need to delete it? When should they delete it?</p>\n<p>Or, you\
    \ can just do this:</p>\n<pre><code>std::string someString(...);\n//Do stuff\n\
    </code></pre>\n<p>No <code>delete</code>. The object was created on the \"stack\"\
    , and it will be destroyed once it goes out of scope. You can even return the\
    \ object, thus transfering its contents to the calling function. You can pass\
    \ the object to functions (typically as a reference or const-reference: <code>void\
    \ SomeFunc(std::string &amp;iCanModifyThis, const std::string &amp;iCantModifyThis)</code>.\
    \ And so forth.</p>\n<p>All without <code>new</code> and <code>delete</code>.\
    \ There's no question of who owns the memory or who's responsible for deleting\
    \ it. If you do:</p>\n<pre><code>std::string someString(...);\nstd::string otherString;\n\
    otherString = someString;\n</code></pre>\n<p>It is understood that <code>otherString</code>\
    \ has a copy of the <em>data</em> of <code>someString</code>. It isn't a pointer;\
    \ it is a separate object. They may happen to have the same contents, but you\
    \ can change one without affecting the other:</p>\n<pre><code>someString += \"\
    More text.\";\nif(otherString == someString) { /*Will never get here */ }\n</code></pre>\n\
    <p>See the idea?</p>\n</div>"
- - C++ code for testing the Collatz conjecture faster than hand-written assembly
    - why?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>If you think a 64-bit DIV instruction\
    \ is a good way to divide by two, then no wonder the compiler's asm output beat\
    \ your hand-written code, even with <code>-O0</code> (compile fast, no extra optimization,\
    \ and store/reload to memory after/before every C statement so a debugger can\
    \ modify variables).</p>\n<p>See <a href=\"http://agner.org/optimize/\" rel=\"\
    noreferrer\">Agner Fog's Optimizing Assembly guide</a> to learn how to write efficient\
    \ asm.  He also has instruction tables and a microarch guide for specific details\
    \ for specific CPUs.  See also the <a class=\"post-tag\" href=\"/questions/tagged/x86\"\
    \ rel=\"tag\" title=\"show questions tagged 'x86'\">x86</a> tag wiki for more\
    \ perf links.</p>\n<p>See also this more general question about beating the compiler\
    \ with hand-written asm: <a href=\"https://stackoverflow.com/questions/9601427\"\
    >Is inline assembly language slower than native C++ code?</a>.  TL:DR: yes if\
    \ you do it wrong (like this question).</p>\n<p>Usually you're fine letting the\
    \ compiler do its thing, especially if you <strong>try to write C++ that can compile\
    \ efficiently</strong>.  Also see <a href=\"https://stackoverflow.com/questions/1866316/assembly-language-compiled-languages\"\
    >is assembly faster than compiled languages?</a>.  One of the answers links to\
    \ <a href=\"http://www.linux-kongress.org/2009/slides/compiler_survey_felix_von_leitner.pdf\"\
    \ rel=\"noreferrer\">these neat slides</a> showing how various C compilers optimize\
    \ some really simple functions with cool tricks.</p>\n<hr/>\n<pre><code>even:\n\
    \    mov rbx, 2\n    xor rdx, rdx\n    div rbx\n</code></pre>\n<p>On Intel Haswell,\
    \ <strong><code>div r64</code></strong> is 36 uops, with a <strong>latency of\
    \ 32-96 cycles</strong>, and a throughput of one per 21-74 cycles.  (Plus the\
    \ 2 uops to set up RBX and zero RDX, but out-of-order execution can run those\
    \ early).  <a href=\"https://stackoverflow.com/q/26907523/224132\">High-uop-count\
    \ instructions like DIV are microcoded, which can also cause front-end bottlenecks.</a>\
    \ In this case, latency is the most relevant factor because it's part of a loop-carried\
    \ dependency chain.</p>\n<p><strong><code>shr rax, 1</code> does the same unsigned\
    \ division: It's 1 uop, with 1c latency</strong>, and can run 2 per clock cycle.</p>\n\
    <p>For comparison, 32-bit division is faster, but still horrible vs. shifts. <code>idiv\
    \ r32</code> is 9 uops, 22-29c latency, and one per 8-11c throughput on Haswell.</p>\n\
    <hr/>\n<p><strong>As you can see from looking at gcc's <code>-O0</code> asm output\
    \ (<a href=\"http://gcc.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,options:(colouriseAsm:'0',compileOnChange:'0'),source:'%23include+%3Ciostream%3E%0A%23include+%3Cstdint.h%3E%0Ausing+namespace+std%3B%0A%0A//+unsigned+types+give+better+asm+output+for+divides+by+2.%0A//+Even+with+-O3,+%60long%60+sucks+(try+it:+godbolt+recompiles+automatically+after+edits)%0A//+I+used+this+version+as+a+starting+point+for+hand-optimizing.%0Aint+sequence(uint64_t+n)+%7B%0A++//+CHANGED+FROM+THE+QUESTION!'S+CODE:+long+-%3E+uint64_t+%0A++++int+count+%3D+1%3B%0A++++while+(n+!!%3D+1)+%7B%0A++++++++if+(n+%25+2+%3D%3D+0)%0A++++++++++++n+/%3D+2%3B%0A++++++++else%0A++++++++++++n+%3D+n*3+%2B+1%3B%0A%0A++++++++%2B%2Bcount%3B%0A++++%7D%0A++++return+count%3B%0A%7D%0A%0Aint+main()+%7B%0A++++int+max+%3D+0,+maxi%3B%0A++++for+(int+i+%3D+999999%3B+i+%3E+0%3B+--i)+%7B%0A++++++++int+s+%3D+sequence(i)%3B%0A++++++++if+(s+%3E+max)+%7B%0A++++++++++++max+%3D+s%3B%0A++++++++++++maxi+%3D+i%3B%0A++++++++%7D%0A++++%7D%0A++++cout+%3C%3C+maxi+%3C%3C+endl%3B%0A%7D%0A%0A//+as+discussed,+gcc+-O0+still+uses+a+multiplicative+inverse%0A//+for+non-power-of-2+constants%0Aunsigned+long+div_by_13(unsigned+long+a)+%7B%0A++return+a/13%3B%0A%7D%0A'),l:'5',n:'1',o:'C%2B%2B+source+%231',t:'0')),k:40.81295963439001,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:g540,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),options:'-O0+-std%3Dgnu%2B%2B11+-Wall+-Wextra+-fverbose-asm'),l:'5',n:'0',o:'%231+with+x86-64+gcc+5.4',t:'0')),k:31.237103409492676,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:g540,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),options:'-O3+-std%3Dgnu%2B%2B11+-Wall+-Wextra+-fno-verbose-asm'),l:'5',n:'0',o:'%231+with+x86-64+gcc+5.4',t:'0')),k:27.94993695611732,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4\"\
    \ rel=\"noreferrer\">Godbolt compiler explorer</a>), it only uses shifts instructions</strong>.\
    \ clang <code>-O0</code> does compile naively like you thought, even using 64-bit\
    \ IDIV twice. (When optimizing, compilers do use both outputs of IDIV when the\
    \ source does a division and modulus with the same operands, if they use IDIV\
    \ at all)</p>\n<p>GCC doesn't have a totally-naive mode; <a href=\"https://stackoverflow.com/a/33284629/224132\"\
    >it always transforms through GIMPLE, which means some \"optimizations\" can't\
    \ be disabled</a>.  This includes recognizing division-by-constant and using shifts\
    \ (power of 2) or <a href=\"https://stackoverflow.com/questions/41183935/why-does-gcc-use-multiplication-by-a-strange-number-in-implementing-integer-divi\"\
    >a fixed-point multiplicative inverse</a> (non power of 2) to avoid IDIV (see\
    \ <code>div_by_13</code> in the above godbolt link).</p>\n<p><code>gcc -Os</code>\
    \ (optimize for size) <em>does</em> use IDIV for non-power-of-2 division,\nunfortunately\
    \ even in cases where the multiplicative inverse code is only slightly larger\
    \ but much faster.</p>\n<hr/>\n<h1>Helping the compiler</h1>\n<p>(summary for\
    \ this case: use <code>uint64_t n</code>)</p>\n<p>First of all, it's only interesting\
    \ to look at optimized compiler output.  (<code>-O3</code>).  <strong><a href=\"\
    https://stackoverflow.com/a/32001196/224132\"><code>-O0</code> speed is basically\
    \ meaningless.</a></strong></p>\n<p>Look at your asm output (on Godbolt, or see\
    \ <a href=\"https://stackoverflow.com/q/38552116/224132\">How to remove \"noise\"\
    \ from GCC/clang assembly output?</a>).  When the compiler doesn't make optimal\
    \ code in the first place: <strong>Writing your C/C++ source in a way that guides\
    \ the compiler into making better code is usually the best approach</strong>.\
    \  You have to know asm, and know what's efficient, but you apply this knowledge\
    \ indirectly.  Compilers are also a good source of ideas: sometimes clang will\
    \ do something cool, and you can hand-hold gcc into doing the same thing: see\
    \ <a href=\"https://stackoverflow.com/a/34410357/224132\">this answer</a> and\
    \ what I did with the non-unrolled loop in @Veedrac's code below.)</p>\n<p>This\
    \ approach is portable, and in 20 years some future compiler can compile it to\
    \ whatever is efficient on future hardware (x86 or not), maybe using new ISA extension\
    \ or auto-vectorizing.  Hand-written x86-64 asm from 15 years ago would usually\
    \ not be optimally tuned for Skylake.  e.g. compare&amp;branch macro-fusion didn't\
    \ exist back then.  <strong>What's optimal now for hand-crafted asm for one microarchitecture\
    \ might not be optimal for other current and future CPUs.</strong> <a href=\"\
    https://stackoverflow.com/questions/40354978/why-is-this-c-code-faster-than-my-hand-written-assembly-for-testing-the-collat#comment67966852_40356449\"\
    >Comments on @johnfound's answer</a> discuss major differences between AMD Bulldozer\
    \ and Intel Haswell, which have a big effect on this code.  But in theory, <code>g++\
    \ -O3 -march=bdver3</code> and <code>g++ -O3 -march=skylake</code> will do the\
    \ right thing.  (Or <code>-march=native</code>.)   Or <code>-mtune=...</code>\
    \ to just tune, without using instructions that other CPUs might not support.</p>\n\
    <p>My feeling is that guiding the compiler to asm that's good for a current CPU\
    \ you care about shouldn't be a problem for future compilers.  They're hopefully\
    \ better than current compilers at finding ways to transform code, and can find\
    \ a way that works for future CPUs.  Regardless, future x86 probably won't be\
    \ terrible at anything that's good on current x86, and the future compiler will\
    \ avoid any asm-specific pitfalls while implementing something like the data movement\
    \ from your C source, if it doesn't see something better.</p>\n<p>Hand-written\
    \ asm is a black-box for the optimizer, so constant-propagation doesn't work when\
    \ inlining makes an input a compile-time constant.  Other optimizations are also\
    \ affected.  Read <a href=\"https://gcc.gnu.org/wiki/DontUseInlineAsm\" rel=\"\
    noreferrer\">https://gcc.gnu.org/wiki/DontUseInlineAsm</a> before using asm. \
    \ (And avoid MSVC-style inline asm: inputs/outputs have to go through memory <a\
    \ href=\"https://stackoverflow.com/a/35959859/224132\">which adds overhead</a>.)</p>\n\
    <p><strong>In this case</strong>: your <code>n</code> has a signed type, and gcc\
    \ uses the SAR/SHR/ADD sequence that gives the correct rounding.  (IDIV and arithmetic-shift\
    \ \"round\" differently for negative inputs, see the <a href=\"http://www.felixcloutier.com/x86/SAL:SAR:SHL:SHR.html\"\
    \ rel=\"noreferrer\">SAR insn set ref manual entry</a>).  (IDK if gcc tried and\
    \ failed to prove that <code>n</code> can't be negative, or what.  Signed-overflow\
    \ is undefined behaviour, so it should have been able to.)</p>\n<p>You should\
    \ have used <code>uint64_t n</code>, so it can just SHR.  And so it's portable\
    \ to systems where <code>long</code> is only 32-bit (e.g. x86-64 Windows).</p>\n\
    <hr/>\n<p>BTW, <strong>gcc's <em>optimized</em> asm output looks pretty good (using\
    \ <code>unsigned long n</code>)</strong>: the inner loop it inlines into <code>main()</code>\
    \ does this:</p>\n<pre><code> # from gcc5.4 -O3  plus my comments\n\n # edx= count=1\n\
    \ # rax= uint64_t n\n\n.L9:                   # do{\n    lea    rcx, [rax+1+rax*2]\
    \   # rcx = 3*n + 1\n    mov    rdi, rax\n    shr    rdi         # rdi = n&gt;&gt;1;\n\
    \    test   al, 1       # set flags based on n%2 (aka n&amp;1)\n    mov    rax,\
    \ rcx\n    cmove  rax, rdi    # n= (n%2) ? 3*n+1 : n/2;\n    add    edx, 1   \
    \   # ++count;\n    cmp    rax, 1\n    jne   .L9          #}while(n!=1)\n\n  cmp/branch\
    \ to update max and maxi, and then do the next n\n</code></pre>\n<p>The inner\
    \ loop is branchless, and the critical path of the loop-carried dependency chain\
    \ is:</p>\n<ul>\n<li>3-component LEA (3 cycles)</li>\n<li>cmov (2 cycles on Haswell,\
    \ 1c on Broadwell or later).</li>\n</ul>\n<p><strong>Total: 5 cycle per iteration,\
    \ latency bottleneck</strong>.  Out-of-order execution takes care of everything\
    \ else in parallel with this (in theory: I haven't tested with perf counters to\
    \ see if it really runs at 5c/iter).</p>\n<p>The FLAGS input of <code>cmov</code>\
    \ (produced by TEST) is faster to produce than the RAX input (from LEA-&gt;MOV),\
    \ so it's not on the critical path.</p>\n<p>Similarly, the MOV-&gt;SHR that produces\
    \ CMOV's RDI input is off the critical path, because it's also faster than the\
    \ LEA.  MOV on IvyBridge and later has zero latency (handled at register-rename\
    \ time).  (It still takes a uop, and a slot in the pipeline, so it's not free,\
    \ just zero latency).  The extra MOV in the LEA dep chain is part of the bottleneck\
    \ on other CPUs.</p>\n<p>The cmp/jne is also not part of the critical path: it's\
    \ not loop-carried, because control dependencies are handled with branch prediction\
    \ + speculative execution, unlike data dependencies on the critical path.</p>\n\
    <hr/>\n<h1>Beating the compiler</h1>\n<p>GCC did a pretty good job here.  It could\
    \ save one code byte by using <a href=\"https://stackoverflow.com/a/36510865/224132\"\
    ><code>inc edx</code> instead of <code>add edx, 1</code></a>, because nobody cares\
    \ about P4 and its false-dependencies for partial-flag-modifying instructions.</p>\n\
    <p>It could also save all the MOV instructions, and the TEST:  SHR sets CF= the\
    \ bit shifted out, so we can use <code>cmovc</code> instead of <code>test</code>\
    \ / <code>cmovz</code>.</p>\n<pre><code> ### Hand-optimized version of what gcc\
    \ does\n.L9:                       #do{\n    lea     rcx, [rax+1+rax*2] # rcx\
    \ = 3*n + 1\n    shr     rax, 1         # n&gt;&gt;=1;    CF = n&amp;1 = n%2\n\
    \    cmovc   rax, rcx       # n= (n&amp;1) ? 3*n+1 : n/2;\n    inc     edx   \
    \         # ++count;\n    cmp     rax, 1\n    jne     .L9            #}while(n!=1)\n\
    </code></pre>\n<p>See @johnfound's answer for another clever trick: remove the\
    \ CMP by branching on SHR's flag result as well as using it for CMOV:  zero only\
    \ if n was 1 (or 0) to start with.  (Fun fact: <a href=\"https://stackoverflow.com/a/36510865/224132\"\
    >SHR with count != 1 on Nehalem or earlier causes a stall if you read the flag\
    \ results</a>.  That's how they made it single-uop.  The shift-by-1 special encoding\
    \ is fine, though.)</p>\n<p>Avoiding MOV doesn't help with the latency at all\
    \ on Haswell (<a href=\"https://stackoverflow.com/q/44169342\">Can x86's MOV really\
    \ be \"free\"? Why can't I reproduce this at all?</a>).  It does help <em>significantly</em>\
    \ on CPUs like Intel pre-IvB, and AMD Bulldozer-family, where MOV is not zero-latency.\
    \  The compiler's wasted MOV instructions do affect the critical path.  BD's complex-LEA\
    \ and CMOV are both lower latency (2c and 1c respectively), so it's a bigger fraction\
    \ of the latency.  Also, throughput bottlenecks become an issue, because it only\
    \ has two integer ALU pipes.  <a href=\"https://stackoverflow.com/questions/40354978/why-is-this-c-code-faster-than-assembly/40356449#40356449\"\
    >See @johnfound's answer</a>, where he has timing results from an AMD CPU.</p>\n\
    <p>Even on Haswell, this version may help a bit by avoiding some occasional delays\
    \ where a non-critical uop steals an execution port from one on the critical path,\
    \ delaying execution by 1 cycle.  (This is called a resource conflict).  It also\
    \ saves a register, which may help when doing multiple <code>n</code> values in\
    \ parallel in an interleaved loop (see below).</p>\n<p><strong>LEA's latency depends\
    \ on the addressing mode</strong>, on Intel SnB-family CPUs.  3c for 3 components\
    \ (<code>[base+idx+const]</code>, which takes two separate adds), but only 1c\
    \ with 2 or fewer components (one add).  Some CPUs (like Core2) do even a 3-component\
    \ LEA in a single cycle, but SnB-family doesn't.  Worse, <a href=\"https://stackoverflow.com/a/40212446/224132\"\
    >Intel SnB-family standardizes latencies so there are no 2c uops</a>, otherwise\
    \ 3-component LEA would be only 2c like Bulldozer.  (3-component LEA is slower\
    \ on AMD as well, just not by as much).</p>\n<p>So <code>lea  rcx, [rax + rax*2]</code>\
    \ / <code>inc rcx</code> is only 2c latency, faster than <code>lea  rcx, [rax\
    \ + rax*2 + 1]</code>, on Intel SnB-family CPUs like Haswell.  Break-even on BD,\
    \ and worse on Core2.  It does cost an extra uop, which normally isn't worth it\
    \ to save 1c latency, but latency is the major bottleneck here and Haswell has\
    \ a wide enough pipeline to handle the extra uop throughput.</p>\n<p><strong>Neither\
    \ gcc, icc, nor clang (on godbolt) used SHR's CF output, always using an AND or\
    \ TEST</strong>.  Silly compilers. :P  They're great pieces of complex machinery,\
    \ but a clever human can often beat them on small-scale problems.  (Given thousands\
    \ to millions of times longer to think about it, of course!  Compilers don't use\
    \ exhaustive algorithms to search for every possible way to do things, because\
    \ that would take too long when optimizing a lot of inlined code, which is what\
    \ they do best.  They also don't model the pipeline in the target microarchitecture,\
    \ at least not in the same detail as <a href=\"https://stackoverflow.com/questions/26021337/what-is-iaca-and-how-do-i-use-it\"\
    >IACA</a> or other static-analysis tools; they just use some heuristics.)</p>\n\
    <hr/>\n<p><strong>Simple loop unrolling won't help</strong>; this loop bottlenecks\
    \ on the latency of a loop-carried dependency chain, not on loop overhead / throughput.\
    \  This means it would do well with hyperthreading (or any other kind of SMT),\
    \ since the CPU has lots of time to interleave instructions from two threads.\
    \  This would mean parallelizing the loop in <code>main</code>, but that's fine\
    \ because each thread can just check a range of <code>n</code> values and produce\
    \ a pair of integers as a result.</p>\n<p><strong>Interleaving by hand within\
    \ a single thread might be viable, too</strong>.  Maybe compute the sequence for\
    \ a pair of numbers in parallel, since each one only takes a couple registers,\
    \ and they can all update the same <code>max</code> / <code>maxi</code>.  This\
    \ creates more <a href=\"https://en.wikipedia.org/wiki/Instruction-level_parallelism\"\
    \ rel=\"noreferrer\">instruction-level parallelism</a>.</p>\n<p>The trick is deciding\
    \ whether to wait until all the <code>n</code> values have reached <code>1</code>\
    \ before getting another pair of starting <code>n</code> values, or whether to\
    \ break out and get a new start point for just one that reached the end condition,\
    \ without touching the registers for the other sequence.  Probably it's best to\
    \ keep each chain working on useful data, otherwise you'd have to conditionally\
    \ increment its counter.</p>\n<hr/>\n<p>You could maybe even do this with SSE\
    \ packed-compare stuff to conditionally increment the counter for vector elements\
    \ where <code>n</code> hadn't reached <code>1</code> yet.  And then to hide the\
    \ even longer latency of a SIMD conditional-increment implementation, you'd need\
    \ to keep more vectors of <code>n</code> values up in the air.  Maybe only worth\
    \ with 256b vector (4x <code>uint64_t</code>).</p>\n<p>I think the best strategy\
    \ to make detection of a <code>1</code> \"sticky\" is to mask the vector of all-ones\
    \ that you add to increment the counter.  So after you've seen a <code>1</code>\
    \ in an element, the increment-vector will have a zero, and +=0 is a no-op.</p>\n\
    <h3>Untested idea for manual vectorization</h3>\n<pre><code># starting with YMM0\
    \ = [ n_d, n_c, n_b, n_a ]  (64-bit elements)\n# ymm4 = _mm256_set1_epi64x(1):\
    \  increment vector\n# ymm5 = all-zeros:  count vector\n\n.inner_loop:\n    vpaddq\
    \    ymm1, ymm0, xmm0\n    vpaddq    ymm1, ymm1, xmm0\n    vpaddq    ymm1, ymm1,\
    \ set1_epi64(1)     # ymm1= 3*n + 1.  Maybe could do this more efficiently?\n\n\
    \    vprllq    ymm3, ymm0, 63                # shift bit 1 to the sign bit\n\n\
    \    vpsrlq    ymm0, ymm0, 1                 # n /= 2\n\n    # There may be a\
    \ better way to do this blend, avoiding the bypass delay for an FP blend between\
    \ integer insns, not sure.  Probably worth it\n    vpblendvpd ymm0, ymm0, ymm1,\
    \ ymm3       # variable blend controlled by the sign bit of each 64-bit element.\
    \  I might have the source operands backwards, I always have to look this up.\n\
    \n    # ymm0 = updated n  in each element.\n\n    vpcmpeqq ymm1, ymm0, set1_epi64(1)\n\
    \    vpandn   ymm4, ymm1, ymm4         # zero out elements of ymm4 where the compare\
    \ was true\n\n    vpaddq   ymm5, ymm5, ymm4         # count++ in elements where\
    \ n has never been == 1\n\n    vptest   ymm4, ymm4\n    jnz  .inner_loop\n   \
    \ # Fall through when all the n values have reached 1 at some point, and our increment\
    \ vector is all-zero\n\n    vextracti128 ymm0, ymm5, 1\n    vpmaxq .... crap this\
    \ doesn't exist\n    # Actually just delay doing a horizontal max until the very\
    \ very end.  But you need some way to record max and maxi.\n</code></pre>\n<p>You\
    \ can and should implement this with intrinsics, instead of hand-written asm.</p>\n\
    <hr/>\n<h2>Algorithmic / implementation improvement:</h2>\n<p>Besides just implementing\
    \ the same logic with more efficient asm, look for ways to simplify the logic,\
    \ or avoid redundant work.  e.g. memoize to detect common endings to sequences.\
    \  Or even better, look at 8 trailing bits at once (gnasher's answer)</p>\n<p>@EOF\
    \ points out that <code>tzcnt</code> (or <code>bsf</code>) could be used to do\
    \ multiple <code>n/=2</code> iterations in one step.  That's probably better than\
    \ SIMD vectorizing, because no SSE or AVX instruction can do that.  It's still\
    \ compatible with doing multiple scalar <code>n</code>s in parallel in different\
    \ integer registers, though.</p>\n<p>So the loop might look like this:</p>\n<pre><code>goto\
    \ loop_entry;  // C++ structured like the asm, for illustration only\ndo {\n \
    \  n = n*3 + 1;\n  loop_entry:\n   shift = _tzcnt_u64(n);\n   n &gt;&gt;= shift;\n\
    \   count += shift;\n} while(n != 1);\n</code></pre>\n<p>This may do significantly\
    \ fewer iterations, but variable-count shifts are slow on Intel SnB-family CPUs\
    \ without BMI2.  3 uops, 2c latency.  (They have an input dependency on the FLAGS\
    \ because count=0 means the flags are unmodified.  They handle this as a data\
    \ dependency, and take multiple uops because a uop can only have 2 inputs (pre-HSW/BDW\
    \ anyway)).  This is the kind that people complaining about x86's crazy-CISC design\
    \ are referring to.  It makes x86 CPUs slower than they would be if the ISA was\
    \ designed from scratch today, even in a mostly-similar way.  (i.e. this is part\
    \ of the \"x86 tax\" that costs speed / power.)  SHRX/SHLX/SARX (BMI2) are a big\
    \ win (1 uop / 1c latency).</p>\n<p>It also puts tzcnt (3c on Haswell and later)\
    \ on the critical path, so it significantly lengthens the total latency of the\
    \ loop-carried dependency chain.  It does remove any need for a CMOV, or for preparing\
    \ a register holding <code>n&gt;&gt;1</code>, though.  <strong>@Veedrac's answer\
    \ overcomes all this by deferring the tzcnt/shift for multiple iterations, which\
    \ is highly effective (see below).</strong></p>\n<p>We can safely use <a href=\"\
    http://www.felixcloutier.com/x86/BSF.html\" rel=\"noreferrer\">BSF</a> or <a href=\"\
    http://www.felixcloutier.com/x86/TZCNT.html\" rel=\"noreferrer\">TZCNT</a> interchangeably,\
    \ because <code>n</code> can never be zero at that point.  TZCNT's machine-code\
    \ decodes as BSF on CPUs that don't support BMI1.  (Meaningless prefixes are ignored,\
    \ so REP BSF runs as BSF).</p>\n<p>TZCNT performs much better than BSF on AMD\
    \ CPUs that support it,  so it can be a good idea to use <code>REP BSF</code>,\
    \ even if you don't care about setting ZF if the input is zero rather than the\
    \ output.  Some compilers do this when you use <code>__builtin_ctzll</code> even\
    \ with <code>-mno-bmi</code>.  </p>\n<p>They perform the same on Intel CPUs, so\
    \ just save the byte if that's all that matters.  TZCNT on Intel (pre-Skylake)\
    \ still has a false-dependency on the supposedly write-only output operand, just\
    \ like BSF, to support the undocumented behaviour that BSF with input = 0 leaves\
    \ its destination unmodified.  So you need to work around that unless optimizing\
    \ only for Skylake, so there's nothing to gain from the extra REP byte.  (Intel\
    \ often goes above and beyond what the x86 ISA manual requires, to avoid breaking\
    \ widely-used code that depends on something it shouldn't, or that is retroactively\
    \ disallowed.  e.g. <a href=\"http://blog.stuffedcow.net/2015/08/pagewalk-coherence/\"\
    \ rel=\"noreferrer\">Windows 9x's assumes no speculative prefetching of TLB entries</a>,\
    \ which was safe when the code was written, <a href=\"https://stackoverflow.com/questions/17395557/observing-stale-instruction-fetching-on-x86-with-self-modifying-code#comment68191467_18388700\"\
    >before Intel updated the TLB management rules</a>.)</p>\n<p>Anyway, LZCNT/TZCNT\
    \ on Haswell have the same false dep as POPCNT: see <a href=\"https://stackoverflow.com/questions/25078285/replacing-a-32-bit-loop-count-variable-with-64-bit-introduces-crazy-performance\"\
    >this Q&amp;A</a>.  This is why in gcc's asm output for @Veedrac's code, you see\
    \ it <a href=\"https://stackoverflow.com/a/33668295/224132\">breaking the dep\
    \ chain with xor-zeroing</a> on the register it's about to use as TZCNT's destination,\
    \ when it doesn't use dst=src.  Since TZCNT/LZCNT/POPCNT never leave their destination\
    \ undefined or unmodified, this false dependency on the output on Intel CPUs is\
    \ purely a performance bug / limitation.  Presumably it's worth some transistors\
    \ / power to have them behave like other uops that go to the same execution unit.\
    \  The only software-visible upside is in the interaction with another microarchitectural\
    \ limitation: <a href=\"https://stackoverflow.com/questions/26046634/micro-fusion-and-addressing-modes\"\
    >they can micro-fuse a memory operand with an indexed addressing mode</a> on Haswell,\
    \ but on Skylake where Intel removed the false dependency for LZCNT/TZCNT they\
    \ \"un-laminate\" indexed addressing modes while POPCNT can still micro-fuse any\
    \ addr mode.</p>\n<hr/>\n<h1>Improvements to ideas / code from other answers:</h1>\n\
    <p><strong>@hidefromkgb's answer</strong> has a nice observation that you're guaranteed\
    \ to be able to do one right shift after a 3n+1.  You can compute this more even\
    \ more efficiently than just leaving out the checks between steps.  The asm implementation\
    \ in that answer is broken, though (it depends on OF, which is undefined after\
    \ SHRD with a count &gt; 1), and slow: <code>ROR rdi,2</code> is faster than <code>SHRD\
    \ rdi,rdi,2</code>, and using two CMOV instructions on the critical path is slower\
    \ than an extra TEST that can run in parallel.</p>\n<p>I put tidied / improved\
    \ C (which guides the compiler to produce better asm), and tested+working faster\
    \ asm (in comments below the C) up on Godbolt: see the link in <a href=\"https://stackoverflow.com/questions/40354978/why-is-this-c-code-faster-than-my-hand-written-assembly-for-testing-the-collat/40367384#40367384\"\
    >@hidefromkgb's answer</a>.  (This answer hit the 30k char limit from the large\
    \ Godbolt URLs, but <a href=\"https://meta.stackoverflow.com/questions/319549/how-are-we-supposed-to-post-godbolt-links-now-that-url-shortening-is-blocked/319594#319594\"\
    >shortlinks can rot</a> and were too long for goo.gl anyway.)</p>\n<p>Also improved\
    \ the output-printing to convert to a string and make one <code>write()</code>\
    \ instead of writing one char at a time. This minimizes impact on timing the whole\
    \ program with <code>perf stat ./collatz</code> (to record performance counters),\
    \ and I de-obfuscated some of the non-critical asm.</p>\n<hr/>\n<p><strong>@Veedrac's\
    \ code</strong></p>\n<p>I got a very small speedup from right-shifting as much\
    \ as we <em>know</em> needs doing, and checking to continue the loop.  From 7.5s\
    \ for limit=1e8 down to 7.275s, on Core2Duo (Merom), with an unroll factor of\
    \ 16.</p>\n<p>code + comments <a href=\"http://gcc.godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZTUAHAvVAOwGdK0AbVAV2J4OmAIIcAtiADkABmmk0Exnh6YA8mwDCCAIZtgmGfICUpDgOLIj0gPS2A1BIx4AZnkzoHAN0zEOrGwOqK4OAGqYnsS6yGDSHA5oWCAApLKi9omCxJhsBD5%2BAeyJqMqqmAkA7pg8PA6VhAgOwMjIaRmOAMoAMuoA6g5a6gAi2A59AJIAKgASg92iAHIA4g4QmAAeBNEOAFIAsgAKCXhBBAiYDliufg58TCbt7ZnXt/eMV6gVwWyXAEZ4YAOITABAEAC0HAQbnyjFuwGIAkYpAc%2Bi87B4AE87phdL4qhcgsg%2BCIHERgr5iK4%2BJUAHRPdKZXQ8Cwo86XAIGNSQgiYD7vBz8EQJAAC0OuiIkAGtgH84glecgEGw8ABHfiYBmiFIAJgAzKdifwsA4UnqtMgOAR8HkzdgnvrDTxjZczVpWFacroJHatULTkC2N6KowYhzrWaAEJaq26FjIQWnAgANgALAB9fKc4BqND8PKmvXDByyKMOByZPMFkJkoSMBUIRH8UFki4ONjscGvYg5Lzvdqx%2BOJvJpzMOWOYzzp07pgVm4ulvWR8uZAVoNj4FjFSq6BXEDWo/Lshy5dGhY9YHi6SfoSHQ1z5fvpQd4BPrq0OP6oVB1U6e/gSLk%2BTzg4rjMiIUYxgQcavsOBB6jqY4iOquTWBA/BJghY4bCYpoAOzRukDoGq4G6YKEACqiwAErqN03TpkMVFTMR1ynJcVG0fRjHqMxDi0MmK6OPmiK1J%2B2ICQ4wigbuvJWiADh4bS%2BoJHCxD8ZgAAcTi6KcArQK0ACsykoloJCYDqwz8Kgaz7H4pS4TqtKpssMwAF6PER%2Bqnm47TluW775BheRYfkCJIumARua6RYOJxdEMUxiwsUufn%2BZkyyIpUCR/NiugycgRDqbQsi2HqawgXwwA6hAJVlbhKTYDqKSaQAnC12m0LSeGpp%2BhAcLhuJKsCAgbvS6T%2BRWjgTAQ8rjroNxSaEhCJPozRZSelLYoQfgwdujQCPkqCUtSqANAY42iJNgVwaOR0nTS6YAgQCQgcm5XgutEVRZcABU/E9RW/GyIuhFXf5N3BSmGb3X4p2VJFeDRYWxa0BR9GFloboUnDj3PRwkETeljj6NijBnbcNY6lJCT5VaTAlBuhCBApGJ5eOAZqH1WaYAQKIWPUlzIGtzI0lJ%2BRJjZx5PtqRPllDd3tijDgbIT4Py5hiH5FWwGxaDWqTZU0JcxA2wag1BFpZNUOhQ4UrK6DQmJFeBg6VK3yVCQpJJJcDTnA4abgs9dsOCAthW8TDjdLivjjveLCu%2BgZ1BK4JB3HGfiXZN5ZJ/hYNpK1GsjjD3NqwXRfwVrduGg7ZZTQ4Fw8GpoFpyJP48AG9SNFJWB5K%2BzIlCo3w1sefx8MgUparqepsb8DjTNg1HppGvRaAA0hADWGVjRGyIXFUEdzytBLqgngmwZa2P9Y8BA4v3h3vBfl9nKTbwy%2B/%2BW4azB/OIFsBby4damh1NGWKUpDRlj%2BF6SeS58LFmrmwNoIDdSgOXK/HessP7lhPrFII/1yooNLqlPCwxcL12WIsCigxxzQV5IBPI4JNiMByBwIoF9d77xeOwOI%2BRU7EEMEePQgjLhrjWmBMSh1Wz/FQAQIgEgURokFjQ1QdRfieDJDZfgjB0AZxKPmYROQ2Tfkus8Rw2cW7EAgEmKS85ZCFmXHgN04UtGI2RmWFBKC8BkMrKUFQah/CgX4LUTE4I25iXOMIFEfx%2BDaxdkCJO3wVp/F0OgLEpjzHmIXkvFe6h16bzrpkYAMibKHT8LOb8jB0ynnLH%2BXkKTgihCgbiSeHDyxZOXqvDejxUqtPnlMReHTcldLLnvNp/TsmdPyT0zBYyBk5Lyd0/OjpKI0QSjxPidoHCpnfrMiZQypn51GX0uZkzFk7OOXshZIz97tPmcM6Z08fKuGIl/eK3EkpTELGMTS5zbmnOubswZVyHlHL%2Bfss5vSwXAqWXqJ5LyVlcUSrxZKXz%2BLNUheMoF9zDk3MxXcg5vy8X/JBbik54Ky7eSZs83pL5kDpl3CIYgBAIBvKRRs80IEBIol1DqMJdQgFEBstCUEPKIXq3MZkWl9LWF%2BGZc4ypP0UYgXAYg7lOpeVsFEvy0a%2BQEkcDYDwnSBBhqBX0AQUVAKlprBVQmMAYAQLytcZgbxjhApMPUnqg10h8i5F0GPcMME6UMtlaHCA5zrp%2BHUm6bGPK%2BV6ILJ6w1Eg4zDXlRzaK6CL7qpGTMpWvo9T2lio6n6lqgEeNitTf6xakaalgfXKYIx1AKWJPoIEcJWF4AkDWhs0k/ZNE2NsfKBxjhSTOG2GWz83BWM4GbehwEdTJlPnmjlsVjq4zOk6zyubJoTinDOfsyDkHTPMSkEh9RjaYAgDgrGq6Hobp%2BmKg22dMjDBqNedRmBfBBCgfoJUFQs7ZxtlXKEMJlbpiehhHgCd0yFTcrUK9YrzE4MLYW4sIGHxq3MWWo9aH44FJJugG0QJ7bSSTnPU4UjPzQKnl5Ei/F674A4H6rmx4OyhM1e3O4FSzQADEI6TRfTZFa7Bwx8kPKiMknbfaEko2PVAE8fC6CEGapwgIwQ4ypDSADhsL1rGQxp%2BGm687nKnbU/cc7cLZlzDqjxR6YVf1oAxtwNwcgFk9BnYAHgEh8NbNJGWV8/LDBshAPUWbIy0G6ShxzacqBCnyGtC%2BBb83DC6n5ELYWIv5uwI53%2BsUr1ZYi8A5cJ8QH0bWJ0SIDc8ASlKDKOU8RUScGqGQc9r4mjMh3JiBIeqHDUytHyE4M7cRnno2nJyW6/IzDROCBAP4vDHiUH424ks3ad13BIT8u51HFBbQYOaKprBOF5rN9AqQJpCkuPlLQ%2Bx1BhA0YzTcgRRbYmioiCTOQgSzZ4ERvTKCIsok894TufAXoNPnt0Q4jWvB4lQNVzuepwSLZEwWbo2AroUa9QkZAQh4wD1DOcA2u3QDA2svWCxDgZidD6LSeNBAQB6mQBAVHohcJsBAKmBMTO0e1UeHhLQSxSEoOu7diAOpHggNEMMYYKCbthD8i0ZAClaC8qYN5tOlPqcQx1fTxnzPWfs858znnp7%2BeLEFyA4XYRRfi5XtzzLE1IzDD6LYToa9ugKQZ5%2BTAwsLuDFl8rWgpOUS0DaBNKY0ITg5QqBCYWpIry8kQZiFEHZgQVEsId9c1JXwvRpxT6blQccJ9RJIeoAhvuClJJ0GY1FwR2i0Dx8nluocOElxg%2B%2B5yFYlzYIwHLuCiv8UtZ3scbBIqNmPgVwfmsxw0h/nlrNyZMt1olY4ZNKqgQRISAhIOK01DzZsp7fwQtfHlHUodRgMTR0SeYZ%2B1gQoCj%2BECFEi/0l3Bzw7HSDvSZFYEGUMrGfK1eN2we9Q4SxLUcFiwR8oQo1Ssf9GBS0dUitOV%2B9/9zVpkAsJo%2BghF55WwBBQR8hPYgkvA/hLgmAWBk0eAUR9FVBnZW0rhqsvdZE/B5dWg0VSc1d1INcacdYdcucWdsEQBDIExZcUEq9qIUEjc9QbdLdrcZdbt%2BMMkh8fUv1x8ksC1aBMMMlrYv8S4MB0AqllCQJ8tVDssGpSsStlx1Dj1ND/JFCuNKhZ9ix8sF1F8wZrD/JwC7DZ8G9dD9DcgQDP1cgNC3DsNQFUZ%2B90Ip8CATAUD8MaDXZSMAI/hm8etA5g4UkvBCFXtUBGEthqkRBQxoheQsQUQ%2B0JN/cmNAJzBgxWw4x548gahBhDgKJutuFvUTwO4u0gxeR2h29aMagv5SxGQV9sQSBARTgB4qpXwSiDoL9YDFN/Bc8JB%2BBhoD9SR1t5DroEDy0wjCEnCF9ENrCPC9jCtACjCotTDit%2B9HMFJEsosKVYUWRNQhiOYuRMAeQxNdDgh1IAi2AUQIgogYg5pRjPMgweB0kNdm04lbAFcHBBCo5udJD%2B9pCxd%2B9ZcIBZAJsjkjiStBITi9QG8r074HACFStCsFJCSst%2BJH0jkQjOV7i4U5Z/JT1pc%2BiqUnYrMRFuNd5xUnY%2Bhvw7V5Cv4KSV1UYAETNQhhStAqTw0IZI1MYY11UPC7FXBJQDMxZSiNhlYeV5TzQVYdSpS4hM1DSSVywcgCBBAiQbMrDJpmSI5mSnYjZyhTZ9xnUngSEp5HREFnQTQ3QrRUk8A/haQEBfR0hrFk1Thp14t%2BFkAUQlQlNfpfolNgBvAxTGSgMxxk1NSQJ9Y0zIidINhHFrS4JbYOiADYpaAtIc1rZOBARfgvAchGBSzdZUYgirUIAky2hVDhgxcdkGymzlY4xYd2z%2BFvBX5wtX5Bciy%2BF0IazgA6zU84CixHYGzMYFz%2Bz3FD1IwGzeccUXicxvcti9YAVMgABNAQVaIIemD4Wops2wamYgn3UkIaJoEeWbUkPQAmVpJkRTZ0S4JOfgf1cWEo6EYaXsZY74ckQgExUZHzCIkKKuPAP/TtQgMsRCzZfsxwZqWBcEcELxYzXpLQ%2BCpCZWZCDURBS9LxS1SaIU16AtfM1MzBZ%2BfMki65JizMtC2KQs3cl%2Bd01pW0xk/i2WK6P0kAFASRaNXU9i/U4BambUiSqUzMzDUzGdczICLdLDcSldKUnldBLMTmN4tcK06XdVaSjkstLSmS3S3dLwCjcMtgfsIsOSiy6y6cEfBy1BPyPMXWG9A06QI0vyh5Xi0QaQMwHgGQQyBQNnaQWgBQVAGQLGTc8cdPV0fUGK0gOnOQEKswKUenJSVMVqTSPCVqVMNMAqvUWgPCPCUgMK6QVMBQKQEqWQUgKK%2BQBgGQBQLgJqjK0wUgOAWAJARbE/cgbgY/fxFAOJPUVqJq9wKDQoSgP4YwBQJQOdTQLERa0gfAHIQqPAfEdapMGoRaswUgwILgaQHkdAecOc/gWzcLRzcEYYVldZZKecSScEPoUWBwN6gdHYcEVwSkL8EQcEdbT69QD6ZNKwYMosNAHIHUEK6q8KyK9auKvy1Kruf2DYTSZMcENMOIoEPUWkVqWkVq7qrK0gHKnUTSZyQyVMWgVqEqEqZMVqAqnUeG2qxGzKtq6QDqkALqw63qmARAMSsofxYaiAQasa4AZMFmma3kfwea9a5aoCVazEdaza73FgXajm/amqnq469gU686y6tga6zc2gXqN6j6r6rYH6v6vwAGt44G8EUGz6iQHgNyZAAscECQP4LtamL2n2xCr28034ecDgKUTEK8d2OGmqiK5qpGmQaeRzDUzG7G3qGE5MZSBQEmkwbK%2BnVMIm1MPCWQM2vUSakqzSVMBdVmuq0gBqkGOOjm5G7m3mzKnO1m2Ghu1qpu9Kw6swSkNhdnIAA\"\
    \ rel=\"noreferrer\">on Godbolt</a>.  Don't use this version with clang; it does\
    \ something silly with the defer-loop.  Using a tmp counter <code>k</code> and\
    \ then adding it to <code>count</code> later changes what clang does, but that\
    \ <em>slightly</em> hurts gcc.</p>\n<p>See discussion in comments: Veedrac's code\
    \ is <em>excellent</em> on CPUs with BMI1 (i.e. not Celeron/Pentium)</p>\n</div>"
- - C++ code for testing the Collatz conjecture faster than hand-written assembly
    - why?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Claiming that the C++ compiler\
    \ can produce more optimal code than a competent assembly language programmer\
    \ is a very bad mistake. And especially in this case. The human always can make\
    \ the code better that the compiler can, and this particular situation is good\
    \ illustration of this claim.</p>\n<p>The timing difference you're seeing is because\
    \ the assembly code in the question is very far from optimal in the inner loops.</p>\n\
    <p>(The below code is 32-bit, but can be easily converted to 64-bit)</p>\n<p>For\
    \ example, the sequence function can be optimized to only 5 instructions:</p>\n\
    <pre><code>    .seq:\n        inc     esi                 ; counter\n        lea\
    \     edx, [3*eax+1]      ; edx = 3*n+1\n        shr     eax, 1              ;\
    \ eax = n/2\n        cmovc   eax, edx            ; if CF eax = edx\n        jnz\
    \     .seq                ; jmp if n&lt;&gt;1\n</code></pre>\n<p>The whole code\
    \ looks like:</p>\n<pre><code>include \"%lib%/freshlib.inc\"\n@BinaryType console,\
    \ compact\noptions.DebugMode = 1\ninclude \"%lib%/freshlib.asm\"\n\nstart:\n \
    \       InitializeAll\n        mov ecx, 999999\n        xor edi, edi        ;\
    \ max\n        xor ebx, ebx        ; max i\n\n    .main_loop:\n\n        xor \
    \    esi, esi\n        mov     eax, ecx\n\n    .seq:\n        inc     esi    \
    \             ; counter\n        lea     edx, [3*eax+1]      ; edx = 3*n+1\n \
    \       shr     eax, 1              ; eax = n/2\n        cmovc   eax, edx    \
    \        ; if CF eax = edx\n        jnz     .seq                ; jmp if n&lt;&gt;1\n\
    \n        cmp     edi, esi\n        cmovb   edi, esi\n        cmovb   ebx, ecx\n\
    \n        dec     ecx\n        jnz     .main_loop\n\n        OutputValue \"Max\
    \ sequence: \", edi, 10, -1\n        OutputValue \"Max index: \", ebx, 10, -1\n\
    \n        FinalizeAll\n        stdcall TerminateAll, 0\n</code></pre>\n<p>In order\
    \ to compile this code, <a href=\"https://fresh.flatassembler.net\">FreshLib</a>\
    \ is needed.</p>\n<p>In my tests, (1 GHz AMD A4-1200 processor), the above code\
    \ is approximately four times faster than the C++ code from the question (when\
    \ compiled with <code>-O0</code>: 430 ms vs. 1900 ms), and more than two times\
    \ faster (430 ms vs. 830 ms) when the C++ code is compiled with <code>-O3</code>.</p>\n\
    <p>The output of both programs is the same: max sequence = 525 on i = 837799.</p>\n\
    </div>"
- - C++ code for testing the Collatz conjecture faster than hand-written assembly
    - why?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>For more performance: A simple\
    \ change is observing that after n = 3n+1, n will be even, so you can divide by\
    \ 2 immediately. And n won't be 1, so you don't need to test for it. So you could\
    \ save a few if statements and write: </p>\n<pre><code>while (n % 2 == 0) n /=\
    \ 2;\nif (n &gt; 1) for (;;) {\n    n = (3*n + 1) / 2;\n    if (n % 2 == 0) {\n\
    \        do n /= 2; while (n % 2 == 0);\n        if (n == 1) break;\n    }\n}\n\
    </code></pre>\n<p>Here's a <em>big</em> win: If you look at the lowest 8 bits\
    \ of n, all the steps until you divided by 2 eight times are completely determined\
    \ by those eight bits. For example, if the last eight bits are 0x01, that is in\
    \ binary your number is ???? 0000 0001 then the next steps are:</p>\n<pre><code>3n+1\
    \ -&gt; ???? 0000 0100\n/ 2  -&gt; ???? ?000 0010\n/ 2  -&gt; ???? ??00 0001\n\
    3n+1 -&gt; ???? ??00 0100\n/ 2  -&gt; ???? ???0 0010\n/ 2  -&gt; ???? ???? 0001\n\
    3n+1 -&gt; ???? ???? 0100\n/ 2  -&gt; ???? ???? ?010\n/ 2  -&gt; ???? ???? ??01\n\
    3n+1 -&gt; ???? ???? ??00\n/ 2  -&gt; ???? ???? ???0\n/ 2  -&gt; ???? ???? ????\n\
    </code></pre>\n<p>So all these steps can be predicted, and 256k + 1 is replaced\
    \ with 81k + 1. Something similar will happen for all combinations. So you can\
    \ make a loop with a big switch statement: </p>\n<pre><code>k = n / 256;\nm =\
    \ n % 256;\n\nswitch (m) {\n    case 0: n = 1 * k + 0; break;\n    case 1: n =\
    \ 81 * k + 1; break; \n    case 2: n = 81 * k + 1; break; \n    ...\n    case\
    \ 155: n = 729 * k + 425; break;\n    ...\n}\n</code></pre>\n<p>Run the loop until\
    \ n ≤ 128, because at that point n could become 1 with fewer than eight divisions\
    \ by 2, and doing eight or more steps at a time would make you miss the point\
    \ where you reach 1 for the first time. Then continue the \"normal\" loop - or\
    \ have a table prepared that tells you how many more steps are need to reach 1.\
    \ </p>\n<p>PS. I strongly suspect Peter Cordes' suggestion would make it even\
    \ faster. There will be no conditional branches at all except one, and that one\
    \ will be predicted correctly except when the loop actually ends. So the code\
    \ would be something like</p>\n<pre><code>static const unsigned int multipliers\
    \ [256] = { ... }\nstatic const unsigned int adders [256] = { ... }\n\nwhile (n\
    \ &gt; 128) {\n    size_t lastBits = n % 256;\n    n = (n &gt;&gt; 8) * multipliers\
    \ [lastBits] + adders [lastBits];\n}\n</code></pre>\n<p>In practice, you would\
    \ measure whether processing the last 9, 10, 11, 12 bits of n at a time would\
    \ be faster. For each bit, the number of entries in the table would double, and\
    \ I excect a slowdown when the tables don't fit into L1 cache anymore. </p>\n\
    <p>PPS. If you need the number of operations: In each iteration we do exactly\
    \ eight divisions by two, and a variable number of (3n + 1) operations, so an\
    \ obvious method to count the operations would be another array. But we can actually\
    \ calculate the number of steps (based on number of iterations of the loop).</p>\n\
    <p>We could redefine the problem slightly: Replace n with (3n + 1) / 2 if odd,\
    \ and replace n with n / 2 if even. Then every iteration will do exactly 8 steps,\
    \ but you could consider that cheating :-) So assume there were r operations n\
    \ &lt;- 3n+1 and s operations n &lt;- n/2. The result will be quite exactly n'\
    \ = n * 3^r / 2^s, because n &lt;- 3n+1 means n &lt;- 3n * (1 + 1/3n). Taking\
    \ the logarithm we find r = (s + log2 (n' / n)) / log2 (3). </p>\n<p>If we do\
    \ the loop until n ≤ 1,000,000 and have a precomputed table how many iterations\
    \ are needed from any start point n ≤ 1,000,000 then calculating r as above, rounded\
    \ to the nearest integer, will give the right result unless s is truly large.\
    \ </p>\n</div>"
- - How do you declare an interface in C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>To expand on the answer by <a\
    \ href=\"https://stackoverflow.com/questions/318064/how-do-you-declare-an-interface-in-c#318084\"\
    >bradtgmurray</a>,  you may want to make one exception to the pure virtual method\
    \ list of your interface by adding a virtual destructor. This allows you to pass\
    \ pointer ownership to another party without exposing the concrete derived class.\
    \ The destructor doesn't have to do anything, because the interface doesn't have\
    \ any concrete members. It might seem contradictory to define a function as both\
    \ virtual and inline, but trust me - it isn't.</p>\n<pre><code>class IDemo\n{\n\
    \    public:\n        virtual ~IDemo() {}\n        virtual void OverrideMe() =\
    \ 0;\n};\n\nclass Parent\n{\n    public:\n        virtual ~Parent();\n};\n\nclass\
    \ Child : public Parent, public IDemo\n{\n    public:\n        virtual void OverrideMe()\n\
    \        {\n            //do stuff\n        }\n};\n</code></pre>\n<p>You don't\
    \ have to include a body for the virtual destructor - it turns out some compilers\
    \ have trouble optimizing an empty destructor and you're better off using the\
    \ default. </p>\n</div>"
- - How do you declare an interface in C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Make a class with pure virtual\
    \ methods. Use the interface by creating another class that overrides those virtual\
    \ methods.</p>\n<p>A pure virtual method is a class method that is defined as\
    \ virtual and assigned to 0.</p>\n<pre><code>class IDemo\n{\n    public:\n   \
    \     virtual ~IDemo() {}\n        virtual void OverrideMe() = 0;\n};\n\nclass\
    \ Child : public IDemo\n{\n    public:\n        virtual void OverrideMe()\n  \
    \      {\n            //do stuff\n        }\n};\n</code></pre>\n</div>"
- - How do you declare an interface in C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>The whole reason you have a special\
    \ Interface type-category in addition to abstract base classes in C#/<a href=\"\
    https://stackoverflow.com/questions/1321122/what-is-an-interface-in-java\">Java</a>\
    \ is because C#/Java do not support multiple inheritance.  </p>\n<p>C++ supports\
    \ multiple inheritance, and so a special type isn't needed.  An abstract base\
    \ class with no non-abstract (pure virtual) methods is functionally equivalent\
    \ to a C#/Java interface.</p>\n</div>"
- - What are C++ functors and their uses?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>A functor is pretty much just\
    \ a class which defines the operator(). That lets you create objects which \"\
    look like\" a function:</p>\n<pre><code>// this is a functor\nstruct add_x {\n\
    \  add_x(int x) : x(x) {}\n  int operator()(int y) const { return x + y; }\n\n\
    private:\n  int x;\n};\n\n// Now you can use it like this:\nadd_x add42(42); //\
    \ create an instance of the functor class\nint i = add42(8); // and \"call\" it\n\
    assert(i == 50); // and it added 42 to its argument\n\nstd::vector&lt;int&gt;\
    \ in; // assume this contains a bunch of values)\nstd::vector&lt;int&gt; out(in.size());\n\
    // Pass a functor to std::transform, which calls the functor on every element\
    \ \n// in the input sequence, and stores the result to the output sequence\nstd::transform(in.begin(),\
    \ in.end(), out.begin(), add_x(1)); \nassert(out[i] == in[i] + 1); // for all\
    \ i\n</code></pre>\n<p>There are a couple of nice things about functors. One is\
    \ that unlike regular functions, they can contain state. The above example creates\
    \ a function which adds 42 to whatever you give it. But that value 42 is not hardcoded,\
    \ it was specified as a constructor argument when we created our functor instance.\
    \ I could create another adder, which added 27, just by calling the constructor\
    \ with a different value. This makes them nicely customizable.</p>\n<p>As the\
    \ last lines show, you often pass functors as arguments to other functions such\
    \ as std::transform or the other standard library algorithms. You could do the\
    \ same with a regular function pointer except, as I said above, functors can be\
    \ \"customized\" because they contain state, making them more flexible (If I wanted\
    \ to use a function pointer, I'd have to write a function which added exactly\
    \ 1 to its argument. The functor is general, and adds whatever you initialized\
    \ it with), and they are also potentially more efficient. In the above example,\
    \ the compiler knows exactly which function <code>std::transform</code> should\
    \ call. It should call <code>add_x::operator()</code>. That means it can inline\
    \ that function call. And that makes it just as efficient as if I had manually\
    \ called the function on each value of the vector.</p>\n<p>If I had passed a function\
    \ pointer instead, the compiler couldn't immediately see which function it points\
    \ to, so unless it performs some fairly complex global optimizations, it'd have\
    \ to dereference the pointer at runtime, and then make the call.</p>\n</div>"
- - What are C++ functors and their uses?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Little addition. You can use\
    \ <a href=\"http://www.boost.org/doc/libs/1_51_0/doc/html/boost/function.html\"\
    \ rel=\"noreferrer\"><code>boost::function</code></a>, to create functors from\
    \ functions and methods, like this:</p>\n<pre><code>class Foo\n{\npublic:\n  \
    \  void operator () (int i) { printf(\"Foo %d\", i); }\n};\nvoid Bar(int i) {\
    \ printf(\"Bar %d\", i); }\nFoo foo;\nboost::function&lt;void (int)&gt; f(foo);//wrap\
    \ functor\nf(1);//prints \"Foo 1\"\nboost::function&lt;void (int)&gt; b(&amp;Bar);//wrap\
    \ normal function\nb(1);//prints \"Bar 1\"\n</code></pre>\n<p>and you can use\
    \ boost::bind to add state to this functor</p>\n<pre><code>boost::function&lt;void\
    \ ()&gt; f1 = boost::bind(foo, 2);\nf1();//no more argument, function argument\
    \ stored in f1\n//and this print \"Foo 2\" (:\n//and normal function\nboost::function&lt;void\
    \ ()&gt; b1 = boost::bind(&amp;Bar, 2);\nb1();// print \"Bar 2\"\n</code></pre>\n\
    <p>and most useful, with boost::bind and boost::function you can create functor\
    \ from class method, actually this is a delegate:</p>\n<pre><code>class SomeClass\n\
    {\n    std::string state_;\npublic:\n    SomeClass(const char* s) : state_(s)\
    \ {}\n\n    void method( std::string param )\n    {\n        std::cout &lt;&lt;\
    \ state_ &lt;&lt; param &lt;&lt; std::endl;\n    }\n};\nSomeClass *inst = new\
    \ SomeClass(\"Hi, i am \");\nboost::function&lt; void (std::string) &gt; callback;\n\
    callback = boost::bind(&amp;SomeClass::method, inst, _1);//create delegate\n//_1\
    \ is a placeholder it holds plase for parameter\ncallback(\"useless\");//prints\
    \ \"Hi, i am useless\"\n</code></pre>\n<p>You can create list or vector of functors</p>\n\
    <pre><code>std::list&lt; boost::function&lt;void (EventArg e)&gt; &gt; events;\n\
    //add some events\n....\n//call them\nstd::for_each(\n        events.begin(),\
    \ events.end(), \n        boost::bind( boost::apply&lt;void&gt;(), _1, e));\n\
    </code></pre>\n<p>There is one problem with all this stuff, compiler error messages\
    \ is not human readable :)</p>\n</div>"
- - What are C++ functors and their uses?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>A Functor is a object which acts\
    \ like a function.\nBasically, a class which defines <code>operator()</code>.</p>\n\
    <pre><code>class MyFunctor\n{\n   public:\n     int operator()(int x) { return\
    \ x * 2;}\n}\n\nMyFunctor doubler;\nint x = doubler(5);\n</code></pre>\n<p>The\
    \ real advantage is that a functor can hold state. </p>\n<pre><code>class Matcher\n\
    {\n   int target;\n   public:\n     Matcher(int m) : target(m) {}\n     bool operator()(int\
    \ x) { return x == target;}\n}\n\nMatcher Is5(5);\n\nif (Is5(n))    // same as\
    \ if (n == 5)\n{ ....}\n</code></pre>\n</div>"
- - What is the difference between 'typedef' and 'using' in C++11?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>They are equivalent, from the\
    \ standard (emphasis mine) (7.1.3.2):</p>\n<blockquote>\n<p>A typedef-name can\
    \ also be introduced by an alias-declaration. The\n  identifier following the\
    \ using keyword becomes a typedef-name and the\n  optional attribute-specifier-seq\
    \ following the identifier appertains\n  to that typedef-name. <strong>It has\
    \ the same semantics as if it were\n  introduced by the typedef specifier.</strong>\
    \ In particular, it\n  does not define a new type and it shall not appear in the\
    \ type-id.</p>\n</blockquote>\n</div>"
- - What is the difference between 'typedef' and 'using' in C++11?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>The <strong>using</strong> syntax\
    \ has an advantage when used within templates. If you need the type abstraction,\
    \ but also need to keep template parameter to be possible to be specified in future.\
    \ You should write something like this.</p>\n<pre><code>template &lt;typename\
    \ T&gt; struct whatever {};\n\ntemplate &lt;typename T&gt; struct rebind\n{\n\
    \  typedef whatever&lt;T&gt; type; // to make it possible to substitue the whatever\
    \ in future.\n};\n\nrebind&lt;int&gt;::type variable;\n\ntemplate &lt;typename\
    \ U&gt; struct bar { typename rebind&lt;U&gt;::type _var_member; }\n</code></pre>\n\
    <p>But <strong>using</strong> syntax simplifies this use case.</p>\n<pre><code>template\
    \ &lt;typename T&gt; using my_type = whatever&lt;T&gt;;\n\nmy_type&lt;int&gt;\
    \ variable;\ntemplate &lt;typename U&gt; struct baz { my_type&lt;U&gt; _var_member;\
    \ }\n</code></pre>\n</div>"
- - What is the difference between 'typedef' and 'using' in C++11?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>They are largely the same, except\
    \ that:</p>\n<blockquote>\n<p>The alias declaration is compatible with templates,\
    \ whereas the C\n  style typedef is not.</p>\n</blockquote>\n</div>"
- - Difference between 'struct' and 'typedef struct' in C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>In C++, there is only a subtle\
    \ difference.  It's a holdover from C, in which it makes a difference.</p>\n<p>The\
    \ C language standard (<a href=\"http://port70.net/~nsz/c/c89/c89-draft.txt\"\
    \ rel=\"noreferrer\">C89 §3.1.2.3</a>, <a href=\"http://port70.net/~nsz/c/c99/n1256.html#6.2.3\"\
    \ rel=\"noreferrer\">C99 §6.2.3</a>, and <a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.2.3\"\
    \ rel=\"noreferrer\">C11 §6.2.3</a>) mandates separate namespaces for different\
    \ categories of identifiers, including <em>tag identifiers</em> (for <code>struct</code>/<code>union</code>/<code>enum</code>)\
    \ and <em>ordinary identifiers</em> (for <code>typedef</code> and other identifiers).\
    \ </p>\n<p>If you just said:</p>\n<pre><code>struct Foo { ... };\nFoo x;\n</code></pre>\n\
    <p>you would get a compiler error, because <code>Foo</code> is only defined in\
    \ the tag namespace. </p>\n<p>You'd have to declare it as:</p>\n<pre><code>struct\
    \ Foo x;\n</code></pre>\n<p>Any time you want to refer to a <code>Foo</code>,\
    \ you'd always have to call it a <code>struct Foo</code>.  This gets annoying\
    \ fast, so you can add a <code>typedef</code>:</p>\n<pre><code>struct Foo { ...\
    \ };\ntypedef struct Foo Foo;\n</code></pre>\n<p>Now <code>struct Foo</code> (in\
    \ the tag namespace) and just plain <code>Foo</code> (in the ordinary identifier\
    \ namespace) both refer to the same thing, and you can freely declare objects\
    \ of type <code>Foo</code> without the <code>struct</code> keyword.</p>\n<hr/>\n\
    <p>The construct:</p>\n<pre><code>typedef struct Foo { ... } Foo;\n</code></pre>\n\
    <p>is just an abbreviation for the declaration and <code>typedef</code>.</p>\n\
    <hr/>\n<p>Finally,</p>\n<pre><code>typedef struct { ... } Foo;\n</code></pre>\n\
    <p>declares an anonymous structure and creates a <code>typedef</code> for it.\
    \  Thus, with this construct, it doesn't have a name in the tag namespace, only\
    \ a name in the typedef namespace.  This means it also cannot be forward-declared.\
    \  <em>If you want to make a forward declaration, you have to give it a name in\
    \ the tag namespace</em>.</p>\n<hr/>\n<p>In C++, all <code>struct</code>/<code>union</code>/<code>enum</code>/<code>class</code>\
    \ declarations act like they are implicitly <code>typedef</code>'ed, as long as\
    \ the name is not hidden by another declaration with the same name.  See <a href=\"\
    https://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c/612476#612476\"\
    >Michael Burr's answer</a> for the full details.</p>\n</div>"
- - Difference between 'struct' and 'typedef struct' in C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>In <a href=\"http://drdobbs.com/article/print?articleId=184403396\"\
    \ rel=\"noreferrer\">this DDJ article</a>, Dan Saks explains one small area where\
    \ bugs can creep through if you do not typedef your structs (and classes!):</p>\n\
    <blockquote>\n<p>If you want, you can imagine that C++\n  generates a typedef\
    \ for every tag\n  name, such as</p>\n<pre><code>typedef class string string;\n\
    </code></pre>\n<p>Unfortunately, this is not entirely\n  accurate. I wish it were\
    \ that simple,\n  but it's not. C++ can't generate such\n  typedefs for structs,\
    \ unions, or enums\n  without introducing incompatibilities\n  with C.</p>\n<p>For\
    \ example, suppose a C program\n  declares both a function and a struct\n  named\
    \ status:</p>\n<pre><code>int status(); struct status;\n</code></pre>\n<p>Again,\
    \ this may be bad practice, but\n  it is C. In this program, status (by\n  itself)\
    \ refers to the function; struct\n  status refers to the type.</p>\n<p>If C++\
    \ did automatically generate\n  typedefs for tags, then when you\n  compiled this\
    \ program as C++, the\n  compiler would generate:</p>\n<pre><code>typedef struct\
    \ status status;\n</code></pre>\n<p>Unfortunately, this type name would\n  conflict\
    \ with the function name, and\n  the program would not compile. That's\n  why\
    \ C++ can't simply generate a\n  typedef for each tag.</p>\n<p>In C++, tags act\
    \ just like typedef\n  names, except that a program can\n  declare an object,\
    \ function, or\n  enumerator with the same name and the\n  same scope as a tag.\
    \ In that case, the\n  object, function, or enumerator name\n  hides the tag name.\
    \ The program can\n  refer to the tag name only by using\n  the keyword class,\
    \ struct, union, or\n  enum (as appropriate) in front of the\n  tag name. A type\
    \ name consisting of\n  one of these keywords followed by a\n  tag is an elaborated-type-specifier.\n\
    \  For instance, struct status and enum\n  month are elaborated-type-specifiers.\
    \ </p>\n<p>Thus, a C program that contains both:</p>\n<pre><code>int status();\
    \ struct status;\n</code></pre>\n<p>behaves the same when compiled as C++.\n \
    \ The name status alone refers to the\n  function. The program can refer to the\n\
    \  type only by using the\n  elaborated-type-specifier struct\n  status.</p>\n\
    <p>So how does this allow bugs to creep\n  into programs? Consider the program\
    \ in\n  <a href=\"http://drdobbs.com/cpp/184403396?pgno=1\" rel=\"noreferrer\"\
    >Listing 1</a>. This program defines a\n  class foo with a default constructor,\n\
    \  and a conversion operator that\n  converts a foo object to char const *.\n\
    \  The expression</p>\n<pre><code>p = foo();\n</code></pre>\n<p>in main should\
    \ construct a foo object\n  and apply the conversion operator. The\n  subsequent\
    \ output statement</p>\n<pre><code>cout &lt;&lt; p &lt;&lt; '\\n';\n</code></pre>\n\
    <p>should display class foo, but it\n  doesn't. It displays function foo.</p>\n\
    <p>This surprising result occurs because\n  the program includes header lib.h\n\
    \  shown in <a href=\"http://drdobbs.com/cpp/184403396?pgno=2\" rel=\"noreferrer\"\
    >Listing 2</a>. This header\n  defines a function also named foo. The\n  function\
    \ name foo hides the class name\n  foo, so the reference to foo in main\n  refers\
    \ to the function, not the class.\n  main can refer to the class only by\n  using\
    \ an elaborated-type-specifier, as\n  in</p>\n<pre><code>p = class foo();\n</code></pre>\n\
    <p>The way to avoid such confusion\n  throughout the program is to add the\n \
    \ following typedef for the class name\n  foo:</p>\n<pre><code>typedef class foo\
    \ foo;\n</code></pre>\n<p>immediately before or after the class\n  definition.\
    \ This typedef causes a\n  conflict between the type name foo and\n  the function\
    \ name foo (from the\n  library) that will trigger a\n  compile-time error.</p>\n\
    <p>I know of no one who actually writes\n  these typedefs as a matter of course.\n\
    \  It requires a lot of discipline. Since\n  the incidence of errors such as the\n\
    \  one in <a href=\"http://drdobbs.com/cpp/184403396?pgno=1\" rel=\"noreferrer\"\
    >Listing 1</a> is probably pretty\n  small, you many never run afoul of\n  this\
    \ problem. But if an error in your\n  software might cause bodily injury,\n  then\
    \ you should write the typedefs no\n  matter how unlikely the error. </p>\n<p>I\
    \ can't imagine why anyone would ever\n  want to hide a class name with a\n  function\
    \ or object name in the same\n  scope as the class. The hiding rules\n  in C were\
    \ a mistake, and they should\n  not have been extended to classes in\n  C++. Indeed,\
    \ you can correct the\n  mistake, but it requires extra\n  programming discipline\
    \ and effort that\n  should not be necessary.</p>\n</blockquote>\n</div>"
- - Difference between 'struct' and 'typedef struct' in C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>One more important difference:\
    \ <code>typedef</code>s cannot be forward declared. So for the <code>typedef</code>\
    \ option you must <code>#include</code> the file containing the <code>typedef</code>,\
    \ meaning everything that <code>#include</code>s your <code>.h</code> also includes\
    \ that file whether it directly needs it or not, and so on. It can definitely\
    \ impact your build times on larger projects.</p>\n<p>Without the <code>typedef</code>,\
    \ in some cases you can just add a forward declaration of <code>struct Foo;</code>\
    \ at the top of your <code>.h</code> file, and only <code>#include</code> the\
    \ struct definition in your <code>.cpp</code> file.</p>\n</div>"
- - What is the difference between g++ and gcc?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p><code>gcc</code> and <code>g++</code>\
    \ are compiler-drivers of the GNU Compiler <em>Collection</em> (which was once\
    \ upon a time just the GNU <em>C Compiler</em>).</p>\n<p>Even though they automatically\
    \ determine which backends (<code>cc1</code> <code>cc1plus</code> ...) to call\
    \ depending on the file-type, unless overridden with <code>-x language</code>,\
    \ they have some differences.</p>\n<p>The probably most important difference in\
    \ their defaults is which libraries they link against automatically.</p>\n<p>According\
    \ to GCC's online documentation <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html\"\
    \ rel=\"noreferrer\">link options</a> and <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Invoking-G_002b_002b.html\"\
    \ rel=\"noreferrer\">how g++ is invoked</a>, <code>g++</code> is equivalent to\
    \ <code>gcc -xc++ -lstdc++ -shared-libgcc</code> (the 1st is a compiler option,\
    \ the 2nd two are linker options). This can be checked by running both with the\
    \ <code>-v</code> option (it displays the backend toolchain commands being run).</p>\n\
    </div>"
- - What is the difference between g++ and gcc?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>GCC: GNU Compiler Collection<br/></p>\n\
    <ul>\n<li>Referrers to all the different languages that are supported by the GNU\
    \ compiler.</li>\n</ul>\n<p>gcc: GNU C      Compiler<br/>\ng++: GNU C++ Compiler<br/></p>\n\
    <p>The main differences:</p>\n<ol>\n<li>gcc will compile: *.c/*.cpp files as C\
    \ and C++ respectively.</li>\n<li>g++ will compile: *.c/*.cpp files but they will\
    \ all be treated as C++ files.</li>\n<li>Also if you use g++ to link the object\
    \ files it automatically links in the std C++ libraries (gcc does not do this).</li>\n\
    <li>gcc compiling C files has fewer predefined macros.</li>\n<li>gcc compiling\
    \ *.cpp and g++ compiling *.c/*.cpp files has a few extra macros.</li>\n</ol>\n\
    <p>Extra Macros when compiling *.cpp files:</p>\n<pre><code>#define __GXX_WEAK__\
    \ 1\n#define __cplusplus 1\n#define __DEPRECATED 1\n#define __GNUG__ 4\n#define\
    \ __EXCEPTIONS 1\n#define __private_extern__ extern\n</code></pre>\n</div>"
- - What is the difference between g++ and gcc?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>For c++ you should use g++.</p>\n\
    <p>It's the same compiler (e.g. the GNU compiler collection). GCC or G++ just\
    \ choose a different front-end with different default options.</p>\n<p>In a nutshell:\
    \ if you use g++ the frontend will tell the linker that you may want to link with\
    \ the C++ standard libraries. The gcc frontend won't do that (also it could link\
    \ with them if you pass the right command line options). </p>\n</div>"
- - How to convert std::string to lower case?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>From <a href=\"http://notfaq.wordpress.com/2007/08/04/cc-convert-string-to-upperlower-case/\"\
    \ rel=\"noreferrer\">this</a>:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include\
    \ &lt;string&gt; \n\nstd::string data = \"Abc\"; \nstd::transform(data.begin(),\
    \ data.end(), data.begin(), ::tolower);\n</code></pre>\n<p>You're really not going\
    \ to get away with iterating through each character.  There's no way to know whether\
    \ the character is lowercase or uppercase otherwise.</p>\n<p>If you really hate\
    \ <code>tolower()</code>, here's a non-portable alternative that I don't recommend\
    \ you use:</p>\n<pre><code>char easytolower(char in) {\n  if(in &lt;= 'Z' &amp;&amp;\
    \ in &gt;= 'A')\n    return in - ('Z' - 'z');\n  return in;\n}\n\nstd::transform(data.begin(),\
    \ data.end(), data.begin(), easytolower);\n</code></pre>\n<p>Be aware that <code>::tolower()</code>\
    \ can only do a per-single-byte-character substitution, which is ill-fitting for\
    \ many scripts, especially if using a multi-byte-encoding like UTF-8.</p>\n</div>"
- - How to convert std::string to lower case?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>There is a Boost string algorithm\
    \ for this:</p>\n<pre><code>#include &lt;boost/algorithm/string.hpp&gt;    \n\n\
    std::string str = \"HELLO, WORLD!\";\nboost::algorithm::to_lower(str); // modifies\
    \ str\n</code></pre>\n<p>Or, for non-in-place:</p>\n<pre><code>#include &lt;boost/algorithm/string.hpp&gt;\
    \    \n\nconst std::string str = \"HELLO, WORLD!\";\nconst std::string lower_str\
    \ = boost::algorithm::to_lower_copy(str);\n</code></pre>\n</div>"
- - How to convert std::string to lower case?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p><strong>tl;dr</strong></p>\n\
    <p><strong>Use the <a href=\"http://www.icu-project.org\" rel=\"noreferrer\">ICU\
    \ library</a>.</strong></p>\n<hr/>\n<p>First you have to answer a question: What\
    \ is the <em>encoding</em> of your <code>std::string</code>? Is it ISO-8859-1?\
    \ Or perhaps ISO-8859-8? Or Windows Codepage 1252? <em>Does whatever you're using\
    \ to convert upper-to-lowercase know that?</em> (Or does it fail miserably for\
    \ characters over <code>0x7f</code>?)</p>\n<p>If you are using UTF-8 (the only\
    \ sane choice among the 8-bit encodings) with <code>std::string</code> as container,\
    \ you are already deceiving yourself into believing that you are still in control\
    \ of things, because you are storing a multibyte character sequence in a container\
    \ that is not aware of the multibyte concept. Even something as simple as <code>.substr()</code>\
    \ is a ticking timebomb. (Because splitting a multibyte sequence will result in\
    \ an invalid (sub-) string.)</p>\n<p>And as soon as you try something like <code>std::toupper(\
    \ 'ß' )</code>, in <em>any</em> encoding, you are in deep trouble. (Because it's\
    \ simply not possible to do this \"right\" with the standard library, which can\
    \ only deliver <em>one</em> result character, not the <code>\"SS\"</code> needed\
    \ here.) [1] Another example would be <code>std::tolower( 'I' )</code>, which\
    \ should yield different results <em>depending on the locale</em>. In Germany,\
    \ <code>'i'</code> would be correct; in Turkey, <code>'ı'</code> (LATIN SMALL\
    \ LETTER DOTLESS I) is the expected result.</p>\n<p>Then there is the point that\
    \ the standard library is depending on which locales are <em>supported</em> on\
    \ the machine your software is running on... and what do you do if it isn't?</p>\n\
    <p>So what you are <em>really</em> looking for is a string class that is capable\
    \ of dealing with all this correctly, <strong>and that is <em>not</em> <code>std::string</code></strong>.</p>\n\
    <p>(C++11 note: <code>std::u16string</code> and <code>std::u32string</code> are\
    \ <em>better</em>, but still not perfect.)</p>\n<p>While Boost <em>looks</em>\
    \ nice, API wise, Boost.Locale is basically a wrapper around <a href=\"http://www.icu-project.org\"\
    \ rel=\"noreferrer\">ICU</a>. <strong>If</strong> Boost is <em>compiled</em> with\
    \ ICU support... if it isn't, Boost.Locale is limited to the locale support compiled\
    \ for the standard library.</p>\n<p>And believe me, <em>getting</em> Boost to\
    \ compile with ICU can be a real pain sometimes. (There are no pre-compiled binaries\
    \ for Windows, so you'd have to supply them together with your application, and\
    \ <em>that</em> opens a whole new can of worms...)</p>\n<p>So personally I would\
    \ recommend getting full Unicode support straight from the horse's mouth and using\
    \ the <a href=\"http://www.icu-project.org\" rel=\"noreferrer\">ICU</a> library\
    \ directly:</p>\n<pre><code>#include &lt;unicode/unistr.h&gt;\n#include &lt;unicode/ustream.h&gt;\n\
    #include &lt;unicode/locid.h&gt;\n\n#include &lt;iostream&gt;\n\nint main()\n\
    {\n    char const * someString = \"Eidenges\\xe4\\xdf\";\n    icu::UnicodeString\
    \ someUString( someString, \"ISO-8859-1\" );\n    // Setting the locale explicitly\
    \ here for completeness.\n    // Usually you would use the user-specified system\
    \ locale.\n    std::cout &lt;&lt; someUString.toLower( \"de_DE\" ) &lt;&lt; \"\
    \\n\";\n    std::cout &lt;&lt; someUString.toUpper( \"de_DE\" ) &lt;&lt; \"\\\
    n\";\n    return 0;\n}\n</code></pre>\n<p>Compile (with G++ in this example):</p>\n\
    <pre><code>g++ -Wall example.cpp -licuuc -licuio\n</code></pre>\n<p>This gives:</p>\n\
    <pre><code>eidengesäß\nEIDENGESÄSS\n</code></pre>\n<hr/>\n<p>[1] In 2017, the\
    \ Council for German Orthography ruled that \"ẞ\" U+1E9E LATIN CAPITAL LETTER\
    \ SHARP S could be used officially, as an option beside the traditional \"SS\"\
    \ conversion to avoid ambiguity e.g. in passports (where names are capitalized).\
    \ My beautiful go-to example, made obsolete by committee decision... </p>\n</div>"
- - What is a “cache-friendly” code?
  - "<div class=\"post-text\" itemprop=\"text\">\n<h2>Preliminaries</h2>\n<p>On modern\
    \ computers, only the lowest level memory structures (the <strong>registers</strong>)\
    \ can move data around in single clock cycles. However, registers are very expensive\
    \ and most computer cores have less than a few dozen registers (few hundred to\
    \ maybe a thousand <em>bytes</em> total).  At the other end of the memory spectrum\
    \ (<strong>DRAM</strong>), the memory is very cheap (i.e. literally <em>millions\
    \ of times cheaper</em>) but takes hundreds of cycles after a request to receive\
    \ the data.  To bridge this gap between super fast and expensive and super slow\
    \ and cheap are the <strong>cache memories</strong>, named L1, L2, L3 in decreasing\
    \ speed and cost. The idea is that most of the executing code will be hitting\
    \ a small set of variables often, and the rest (a much larger set of variables)\
    \ infrequently. If the processor can't find the data in L1 cache, then it looks\
    \ in L2 cache. If not there, then L3 cache, and if not there, main memory. Each\
    \ of these \"misses\" is expensive in time.</p>\n<p>(The analogy is cache memory\
    \ is to system memory, as system memory is to hard disk storage. Hard disk storage\
    \ is super cheap, but very slow).</p>\n<p>Caching is one of the main methods to\
    \ reduce the impact of <em>latency</em>. To paraphrase Herb Sutter (cfr. links\
    \ below): <strong>increasing bandwidth is easy, but we can't buy our way out of\
    \ latency</strong>.</p>\n<p>Data is always retrieved through the memory hierarchy\
    \ (smallest == fastest to slowest). A <em>cache hit/miss</em> usually refers to\
    \ a hit/miss in the highest level of cache in the CPU -- by highest level I mean\
    \ the largest == slowest. The cache hit rate is crucial for performance, since\
    \ every cache miss results in fetching data from RAM (or worse ...) which takes\
    \ <strong><em>a lot</em></strong> of time (hundreds of cycles for RAM, tens of\
    \ millions of cycles for HDD). In comparison, reading data from the (highest level)\
    \ cache typically takes only a handful of cycles.</p>\n<p>In modern computer architectures,\
    \ the performance bottleneck is leaving the CPU die (e.g. accessing RAM or higher).\
    \ This will only get worse over time. The increase in processor frequency is currently\
    \ no longer relevant to increase performance. <strong>The problem is memory access.</strong>\
    \ Hardware design efforts in CPUs therefore currently focus heavily on optimizing\
    \ caches, prefetching, pipelines and concurrency. For instance, modern CPUs spend\
    \ around 85% of die on caches and up to 99% for storing/moving data!</p>\n<p>There\
    \ is quite a lot to be said on the subject. Here are a few great references about\
    \ caches, memory hierarchies and proper programming:</p>\n<ul>\n<li><a href=\"\
    http://www.agner.org/optimize/\" rel=\"noreferrer\">Agner Fog's page</a>. In his\
    \ excellent documents, you can find detailed examples covering languages ranging\
    \ from assembly to C++. </li>\n<li>If you are into videos, I strongly recommend\
    \ to have a look at  <a href=\"http://www.youtube.com/watch?v=L7zSU9HI-6I\" rel=\"\
    noreferrer\">Herb Sutter's talk on machine architecture (youtube)</a> (specifically\
    \ check 12:00 and onwards!).</li>\n<li><a href=\"http://www.research.scea.com/research/pdfs/GDC2003_Memory_Optimization_18Mar03.pdf\"\
    \ rel=\"noreferrer\">Slides about memory optimization by Christer Ericson</a>\
    \ (director of technology @ Sony)</li>\n<li>LWN.net's article <a href=\"http://lwn.net/Articles/250967/\"\
    \ rel=\"noreferrer\">\"<em>What every programmer should know about memory</em>\"\
    </a></li>\n</ul>\n<h2>Main concepts for cache-friendly code</h2>\n<p>A very important\
    \ aspect of cache-friendly code is all about <strong><a href=\"http://en.wikipedia.org/wiki/Locality_of_reference\"\
    \ rel=\"noreferrer\">the principle of locality</a></strong>, the goal of which\
    \ is to place related data close in memory to allow efficient caching. In terms\
    \ of the CPU cache, it's important to be aware of cache lines to understand how\
    \ this works: <a href=\"https://stackoverflow.com/questions/3928995/how-do-cache-lines-work\"\
    >How do cache lines work?</a> </p>\n<p>The following particular aspects are of\
    \ high importance to optimize caching:</p>\n<ol>\n<li><strong>Temporal locality</strong>:\
    \ when a given memory location was accessed, it is likely that the same location\
    \ is accessed again in the near future. Ideally, this information will still be\
    \ cached at that point.</li>\n<li><strong>Spatial locality</strong>: this refers\
    \ to placing related data close to eachother. Caching happens on many levels,\
    \ not just in the CPU. For example, when you read from RAM, typically a larger\
    \ chunk of memory is fetched than what was specifically asked for because very\
    \ often the program will require that data soon. HDD caches follow the same line\
    \ of thought. Specifically for CPU caches, the notion of <em>cache lines</em>\
    \ is important.</li>\n</ol>\n<p><strong>Use appropriate <a class=\"post-tag\"\
    \ href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged\
    \ 'c++'\">c++</a> containers</strong></p>\n<p>A simple example of cache-friendly\
    \ versus cache-unfriendly is <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\"\
    \ rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a>'s <code>std::vector</code>\
    \ versus <code>std::list</code>. Elements of a <code>std::vector</code> are stored\
    \ in contiguous memory, and as such accessing them is <em>much</em> more cache-friendly\
    \ than accessing elements in a <code>std::list</code>, which stores its content\
    \ all over the place. This is due to spatial locality.</p>\n<p>A very nice illustration\
    \ of this is given by Bjarne Stroustrup in <a href=\"http://www.youtube.com/watch?v=YQs6IC-vgmo\"\
    \ rel=\"noreferrer\">this youtube clip</a> (thanks to @Mohammad Ali Baydoun for\
    \ the link!).</p>\n<p><strong>Don't neglect the cache in data structure and algorithm\
    \ design</strong></p>\n<p>Whenever possible, try to adapt your data structures\
    \ and order of computations in a way that allows maximum use of the cache. An\
    \ common technique in this regard is <a href=\"http://www.cs.berkeley.edu/~richie/cs267/mg/report/node35.html\"\
    \ rel=\"noreferrer\">cache blocking</a> <a href=\"https://web.archive.org/web/20140113145619/http://www.cs.berkeley.edu/~richie/cs267/mg/report/node35.html\"\
    \ rel=\"noreferrer\">(Archive.org version)</a>, which is of extreme importance\
    \ in high-performance computing (cfr. for example <a href=\"http://en.wikipedia.org/wiki/Automatically_Tuned_Linear_Algebra_Software\"\
    \ rel=\"noreferrer\">ATLAS</a>).</p>\n<p><strong>Know and exploit the implicit\
    \ structure of data</strong></p>\n<p>Another simple example, which many people\
    \ in the field sometimes forget is column-major (ex. <a class=\"post-tag\" href=\"\
    /questions/tagged/fortran\" rel=\"tag\" title=\"show questions tagged 'fortran'\"\
    >fortran</a>,<a class=\"post-tag\" href=\"/questions/tagged/matlab\" rel=\"tag\"\
    \ title=\"show questions tagged 'matlab'\">matlab</a>) vs. row-major ordering\
    \ (ex. <a class=\"post-tag\" href=\"/questions/tagged/c\" rel=\"tag\" title=\"\
    show questions tagged 'c'\">c</a>,<a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\"\
    \ rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a>) for storing two dimensional\
    \ arrays. For example, consider the following matrix:</p>\n<pre><code>1 2\n3 4\n\
    </code></pre>\n<p>In row-major ordering, this is stored in memory as <code>1 2\
    \ 3 4</code>; in column-major ordering this would be stored as <code>1 3 2 4</code>.\
    \ It is easy to see that implementations which do not exploit this ordering will\
    \ quickly run into (easily avoidable!) cache issues. Unfortunately, I see stuff\
    \ like this <em>very</em> often in my domain (machine learning). @MatteoItalia\
    \ showed this example in more detail in his answer.</p>\n<p>When fetching a certain\
    \ element of a matrix from memory, elements near it will be fetched as well and\
    \ stored in a cache line. If the ordering is exploited, this will result in fewer\
    \ memory accesses (because the next few values which are needed for subsequent\
    \ computations are already in a cache line). </p>\n<p>For simplicity, assume the\
    \ cache comprises a single cache line which can contain 2 matrix elements and\
    \ that when a given element is fetched from memory, the next one is too. Say we\
    \ want to take the sum over all elements in the example 2x2 matrix above (lets\
    \ call it <code>M</code>):</p>\n<p>Exploiting the ordering (e.g. changing column\
    \ index first in <a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"\
    tag\" title=\"show questions tagged 'c++'\">c++</a>): </p>\n<pre><code>M[0][0]\
    \ (memory) + M[0][1] (cached) + M[1][0] (memory) + M[1][1] (cached)\n= 1 + 2 +\
    \ 3 + 4\n--&gt; 2 cache hits, 2 memory accesses\n</code></pre>\n<p>Not exploiting\
    \ the ordering (e.g. changing row index first in <a class=\"post-tag\" href=\"\
    /questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\"\
    >c++</a>):</p>\n<pre><code>M[0][0] (memory) + M[1][0] (memory) + M[0][1] (memory)\
    \ + M[1][1] (memory)\n= 1 + 3 + 2 + 4\n--&gt; 0 cache hits, 4 memory accesses\n\
    </code></pre>\n<p>In this simple example, exploiting the ordering approximately\
    \ doubles execution speed (since memory access requires much more cycles than\
    \ computing the sums). In practice the performance difference can be <em>much</em>\
    \ larger.</p>\n<p><strong>Avoid unpredictable branches</strong></p>\n<p>Modern\
    \ architectures feature pipelines and compilers are becoming very good at reordering\
    \ code to minimize delays due to memory access. When your critical code contains\
    \ (unpredictable) branches, it is hard or impossible to prefetch data. This will\
    \ indirectly lead to more cache misses.</p>\n<p>This is explained <em>very</em>\
    \ well here (thanks to @0x90 for the link): <a href=\"https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-an-unsorted-array\"\
    >Why is it faster to process a sorted array than an unsorted array?</a></p>\n\
    <p><strong>Avoid virtual functions</strong></p>\n<p>In the context of <a class=\"\
    post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions\
    \ tagged 'c++'\">c++</a>, <code>virtual</code> methods represent a controversial\
    \ issue with regard to cache misses (a general consensus exists that they should\
    \ be avoided when possible in terms of performance). Virtual functions can induce\
    \ cache misses during look up, but this only happens <em>if</em> the specific\
    \ function is not called often (otherwise it would likely be cached), so this\
    \ is regarded as a non-issue by some. For reference about this issue, check out:\
    \ <a href=\"https://stackoverflow.com/questions/667634/what-is-the-performance-cost-of-having-a-virtual-method-in-a-c-class\"\
    >What is the performance cost of having a virtual method in a C++ class?</a> </p>\n\
    <h2>Common problems</h2>\n<p>A common problem in modern architectures with multiprocessor\
    \ caches is called <a href=\"http://en.wikipedia.org/wiki/False_sharing\" rel=\"\
    noreferrer\">false sharing</a>. This occurs when each individual processor is\
    \ attempting to use data in another memory region and attempts to store it in\
    \ the same <em>cache line</em>. This causes the cache line -- which contains data\
    \ another processor can use -- to be overwritten again and again. Effectively,\
    \ different threads make each other wait by inducing cache misses in this situation.\n\
    See also (thanks to @Matt for the link): <a href=\"https://stackoverflow.com/questions/8469427/how-and-when-to-align-to-cache-line-size\"\
    >How and when to align to cache line size?</a></p>\n<p>An extreme symptom of poor\
    \ caching in RAM memory (which is probably not what you mean in this context)\
    \ is so-called <a href=\"http://en.wikipedia.org/wiki/Thrashing_%28computer_science%29\"\
    \ rel=\"noreferrer\">thrashing</a>. This occurs when the process continuously\
    \ generates page faults (e.g. accesses memory which is not in the current page)\
    \ which require disk access.</p>\n</div>"
- - What is a “cache-friendly” code?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>In addition to @Marc Claesen's\
    \ answer, I think that an instructive classic example of cache-unfriendly code\
    \ is code that scans a C bidimensional array (e.g. a bitmap image) column-wise\
    \ instead of row-wise.</p>\n<p>Elements that are adjacent in a row are also adjacent\
    \ in memory, thus accessing them in sequence means accessing them in ascending\
    \ memory order; this is cache-friendly, since the cache tends to prefetch contiguous\
    \ blocks of memory.</p>\n<p>Instead, accessing such elements column-wise is cache-unfriendly,\
    \ since elements on the same column are distant in memory from each other (in\
    \ particular, their distance is equal to the size of the row), so when you use\
    \ this access pattern you are jumping around in memory, potentially wasting the\
    \ effort of the cache of retrieving the elements nearby in memory.</p>\n<p>And\
    \ all that it takes to ruin the performance is to go from</p>\n<pre><code>// Cache-friendly\
    \ version - processes pixels which are adjacent in memory\nfor(unsigned int y=0;\
    \ y&lt;height; ++y)\n{\n    for(unsigned int x=0; x&lt;width; ++x)\n    {\n  \
    \      ... image[y][x] ...\n    }\n}\n</code></pre>\n<p>to</p>\n<pre><code>//\
    \ Cache-unfriendly version - jumps around in memory for no good reason\nfor(unsigned\
    \ int x=0; x&lt;width; ++x)\n{\n    for(unsigned int y=0; y&lt;height; ++y)\n\
    \    {\n        ... image[y][x] ...\n    }\n}\n</code></pre>\n<p>This effect can\
    \ be quite dramatic (several order of magnitudes in speed) in systems with small\
    \ caches and/or working with big arrays (e.g. 10+ megapixels 24 bpp images on\
    \ current machines); for this reason, if you have to do many vertical scans, often\
    \ it's better to rotate the image of 90 degrees first and perform the various\
    \ analysis later, limiting the cache-unfriendly code just to the rotation.</p>\n\
    </div>"
- - What is a “cache-friendly” code?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Optimizing cache usage largely\
    \ comes down to two factors.</p>\n<h1>Locality of Reference</h1>\n<p>The first\
    \ factor (to which others have already alluded) is locality of reference. Locality\
    \ of reference really has two dimensions though: space and time.</p>\n<ul>\n<li>Spatial</li>\n\
    </ul>\n<p>The spatial dimension also comes down to two things: first, we want\
    \ to pack our information densely, so more information will fit in that limited\
    \ memory. This means (for example) that you need a major improvement in computational\
    \ complexity to justify data structures based on small nodes joined by pointers.</p>\n\
    <p>Second, we want information that will be processed together also located together.\
    \ A typical cache works in \"lines\", which means when you access some information,\
    \ other information at nearby addresses will be loaded into the cache with the\
    \ part we touched. For example, when I touch one byte, the cache might load 128\
    \ or 256 bytes near that one. To take advantage of that, you generally want the\
    \ data arranged to maximize the likelihood that you'll also use that other data\
    \ that was loaded at the same time.</p>\n<p>For just a really trivial example,\
    \ this can mean that a linear search can be much more competitive with a binary\
    \ search than you'd expect. Once you've loaded one item from a cache line, using\
    \ the rest of the data in that cache line is almost free. A binary search becomes\
    \ noticeably faster only when the data is large enough that the binary search\
    \ reduces the number of cache lines you access.</p>\n<ul>\n<li>Time</li>\n</ul>\n\
    <p>The time dimension means that when you do some operations on some data, you\
    \ want (as much as possible) to do all the operations on that data at once.</p>\n\
    <p>Since you've tagged this as C++, I'll point to a classic example of a relatively\
    \ cache-unfriendly design: <code>std::valarray</code>. <code>valarray</code> overloads\
    \ most arithmetic operators, so I can (for example) say <code>a = b + c + d;</code>\
    \ (where <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> are\
    \ all valarrays) to do element-wise addition of those arrays.</p>\n<p>The problem\
    \ with this is that it walks through one pair of inputs, puts results in a temporary,\
    \ walks through another pair of inputs, and so on. With a lot of data, the result\
    \ from one computation may disappear from the cache before it's used in the next\
    \ computation, so we end up reading (and writing) the data repeatedly before we\
    \ get our final result. If each element of the final result will be something\
    \ like <code>(a[n] + b[n]) * (c[n] + d[n]);</code>, we'd generally prefer to read\
    \ each <code>a[n]</code>, <code>b[n]</code>, <code>c[n]</code> and <code>d[n]</code>\
    \ once, do the computation, write the result, increment <code>n</code> and repeat\
    \ 'til we're done.<sup>2</sup></p>\n<h1>Line Sharing</h1>\n<p>The second major\
    \ factor is avoiding line sharing. To understand this, we probably need to back\
    \ up and look a little at how caches are organized. The simplest form of cache\
    \ is direct mapped. This means one address in main memory can only be stored in\
    \ one specific spot in the cache. If we're using two data items that map to the\
    \ same spot in the cache, it works badly -- each time we use one data item, the\
    \ other has to be flushed from the cache to make room for the other. The rest\
    \ of the cache might be empty, but those items won't use other parts of the cache.</p>\n\
    <p>To prevent this, most caches are what are called \"set associative\". For example,\
    \ in a 4-way set-associative cache, any item from main memory can be stored at\
    \ any of 4 different places in the cache. So, when the cache is going to load\
    \ an item, it looks for the least recently used<sup>3</sup> item among those four,\
    \ flushes it to main memory, and loads the new item in its place.</p>\n<p>The\
    \ problem is probably fairly obvious: for a direct-mapped cache, two operands\
    \ that happen to map to the same cache location can lead to bad behavior. An N-way\
    \ set-associative cache increases the number from 2 to N+1. Organizing a cache\
    \ into more \"ways\" takes extra circuitry and generally runs slower, so (for\
    \ example) an 8192-way set associative cache is rarely a good solution either.</p>\n\
    <p>Ultimately, this factor is more difficult to control in portable code though.\
    \ Your control over where your data is placed is usually fairly limited. Worse,\
    \ the exact mapping from address to cache varies between otherwise similar processors.\
    \ In some cases, however, it can be worth doing things like allocating a large\
    \ buffer, and then using only parts of what you allocated to ensure against data\
    \ sharing the same cache lines (even though you'll probably need to detect the\
    \ exact processor and act accordingly to do this).</p>\n<ul>\n<li>False Sharing</li>\n\
    </ul>\n<p>There's another, related item called \"false sharing\". This arises\
    \ in a multiprocessor or multicore system, where two (or more) processors/cores\
    \ have data that's separate, but falls in the same cache line. This forces the\
    \ two processors/cores to coordinate their access to the data, even though each\
    \ has its own, separate data item. Especially if the two modify the data in alternation,\
    \ this can lead to a massive slowdown as the data has to be constantly shuttled\
    \ between the processors. This can't easily be cured by organizing the cache into\
    \ more \"ways\" or anything like that either. The primary way to prevent it is\
    \ to ensure that two threads rarely (preferably never) modify data that could\
    \ possibly be in the same cache line (with the same caveats about difficulty of\
    \ controlling the addresses at which data is allocated).</p>\n<hr/>\n<ol>\n<li><p>Those\
    \ who know C++ well might wonder if this is open to optimization via something\
    \ like expression templates. I'm pretty sure the answer is that yes, it could\
    \ be done and if it was, it would probably be a pretty substantial win. I'm not\
    \ aware of anybody having done so, however, and given how little <code>valarray</code>\
    \ gets used, I'd be at least a little surprised to see anybody do so either.</p></li>\n\
    <li><p>In case anybody wonders how <code>valarray</code> (designed specifically\
    \ for performance) could be this badly wrong, it comes down to one thing: it was\
    \ really designed for machines like the older Crays, that used fast main memory\
    \ and no cache. For them, this really was a nearly ideal design.</p></li>\n<li><p>Yes,\
    \ I'm simplifying: most caches don't really measure the least recently used item\
    \ precisely, but they use some heuristic that's intended to be close to that without\
    \ having to keep a full time-stamp for each access.</p></li>\n</ol>\n</div>"
- - What does the C++ standard state the size of int, long type to be?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>The C++ standard does not specify\
    \ the size of integral types in bytes, but it specifies minimum ranges they must\
    \ be able to hold. You can infer minimum size in bits from the required range.\
    \ You can infer minimum size in bytes from that and the value of the <code>CHAR_BIT</code>\
    \ macro that <a href=\"https://stackoverflow.com/questions/437470/type-to-use-to-represent-a-byte-in-ansi-c89-90-c/437640#437640\"\
    >defines the number of bits in a byte</a> (in all but the most obscure platforms\
    \ it's 8, and it can't be less than 8).</p>\n<p>One additional constraint for\
    \ <code>char</code> is that its size is always 1 byte, or <code>CHAR_BIT</code>\
    \ bits (hence the name).</p>\n<p>Minimum ranges <a href=\"http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf\"\
    \ rel=\"noreferrer\">required by the standard</a> (page 22) are:</p>\n<p>and Data\
    \ Type Ranges on <a href=\"http://msdn.microsoft.com/en-us/library/s3f49ktz.aspx\"\
    \ rel=\"noreferrer\">MSDN</a>:</p>\n<ol>\n<li><code>signed char</code>: -127 to\
    \ 127 (note, not -128 to 127; this accommodates 1's-complement and sign-and-magnitude\
    \ platforms)</li>\n<li><code>unsigned char</code>: 0 to 255</li>\n<li>\"plain\"\
    \ <code>char</code>: same range as <code>signed char</code> or <code>unsigned\
    \ char</code>, <a href=\"https://stackoverflow.com/q/2397984\">implementation-defined</a></li>\n\
    <li><code>signed short</code>: -32767 to 32767</li>\n<li><code>unsigned short</code>:\
    \ 0 to 65535</li>\n<li><code>signed int</code>: -32767 to 32767</li>\n<li><code>unsigned\
    \ int</code>: 0 to 65535</li>\n<li><code>signed long</code>: -2147483647 to 2147483647</li>\n\
    <li><code>unsigned long</code>: 0 to 4294967295</li>\n<li><code>signed long long</code>:\
    \ -9223372036854775807 to 9223372036854775807</li>\n<li><code>unsigned long long</code>:\
    \ 0 to 18446744073709551615</li>\n</ol>\n<p>A C++ (or C) implementation can define\
    \ the size of a type in bytes <code>sizeof(type)</code> to any value, as long\
    \ as</p>\n<ol>\n<li>the expression <code>sizeof(type) * CHAR_BIT</code> evaluates\
    \ to a number of bits high enough to contain required ranges, and</li>\n<li>the\
    \ ordering of type is still valid (e.g. <code>sizeof(int) &lt;= sizeof(long)</code>).</li>\n\
    </ol>\n<p>The actual implementation-specific ranges can be found in <code>&lt;limits.h&gt;</code>\
    \ header in C, or <code>&lt;climits&gt;</code> in C++ (or even better, templated\
    \ <code>std::numeric_limits</code> in <code>&lt;limits&gt;</code> header).</p>\n\
    <p>For example, this is how you will find maximum range for <code>int</code>:</p>\n\
    <p><strong>C:</strong></p>\n<pre><code>#include &lt;limits.h&gt;\nconst int min_int\
    \ = INT_MIN;\nconst int max_int = INT_MAX;\n</code></pre>\n<p><strong>C++</strong>:</p>\n\
    <pre><code>#include &lt;limits&gt;\nconst int min_int = std::numeric_limits&lt;int&gt;::min();\n\
    const int max_int = std::numeric_limits&lt;int&gt;::max();\n</code></pre>\n</div>"
- - What does the C++ standard state the size of int, long type to be?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>For 32-bit systems, the 'de facto'\
    \ standard is ILP32 — that is, <code>int</code>, <code>long</code> and pointer\
    \ are all 32-bit quantities.</p>\n<p>For 64-bit systems, the primary Unix 'de\
    \ facto' standard is LP64 — <code>long</code> and pointer are 64-bit (but <code>int</code>\
    \ is 32-bit).  The Windows 64-bit standard is LLP64 — <code>long long</code> and\
    \ pointer are 64-bit (but <code>long</code> and <code>int</code> are both 32-bit).</p>\n\
    <p>At one time, some Unix systems used an ILP64 organization.</p>\n<p>None of\
    \ these de facto standards is legislated by the C standard (ISO/IEC 9899:1999),\
    \ but all are permitted by it.</p>\n<p>And, by definition, <code>sizeof(char)</code>\
    \ is <code>1</code>, notwithstanding the test in the Perl configure script.</p>\n\
    <p>Note that there were machines (Crays) where <code>CHAR_BIT</code> was much\
    \ larger than 8.  That meant, IIRC, that <code>sizeof(int)</code> was also 1,\
    \ because both <code>char</code> and <code>int</code> were 32-bit.</p>\n</div>"
- - What does the C++ standard state the size of int, long type to be?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>In practice there's no such thing.\
    \ Often you can expect <code>std::size_t</code> to  represent the unsigned native\
    \ integer size on current architecture. i.e. 16-bit, 32-bit or 64-bit but it isn't\
    \ always the case as pointed out in the comments to this answer.</p>\n<p>As far\
    \ as all the other built-in types go, it really depends on the compiler. Here's\
    \ two excerpts taken from the current working draft of the latest C++ standard:</p>\n\
    <blockquote>\n<p>There are five standard signed integer types : signed char, short\
    \ int, int, long int, and long long int. In this list, each type provides at least\
    \ as much storage as those preceding it in the list.</p>\n<p>For each of the standard\
    \ signed integer types, there exists a corresponding (but different) standard\
    \ unsigned integer type: unsigned char, unsigned short int, unsigned int, unsigned\
    \ long int, and unsigned long long int, each of which occupies the same amount\
    \ of storage and has the same alignment requirements.</p>\n</blockquote>\n<p>If\
    \ you want to you can statically (compile-time) assert the sizeof these fundamental\
    \ types. It will alert people to think about porting your code if the sizeof assumptions\
    \ change. </p>\n</div>"
- - What is object slicing?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>\"Slicing\" is where you assign\
    \ an object of a derived class to an instance of a base class, thereby losing\
    \ part of the information - some of it is \"sliced\" away.</p>\n<p>For example,\
    \ </p>\n<pre><code>class A {\n   int foo;\n};\n\nclass B : public A {\n   int\
    \ bar;\n};\n</code></pre>\n<p>So an object of type <code>B</code> has two data\
    \ members, <code>foo</code> and <code>bar</code>.</p>\n<p>Then if you were to\
    \ write this:</p>\n<pre><code>B b;\n\nA a = b;\n</code></pre>\n<p>Then the information\
    \ in <code>b</code> about member <code>bar</code> is lost in <code>a</code>.</p>\n\
    </div>"
- - What is object slicing?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Most answers here fail to explain\
    \ what the actual problem with slicing is. They only explain the benign cases\
    \ of slicing, not the treacherous ones. Assume, like the other answers, that you're\
    \ dealing with two classes <code>A</code> and <code>B</code>, where <code>B</code>\
    \ derives (publicly) from <code>A</code>.</p>\n<p>In this situation, C++ lets\
    \ you pass an instance of <code>B</code> to  <code>A</code>'s assignment operator\
    \ (and also to the copy constructor). This works because an instance of <code>B</code>\
    \ can be converted to a <code>const A&amp;</code>, which is what assignment operators\
    \ and copy-constructors expect their arguments to be.</p>\n<h3>The benign case</h3>\n\
    <pre><code>B b;\nA a = b;\n</code></pre>\n<p>Nothing bad happens there - you asked\
    \ for an instance of <code>A</code> which is a copy of <code>B</code>, and that's\
    \ exactly what you get. Sure, <code>a</code> won't contain some of <code>b</code>'s\
    \ members, but how should it? It's an <code>A</code>, after all, not a <code>B</code>,\
    \ so it hasn't even <em>heard</em> about these members, let alone would be able\
    \ to store them.</p>\n<h3>The treacherous case</h3>\n<pre><code>B b1;\nB b2;\n\
    A&amp; a_ref = b2;\na_ref = b1;\n//b2 now contains a mixture of b1 and b2!\n</code></pre>\n\
    <p>You might think that <code>b2</code> will be a copy of <code>b1</code> afterwards.\
    \ But, alas, it's <strong>not</strong>! If you inspect it, you'll discover that\
    \ <code>b2</code> is a Frankensteinian creature, made from some chunks of <code>b1</code>\
    \ (the chunks that <code>B</code> inherits from <code>A</code>), and some chunks\
    \ of <code>b2</code> (the chunks that only <code>B</code> contains). Ouch!</p>\n\
    <p>What happened? Well, C++ by default doesn't treat assignment operators as <code>virtual</code>.\
    \ Thus, the line <code>a_ref = b1</code> will call the assignment operator of\
    \ <code>A</code>, not that of <code>B</code>. This is because for non-virtual\
    \ functions, the <strong>declared</strong> type (which is <code>A&amp;</code>)\
    \ determines which function is called, as opposed to the <strong>actual</strong>\
    \ type (which would be <code>B</code>, since <code>a_ref</code> references an\
    \ instance of <code>B</code>). Now, <code>A</code>'s assignment operator obviously\
    \ knows only about the members declared in <code>A</code>, so it will copy only\
    \ those, leaving the members added in <code>B</code> unchanged.</p>\n<h3>A solution</h3>\n\
    <p>Assigning only to parts of an object usually makes little sense, yet C++ unfortunately\
    \ provides no built-in way to forbid this. You can, however, roll your own. The\
    \ first step is making the assignment operator <em>virtual</em>. This will guarantee\
    \ that it's always the <strong>actual</strong> type's assignment operator which\
    \ is called, not the <strong>declared</strong> type's. The second step is to use\
    \ <code>dynamic_cast</code> to verify that the assigned object has a compatible\
    \ type. The third step is to do the actual assignment in a (protected!) member\
    \ <code>assign()</code>, since <code>B</code>'s <code>assign()</code> will probably\
    \ want to use <code>A</code>'s <code>assign()</code> to copy <code>A</code>'s\
    \ members.</p>\n<pre><code>class A {\npublic:\n  virtual A&amp; operator= (const\
    \ A&amp; a) {\n    assign(a);\n    return *this;\n  }\n\nprotected:\n  void assign(const\
    \ A&amp; a) {\n    // copy members of A from a to this\n  }\n};\n\nclass B : public\
    \ A {\npublic:\n  virtual B&amp; operator= (const A&amp; a) {\n    if (const B*\
    \ b = dynamic_cast&lt;const B*&gt;(&amp;a))\n      assign(*b);\n    else\n   \
    \   throw bad_assignment();\n    return *this;\n  }\n\nprotected:\n  void assign(const\
    \ B&amp; b) {\n    A::assign(b); // Let A's assign() copy members of A from b\
    \ to this\n    // copy members of B from b to this\n  }\n};\n</code></pre>\n<p>Note\
    \ that, for pure convenience, <code>B</code>'s <code>operator=</code> covariantly\
    \ overrides the return type, since it <strong>knows</strong> that it's returning\
    \ an instance of <code>B</code>.</p>\n</div>"
- - What is object slicing?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>If You have a base class <code>A</code>\
    \ and a derived class <code>B</code>, then You can do the following.</p>\n<pre><code>void\
    \ wantAnA(A myA)\n{\n   // work with myA\n}\n\nB derived;\n// work with the object\
    \ \"derived\"\nwantAnA(derived);\n</code></pre>\n<p>Now the method <code>wantAnA</code>\
    \ needs a copy of <code>derived</code>. However, the object <code>derived</code>\
    \ cannot be copied completely, as the class <code>B</code> could invent additional\
    \ member variables which are not in its base class <code>A</code>.</p>\n<p>Therefore,\
    \ to call <code>wantAnA</code>, the compiler will \"slice off\" all additional\
    \ members of the derived class. The result might be an object you did not want\
    \ to create, because</p>\n<ul>\n<li>it may be incomplete,</li>\n<li>it behaves\
    \ like an <code>A</code>-object (all special behaviour of the class <code>B</code>\
    \ is lost).</li>\n</ul>\n</div>"
- - Meaning of 'const' last in a function declaration of a class?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>When you add the <code>const</code>\
    \ keyword to a method the <code>this</code> pointer will essentially become a\
    \ pointer to <code>const</code> object, and you cannot therefore change any member\
    \ data. (Unless you use <code>mutable</code>, more on that later).</p>\n<p>The\
    \ <code>const</code> keyword is part of the functions signature which means that\
    \ you can implement two similar methods, one which is called when the object is\
    \ <code>const</code>, and one that isn't.</p>\n<pre><code>#include &lt;iostream&gt;\n\
    \nclass MyClass\n{\nprivate:\n    int counter;\npublic:\n    void Foo()\n    {\
    \ \n        std::cout &lt;&lt; \"Foo\" &lt;&lt; std::endl;    \n    }\n\n    void\
    \ Foo() const\n    {\n        std::cout &lt;&lt; \"Foo const\" &lt;&lt; std::endl;\n\
    \    }\n\n};\n\nint main()\n{\n    MyClass cc;\n    const MyClass&amp; ccc = cc;\n\
    \    cc.Foo();\n    ccc.Foo();\n}\n</code></pre>\n<p>This will output</p>\n<pre><code>Foo\n\
    Foo const\n</code></pre>\n<p>In the non-const method you can change the instance\
    \ members, which you cannot do in the <code>const</code> version. If you change\
    \ the method declaration in the above example to the code below you will get some\
    \ errors.</p>\n<pre><code>    void Foo()\n    {\n        counter++; //this works\n\
    \        std::cout &lt;&lt; \"Foo\" &lt;&lt; std::endl;    \n    }\n\n    void\
    \ Foo() const\n    {\n        counter++; //this will not compile\n        std::cout\
    \ &lt;&lt; \"Foo const\" &lt;&lt; std::endl;\n    }\n</code></pre>\n<p>This is\
    \ not completely true, because you can mark a member as <code>mutable</code> and\
    \ a <code>const</code> method can then change it. It's mostly used for internal\
    \ counters and stuff. The solution for that would be the below code.</p>\n<pre><code>#include\
    \ &lt;iostream&gt;\n\nclass MyClass\n{\nprivate:\n    mutable int counter;\npublic:\n\
    \n    MyClass() : counter(0) {}\n\n    void Foo()\n    {\n        counter++;\n\
    \        std::cout &lt;&lt; \"Foo\" &lt;&lt; std::endl;    \n    }\n\n    void\
    \ Foo() const\n    {\n        counter++;\n        std::cout &lt;&lt; \"Foo const\"\
    \ &lt;&lt; std::endl;\n    }\n\n    int GetInvocations() const\n    {\n      \
    \  return counter;\n    }\n};\n\nint main(void)\n{\n    MyClass cc;\n    const\
    \ MyClass&amp; ccc = cc;\n    cc.Foo();\n    ccc.Foo();\n    std::cout &lt;&lt;\
    \ \"The MyClass instance has been invoked \" &lt;&lt; ccc.GetInvocations() &lt;&lt;\
    \ \" times\" &lt;&lt; endl;\n}\n</code></pre>\n<p>which would output</p>\n<pre><code>Foo\n\
    Foo const\nThe MyClass instance has been invoked 2 times\n</code></pre>\n</div>"
- - Meaning of 'const' last in a function declaration of a class?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>The const means that the method\
    \ promises not to alter any members of the class. You'd be able to execute the\
    \ object's members that are so marked, even if the object itself were marked <code>const</code>:</p>\n\
    <pre><code>const foobar fb;\nfb.foo();\n</code></pre>\n<p>would be legal.</p>\n\
    <p>See <a href=\"http://www.stackoverflow.com/questions/455518/how-many-and-which-are-the-uses-of-const-in-c\"\
    >How many and which are the uses of “const” in C++?</a> for more information.</p>\n\
    </div>"
- - Meaning of 'const' last in a function declaration of a class?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>The <code>const</code> qualifier\
    \ means that the methods can be called on any value of <code>foobar</code>. The\
    \ difference comes when you consider calling a non-const method on a const object.\
    \ Consider if your <code>foobar</code> type had the following extra method declaration:</p>\n\
    <pre><code>class foobar {\n  ...\n  const char* bar();\n}\n</code></pre>\n<p>The\
    \ method <code>bar()</code> is non-const and can only be accessed from non-const\
    \ values.</p>\n<pre><code>void func1(const foobar&amp; fb1, foobar&amp; fb2) {\n\
    \  const char* v1 = fb1.bar();  // won't compile\n  const char* v2 = fb2.bar();\
    \  // works\n}\n</code></pre>\n<p>The idea behind <code>const</code> though is\
    \ to mark methods which will not alter the internal state of the class. This is\
    \ a powerful concept but is not actually enforceable in C++.  It's more of a promise\
    \ than a guarantee. And one that is often broken and easily broken.  </p>\n<pre><code>foobar&amp;\
    \ fbNonConst = const_cast&lt;foobar&amp;&gt;(fb1);\n</code></pre>\n</div>"
- - Can code that is valid in both C and C++ produce different behavior when compiled
    in each language?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>The following, valid in C and\
    \ C++, is going to (most likely) result in different values in <code>i</code>\
    \ in C and C++:</p>\n<pre><code>int i = sizeof('a');\n</code></pre>\n<p>See <a\
    \ href=\"https://stackoverflow.com/questions/2172943/size-of-character-a-in-c-c\"\
    >Size of character ('a') in C/C++</a> for an explanation of the difference.</p>\n\
    <p>Another one from <a href=\"http://david.tribble.com/text/cdiffs.htm\" rel=\"\
    noreferrer\">this article</a>:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint\
    \  sz = 80;\n\nint main(void)\n{\n    struct sz { char c; };\n\n    int val =\
    \ sizeof(sz);      // sizeof(int) in C,\n                               // sizeof(struct\
    \ sz) in C++\n    printf(\"%d\\n\", val);\n    return 0;\n}\n</code></pre>\n</div>"
- - Can code that is valid in both C and C++ produce different behavior when compiled
    in each language?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Here is an example that takes\
    \ advantage of the difference between function calls and object declarations in\
    \ C and C++, as well as the fact that C90 allows the calling of undeclared functions:</p>\n\
    <pre><code>#include &lt;stdio.h&gt;\n\nstruct f { int x; };\n\nint main() {\n\
    \    f();\n}\n\nint f() {\n    return printf(\"hello\");\n}\n</code></pre>\n<p>In\
    \ C++ this will print nothing because a temporary <code>f</code> is created and\
    \ destroyed, but in C90 it will print <code>hello</code> because functions can\
    \ be called without having been declared.</p>\n<p>In case you were wondering about\
    \ the name <code>f</code> being used twice, the C and C++ standards explicitly\
    \ allows this, and to make an object you have to say <code>struct f</code> to\
    \ disambiguate if you want the structure, or leave off <code>struct</code> if\
    \ you want the function.</p>\n</div>"
- - Can code that is valid in both C and C++ produce different behavior when compiled
    in each language?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>For C++ vs. C90, there's at least\
    \ one way to get different behavior that's not implementation defined. C90 doesn't\
    \ have single-line comments. With a little care, we can use that to create an\
    \ expression with entirely different results in C90 and in C++.</p>\n<pre><code>int\
    \ a = 10 //* comment */ 2 \n        + 3;\n</code></pre>\n<p>In C++, everything\
    \ from the <code>//</code> to the end of the line is a comment, so this works\
    \ out as:</p>\n<pre><code>int a = 10 + 3;\n</code></pre>\n<p>Since C90 doesn't\
    \ have single-line comments, only the <code>/* comment */</code> is a comment.\
    \ The first <code>/</code> and the <code>2</code> are both parts of the initialization,\
    \ so it comes out to:</p>\n<pre><code>int a = 10 / 2 + 3;\n</code></pre>\n<p>So,\
    \ a correct C++ compiler will give 13, but a strictly correct C90 compiler 8.\
    \ Of course, I just picked arbitrary numbers here -- you can use other numbers\
    \ as you see fit.</p>\n</div>"
- - C++ Singleton design pattern
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>In 2008 I provided a C++98 implementation\
    \ of the Singleton design pattern that is lazy-evaluated, guaranteed-destruction,\
    \ not-technically-thread-safe:<br/>\n<a href=\"https://stackoverflow.com/questions/270947/can-any-one-provide-me-a-sample-of-singleton-in-c/271104#271104\"\
    >Can any one provide me a sample of Singleton in c++?</a> </p>\n<p>Here is an\
    \ updated C++11 implementation of the Singleton design pattern that is lazy-evaluated,\
    \ correctly-destroyed, and <a href=\"https://stackoverflow.com/a/449823/52074\"\
    >thread-safe</a>.</p>\n<pre><code>class S\n{\n    public:\n        static S&amp;\
    \ getInstance()\n        {\n            static S    instance; // Guaranteed to\
    \ be destroyed.\n                                  // Instantiated on first use.\n\
    \            return instance;\n        }\n    private:\n        S() {}       \
    \             // Constructor? (the {} brackets) are needed here.\n\n        //\
    \ C++ 03\n        // ========\n        // Don't forget to declare these two. You\
    \ want to make sure they\n        // are unacceptable otherwise you may accidentally\
    \ get copies of\n        // your singleton appearing.\n        S(S const&amp;);\
    \              // Don't Implement\n        void operator=(S const&amp;); // Don't\
    \ implement\n\n        // C++ 11\n        // =======\n        // We can use the\
    \ better technique of deleting the methods\n        // we don't want.\n    public:\n\
    \        S(S const&amp;)               = delete;\n        void operator=(S const&amp;)\
    \  = delete;\n\n        // Note: Scott Meyers mentions in his Effective Modern\n\
    \        //       C++ book, that deleted functions should generally\n        //\
    \       be public as it results in better error messages\n        //       due\
    \ to the compilers behavior to check accessibility\n        //       before deleted\
    \ status\n};\n</code></pre>\n<p>See this article about when to use a singleton:\
    \ (not often)<br/>\n<a href=\"https://stackoverflow.com/questions/86582/singleton-how-should-it-be-used\"\
    >Singleton: How should it be used</a></p>\n<p>See this two article about initialization\
    \ order and how to cope:<br/>\n<a href=\"https://stackoverflow.com/questions/211237/c-static-variables-initialisation-order/211307#211307\"\
    >Static variables initialisation order</a><br/>\n<a href=\"https://stackoverflow.com/questions/335369/finding-c-static-initialization-order-problems/335746#335746\"\
    >Finding C++ static initialization order problems</a> </p>\n<p>See this article\
    \ describing lifetimes:<br/>\n<a href=\"https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function\"\
    >What is the lifetime of a static variable in a C++ function?</a> </p>\n<p>See\
    \ this article that discusses some threading implications to singletons:<br/>\n\
    <a href=\"https://stackoverflow.com/questions/449436/singleton-instance-declared-as-static-variable-of-getinstance-method/449823#449823\"\
    >Singleton instance declared as static variable of GetInstance method, is it thread-safe?</a></p>\n\
    <p>See this article that explains why double checked locking will not work on\
    \ C++:<br/>\n<a href=\"https://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviour-that-c-programmer-should-know-about/367690#367690\"\
    >What are all the common undefined behaviours that a C++ programmer should know\
    \ about?</a><br/>\n<a href=\"http://www.drdobbs.com/cpp/c-and-the-perils-of-double-checked-locki/184405726\"\
    \ rel=\"noreferrer\">Dr Dobbs: C++ and The Perils of Double-Checked Locking: Part\
    \ I</a></p>\n</div>"
- - C++ Singleton design pattern
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Being a Singleton, you usually\
    \ do not want it to be destructed.</p>\n<p>It will get torn down and deallocated\
    \ when the program terminates, which is the normal, desired behavior for a singleton.\
    \  If you want to be able to explicitly clean it, it's fairly easy to add a static\
    \ method to the class that allows you to restore it to a clean state, and have\
    \ it reallocate next time it's used, but that's outside of the scope of a \"classic\"\
    \ singleton.</p>\n</div>"
- - C++ Singleton design pattern
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>You could avoid memory allocation.\
    \ There are many variants, all having problems in case of multithreading environment.</p>\n\
    <p>I prefer this kind of implementation (actually, it is not correctly said I\
    \ prefer, because I avoid singletons as much as possible):</p>\n<pre><code>class\
    \ Singleton\n{\nprivate:\n   Singleton();\n\npublic:\n   static Singleton&amp;\
    \ instance()\n   {\n      static Singleton INSTANCE;\n      return INSTANCE;\n\
    \   }\n};\n</code></pre>\n<p>It has no dynamic memory allocation.</p>\n</div>"
- - What should main() return in C and C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>The return value for <code>main</code>\
    \ should indicate how the program exited. Normal exit is generally represented\
    \ by a 0 return value from <code>main</code>. Abnormal exit is usually signalled\
    \ by a non-zero return, but there is no standard for how non-zero codes are interpreted.\
    \ Also as noted by others, <code>void main()</code> is explicitly prohibited by\
    \ the C++ standard and shouldn't be used. The valid C++ <code>main</code> signatures\
    \ are:</p>\n<pre><code>int main()\n</code></pre>\n<p>and</p>\n<pre><code>int main(int\
    \ argc, char* argv[])\n</code></pre>\n<p>which is equivalent to</p>\n<pre><code>int\
    \ main(int argc, char** argv)\n</code></pre>\n<p>It's also worth noting that in\
    \ C++, <code>int main()</code> can be left without a return value at which point\
    \ it defaults to returning 0. This is also true with a C99 program. Whether <code>return\
    \ 0</code> should be omitted or not is open to debate. The range of valid C program\
    \ main signatures is much greater.  </p>\n<p>Also, efficiency is not an issue\
    \ with the <code>main</code> function. It can only be entered and left once (marking\
    \ the program's start and termination) according to the C++ standard. For C, the\
    \ case is different and re-entering <code>main()</code> is allowed, but should\
    \ be avoided. </p>\n</div>"
- - What should main() return in C and C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>The accepted answer appears to\
    \ be targetted for C++, so I thought I'd add an answer that pertains to C, and\
    \ this differs in a few ways.</p>\n<p>ISO/IEC 9899:1989 (C90):</p>\n<p><code>main()</code>\
    \ should be declared as either:</p>\n<pre><code>int main(void)\nint main(int argc,\
    \ char **argv)\n</code></pre>\n<p>Or equivalent. For example, <code>int main(int\
    \ argc, char *argv[])</code> is equivalent to the second one. Further, the <code>int</code>\
    \ return type can be omitted as it is a default.</p>\n<p>If an implementation\
    \ permits it, <code>main()</code> can be declared in other ways, but this makes\
    \ the program implementation defined, and no longer strictly conforming.</p>\n\
    <p>The standard defines 3 values for returning that are strictly conforming (that\
    \ is, does not rely on implementation defined behaviour): <code>0</code> and <code>EXIT_SUCCESS</code>\
    \ for a successful termination, and <code>EXIT_FAILURE</code> for an unsuccessful\
    \ termination. Any other values are non-standard and implementation defined. <code>main()</code>\
    \ must have an explicit <code>return</code> statement at the end to avoid undefined\
    \ behaviour.</p>\n<p>Finally, there is nothing wrong from a standards point of\
    \ view with calling <code>main()</code> from a program.</p>\n<p>ISO/IEC 9899:1999\
    \ (C99):</p>\n<p>For C99, everything is the same as above except:</p>\n<ul>\n\
    <li>The <code>int</code> return type may not be omitted.</li>\n<li>You may omit\
    \ the return statement from <code>main()</code>. If you do, and <code>main()</code>\
    \ finished, there is an implicit <code>return 0</code>.</li>\n</ul>\n</div>"
- - What should main() return in C and C++?
  - "<div class=\"post-text\" itemprop=\"text\">\n<h2>Standard C — Hosted Environment</h2>\n\
    <p>For a hosted environment (that's the normal one), the C11 standard (ISO/IEC\
    \ 9899:2011) says:</p>\n<blockquote>\n<h3>5.1.2.2.1 Program startup</h3>\n<p>The\
    \ function called at program startup is named <code>main</code>. The implementation\
    \ declares no\n  prototype for this function. It shall be defined with a return\
    \ type of <code>int</code> and with no\n  parameters:</p>\n<pre><code>int main(void)\
    \ { /* ... */ }\n</code></pre>\n<p>or with two parameters (referred to here as\
    \ <code>argc</code> and <code>argv</code>, though any names may be\n  used, as\
    \ they are local to the function in which they are declared):</p>\n<pre><code>int\
    \ main(int argc, char *argv[]) { /* ... */ }\n</code></pre>\n<p>or equivalent;<sup>10)</sup>\
    \ or in some other implementation-defined manner.</p>\n<p>If they are declared,\
    \ the parameters to the main function shall obey the following\n  constraints:</p>\n\
    <ul>\n<li>The value of <code>argc</code> shall be nonnegative.</li>\n<li><code>argv[argc]</code>\
    \ shall be a null pointer.</li>\n<li>If the value of <code>argc</code> is greater\
    \ than zero, the array members <code>argv[0]</code> through\n  <code>argv[argc-1]</code>\
    \ inclusive shall contain pointers to strings, which are given\n  implementation-defined\
    \ values by the host environment prior to program startup. The\n  intent is to\
    \ supply to the program information determined prior to program startup\n  from\
    \ elsewhere in the hosted environment. If the host environment is not capable\
    \ of\n  supplying strings with letters in both uppercase and lowercase, the implementation\n\
    \  shall ensure that the strings are received in lowercase.</li>\n<li>If the value\
    \ of <code>argc</code> is greater than zero, the string pointed to by <code>argv[0]</code>\n\
    \  represents the program name; <code>argv[0][0]</code> shall be the null character\
    \ if the\n  program name is not available from the host environment. If the value\
    \ of <code>argc</code> is\n  greater than one, the strings pointed to by <code>argv[1]</code>\
    \ through <code>argv[argc-1]</code>\n  represent the program parameters.</li>\n\
    <li>The parameters <code>argc</code> and <code>argv</code> and the strings pointed\
    \ to by the <code>argv</code> array shall\n  be modifiable by the program, and\
    \ retain their last-stored values between program\n  startup and program termination.</li>\n\
    </ul>\n<p><sup>10)</sup> Thus, <code>int</code> can be replaced by a typedef name\
    \ defined as <code>int</code>, or the type of <code>argv</code> can be written\
    \ as\n  <code>char **argv</code>, and so on.</p>\n</blockquote>\n<h3>Program termination\
    \ in C99 or C11</h3>\n<p>The value returned from <code>main()</code> is transmitted\
    \ to the 'environment' in an implementation-defined way.</p>\n<blockquote>\n<h3>5.1.2.2.3\
    \ Program termination</h3>\n<p>1 If the return type of the <code>main</code> function\
    \ is a type compatible with <code>int</code>, a return from the\n  initial call\
    \ to the <code>main</code> function is equivalent to calling the <code>exit</code>\
    \ function with the value\n  returned by the <code>main</code> function as its\
    \ argument;<sup>11)</sup> reaching the <code>}</code> that terminates the\n  <code>main</code>\
    \ function returns a value of 0. If the return type is not compatible with <code>int</code>,\
    \ the\n  termination status returned to the host environment is unspecified.</p>\n\
    <p><sup>11)</sup> In accordance with 6.2.4, the lifetimes of objects with automatic\
    \ storage duration declared in <code>main</code>\n  will have ended in the former\
    \ case, even where they would not have in the latter.</p>\n</blockquote>\n<p>Note\
    \ that <code>0</code> is mandated as 'success'. You can use <code>EXIT_FAILURE</code>\
    \ and <code>EXIT_SUCCESS</code> from <code>&lt;stdlib.h&gt;</code> if you prefer,\
    \ but 0 is well established, and so is 1. See also <a href=\"https://stackoverflow.com/questions/179565/exitcodes-bigger-than-255-possible/\"\
    >Exit codes greater than 255 — possible?</a>.</p>\n<p>In C89 (and hence in Microsoft\
    \ C), there is no statement about what happens if the <code>main()</code> function\
    \ returns but does not specify a return value; it therefore leads to undefined\
    \ behaviour.</p>\n<blockquote>\n<h3>7.22.4.4 The <code>exit</code> function</h3>\n\
    <p>¶5 Finally, control is returned to the host environment. If the value of <code>status</code>\
    \ is zero or <code>EXIT_SUCCESS</code>, an implementation-defined form of the\
    \ status <em>successful termination</em> is returned. If the value of <code>status</code>\
    \ is <code>EXIT_FAILURE</code>, an implementation-defined form of the status <em>unsuccessful\
    \ termination</em> is returned. Otherwise the status returned is implementation-defined.</p>\n\
    </blockquote>\n<h2>Standard C++ — Hosted Environment</h2>\n<p>The C++11 standard\
    \ (ISO/IEC 14882:2011) says:</p>\n<blockquote>\n<h3>3.6.1 Main function [basic.start.main]</h3>\n\
    <p>¶1 A program shall contain a global function called main, which is the designated\
    \ start of the program. [...]</p>\n<p>¶2 An implementation shall not predefine\
    \ the main function. This function shall not be overloaded. It shall\n  have a\
    \ return type of type int, but otherwise its type is implementation defined.\n\
    \  All implementations\n  shall allow both of the following definitions of main:</p>\n\
    <pre><code>int main() { /* ... */ }\n</code></pre>\n<p>and</p>\n<pre><code>int\
    \ main(int argc, char* argv[]) { /* ... */ }\n</code></pre>\n<p>In the latter\
    \ form <code>argc</code> shall be the number of arguments passed to the program\
    \ from the environment\n  in which the program is run. If <code>argc</code> is\
    \ nonzero these arguments shall be supplied in <code>argv[0]</code>\n  through\
    \ <code>argv[argc-1]</code> as pointers to the initial characters of null-terminated\
    \ multibyte strings (NTMBSs) (17.5.2.1.4.2) and <code>argv[0]</code> shall be\
    \ the pointer to the initial character of a NTMBS that represents the\n  name\
    \ used to invoke the program or <code>\"\"</code>. The value of <code>argc</code>\
    \ shall be non-negative. The value of <code>argv[argc]</code>\n  shall be 0. [\
    \ Note: It is recommended that any further (optional) parameters be added after\
    \ <code>argv</code>. —end\n  note ]</p>\n<p>¶3 The function <code>main</code>\
    \ shall not be used within a program. The linkage (3.5) of <code>main</code> is\
    \ implementation-defined. [...]</p>\n<p>¶5 A return statement in main has the\
    \ effect of leaving the main function (destroying any objects with automatic\n\
    \  storage duration) and calling <code>std::exit</code> with the return value\
    \ as the argument. If control reaches the end\n  of main without encountering\
    \ a return statement, the effect is that of executing</p>\n<pre><code>return 0;\n\
    </code></pre>\n</blockquote>\n<p>The C++ standard explicitly says \"It [the main\
    \ function] shall have a return type of type <code>int</code>, but otherwise its\
    \ type is implementation defined\", and requires the same two signatures as the\
    \ C standard to be supported as options. So a 'void main()' is directly not allowed\
    \ by the C++ standard, though there's nothing it can do to stop a non-standard\
    \ implementation allowing alternatives.  Note that C++ forbids the user from calling\
    \ <code>main</code> (but the C standard does not).</p>\n<p>There's a paragraph\
    \ of §18.5 <strong>Start and termination</strong> in the C++11 standard that is\
    \ identical to the paragraph from §7.22.4.4 <strong>The <code>exit</code> function</strong>\
    \ in the C11 standard (quoted above), apart from a footnote (which simply documents\
    \ that <code>EXIT_SUCCESS</code> and <code>EXIT_FAILURE</code> are defined in\
    \ <code>&lt;cstdlib&gt;</code>).</p>\n<h2>Standard C — Common Extension</h2>\n\
    <p>Classically, Unix systems support a third variant:</p>\n<pre><code>int main(int\
    \ argc, char **argv, char **envp) { ... }\n</code></pre>\n<p>The third argument\
    \ is a null-terminated list of pointers to strings, each of which is an environment\
    \ variable which has a name, an equals sign, and a value (possibly empty).  If\
    \ you do not use this, you can still get at the environment via '<code>extern\
    \ char **environ;</code>'.  For a long time, that did not have a header that declared\
    \ it, but the <a href=\"http://en.wikipedia.org/wiki/POSIX\" rel=\"noreferrer\"\
    >POSIX</a> 2008 standard now requires it to be declared in <code>&lt;unistd.h&gt;</code>.</p>\n\
    <p>This is recognized by the C standard as a common extension, documented in Annex\
    \ J:</p>\n<blockquote>\n<h3>J.5.1 Environment arguments</h3>\n<p>¶1 In a hosted\
    \ environment, the main function receives a third argument, <code>char *envp[]</code>,\n\
    \  that points to a null-terminated array of pointers to <code>char</code>, each\
    \ of which points to a string\n  that provides information about the environment\
    \ for this execution of the program (5.1.2.2.1).</p>\n</blockquote>\n<h2>Microsoft\
    \ C</h2>\n<p>The <a href=\"http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.100%29.aspx\"\
    \ rel=\"noreferrer\">Microsoft VS 2010</a> compiler is interesting. The web site\
    \ says:</p>\n<blockquote>\n<p>The declaration syntax for main is</p>\n<pre><code>\
    \ int main();\n</code></pre>\n<p>or, optionally,</p>\n<pre><code>int main(int\
    \ argc, char *argv[], char *envp[]);\n</code></pre>\n<p>Alternatively, the <code>main</code>\
    \ and <code>wmain</code> functions can be declared as returning <code>void</code>\
    \ (no return value). If you declare <code>main</code> or <code>wmain</code> as\
    \ returning void, you cannot return an exit code to the parent process or operating\
    \ system by using a return statement. To return an exit code when <code>main</code>\
    \ or <code>wmain</code> is declared as <code>void</code>, you must use the <code>exit</code>\
    \ function.</p>\n</blockquote>\n<p>It is not clear to me what happens (what exit\
    \ code is returned to the parent or OS) when a program with <code>void main()</code>\
    \ does exit — and the MS web site is silent too.</p>\n<p>Interestingly, MS does\
    \ not prescribe the two-argument version of <code>main()</code> that the C and\
    \ C++ standards require. It only prescribes a three argument form where the third\
    \ argument is <code>char **envp</code>, a pointer to a list of environment variables.</p>\n\
    <p>The Microsoft page also lists some other alternatives — <code>wmain()</code>\
    \ which takes wide character strings, and some more.</p>\n<p>The Microsoft <a\
    \ href=\"http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2005\"\
    \ rel=\"noreferrer\">Visual Studio 2005</a> version of <a href=\"http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.80%29.aspx\"\
    \ rel=\"noreferrer\">this page</a> does not list <code>void main()</code> as an\
    \ alternative.  The <a href=\"http://msdn.microsoft.com/en-us/library/6wd819wh%28v=vs.90%29.aspx\"\
    \ rel=\"noreferrer\">versions</a> from Microsoft <a href=\"http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2008\"\
    \ rel=\"noreferrer\">Visual Studio 2008</a> onwards do.</p>\n<h2>Standard C —\
    \ Freestanding Environment</h2>\n<p>As noted early on, the requirements above\
    \ apply to hosted environments. If you are working with a freestanding environment\
    \ (which is the alternative to a hosted environment), then the standard has much\
    \ less to say. For a freestanding environment, the function called at program\
    \ startup need not be called <code>main</code> and there are no constraints on\
    \ its return type.  The standard says:</p>\n<blockquote>\n<h3>5.1.2 Execution\
    \ environments</h3>\n<p>Two execution environments are defined: freestanding and\
    \ hosted. In both cases,\n  program startup occurs when a designated C function\
    \ is called by the execution\n  environment. All objects with static storage duration\
    \ shall be initialized (set to their initial values) before program startup. The\
    \ manner and timing of such initialization are otherwise unspecified. Program\
    \ termination returns control to the execution environment.</p>\n<h3>5.1.2.1 Freestanding\
    \ environment</h3>\n<p>In a freestanding environment (in which C program execution\
    \ may take place without any benefit of an operating system), the name and type\
    \ of the function called at program startup are implementation-defined. Any library\
    \ facilities available to a freestanding program, other than the minimal set required\
    \ by clause 4, are implementation-defined.</p>\n<p>The effect of program termination\
    \ in a freestanding environment is implementation-defined.</p>\n</blockquote>\n\
    <p>The cross-reference to clause 4 Conformance refers to this:</p>\n<blockquote>\n\
    <p>¶5 A <em>strictly conforming program</em> shall use only those features of\
    \ the language and library specified in this International Standard.<sup>3)</sup>\
    \ It shall not produce output dependent on any unspecified, undefined, or implementation-defined\
    \ behavior, and shall not exceed any minimum implementation limit.</p>\n<p>¶6\
    \ The two forms of conforming implementation are <em>hosted</em> and <em>freestanding</em>.\
    \ A <em>conforming hosted implementation</em> shall accept any strictly conforming\
    \ program. A <em>conforming freestanding implementation</em> shall accept any\
    \ strictly conforming program in which the use of the features specified in the\
    \ library clause (clause 7) is confined to the contents of the standard headers\
    \ <code>&lt;float.h&gt;</code>, <code>&lt;iso646.h&gt;</code>, <code>&lt;limits.h&gt;</code>,\
    \ <code>&lt;stdalign.h&gt;</code>,\n  <code>&lt;stdarg.h&gt;</code>, <code>&lt;stdbool.h&gt;</code>,\
    \ <code>&lt;stddef.h&gt;</code>, <code>&lt;stdint.h&gt;</code>, and\n  <code>&lt;stdnoreturn.h&gt;</code>.\
    \ A conforming implementation may have extensions (including\n  additional library\
    \ functions), provided they do not alter the behavior of any strictly conforming\
    \ program.<sup>4)</sup></p>\n<p>¶7 A <em>conforming program</em> is one that is\
    \ acceptable to a conforming implementation.<sup>5)</sup></p>\n<p><sup>3)</sup>\
    \ A strictly conforming program can use conditional features (see 6.10.8.3) provided\
    \ the use is guarded by an appropriate conditional inclusion preprocessing directive\
    \ using the related macro. For example:</p>\n<pre><code>#ifdef __STDC_IEC_559__\
    \ /* FE_UPWARD defined */\n    /* ... */\n    fesetround(FE_UPWARD);\n    /* ...\
    \ */\n#endif\n</code></pre>\n<p><sup>4)</sup> This implies that a conforming implementation\
    \ reserves no identifiers other than those explicitly reserved in this International\
    \ Standard.</p>\n<p><sup>5)</sup> Strictly conforming programs are intended to\
    \ be maximally portable among conforming implementations. Conforming programs\
    \ may depend upon non-portable features of a conforming implementation.</p>\n\
    </blockquote>\n<p>It is noticeable that the only header required of a freestanding\
    \ environment that actually defines any functions is <code>&lt;stdarg.h&gt;</code>\
    \ (and even those may be — and often are — just macros).</p>\n<h2>Standard C++\
    \ — Freestanding Environment</h2>\n<p>Just as the C standard recognizes both hosted\
    \ and freestanding environment, so too does the C++ standard. (Quotes from ISO/IEC\
    \ 14882:2011.)</p>\n<blockquote>\n<h3>1.4 Implementation compliance [intro.compliance]</h3>\n\
    <p>¶7 Two kinds of implementations are defined: a <em>hosted implementation</em>\
    \ and a <em>freestanding implementation</em>. For a hosted implementation, this\
    \ International Standard defines the set of available libraries. A freestanding\n\
    \  implementation is one in which execution may take place without the benefit\
    \ of an operating system, and has an implementation-defined set of libraries that\
    \ includes certain language-support libraries (17.6.1.3).</p>\n<p>¶8 A conforming\
    \ implementation may have extensions (including additional library functions),\
    \ provided they do not alter the behavior of any well-formed program. Implementations\
    \ are required to diagnose programs that\n  use such extensions that are ill-formed\
    \ according to this International Standard. Having done so, however, they can\
    \ compile and execute such programs.</p>\n<p>¶9 Each implementation shall include\
    \ documentation that identifies all conditionally-supported constructs that it\
    \ does not support and defines all locale-specific characteristics.<sup>3</sup></p>\n\
    <p><sup>3)</sup> This documentation also defines implementation-defined behavior;\
    \ see 1.9.</p>\n<h3>17.6.1.3 Freestanding implementations [compliance]</h3>\n\
    <p>Two kinds of implementations are defined: hosted and freestanding (1.4). For\
    \ a hosted implementation, this International Standard describes the set of available\
    \ headers.</p>\n<p>A freestanding implementation has an implementation-defined\
    \ set of headers. This set shall include at least the headers shown in Table 16.</p>\n\
    <p>The supplied version of the header <code>&lt;cstdlib&gt;</code> shall declare\
    \ at least the functions <code>abort</code>, <code>atexit</code>, <code>at_quick_exit</code>,\
    \ <code>exit</code>, and <code>quick_exit</code> (18.5). The other headers listed\
    \ in this table shall meet the same requirements as for a hosted implementation.</p>\n\
    <p>Table 16 — C++ headers for freestanding implementations</p>\n<pre><code>Subclause\
    \                           Header(s)\n                                    &lt;ciso646&gt;\n\
    18.2  Types                         &lt;cstddef&gt;\n18.3  Implementation properties\
    \     &lt;cfloat&gt; &lt;limits&gt; &lt;climits&gt;\n18.4  Integer types     \
    \            &lt;cstdint&gt;\n18.5  Start and termination         &lt;cstdlib&gt;\n\
    18.6  Dynamic memory management     &lt;new&gt;\n18.7  Type identification   \
    \        &lt;typeinfo&gt;\n18.8  Exception handling            &lt;exception&gt;\n\
    18.9  Initializer lists             &lt;initializer_list&gt;\n18.10 Other runtime\
    \ support         &lt;cstdalign&gt; &lt;cstdarg&gt; &lt;cstdbool&gt;\n20.9  Type\
    \ traits                   &lt;type_traits&gt;\n29    Atomics                \
    \       &lt;atomic&gt;\n</code></pre>\n</blockquote>\n<h2>What about using <code>int\
    \ main()</code> in C?</h2>\n<p>The standard §5.1.2.2.1 of the C11 standard shows\
    \ the preferred notation — <code>int main(void)</code> — but there are also two\
    \ examples in the standard which show <code>int main()</code>: <a href=\"https://port70.net/~nsz/c/c11/n1570.html#6.5.3.4p8\"\
    \ rel=\"noreferrer\">§6.5.3.4 ¶8</a> and <a href=\"https://port70.net/~nsz/c/c11/n1570.html#6.7.6.3p20\"\
    \ rel=\"noreferrer\">§6.7.6.3 ¶20</a>.  Now, it is important to note that examples\
    \ are not 'normative'; they are only illustrative.  If there are bugs in the examples,\
    \ they do not directly affect the main text of the standard.  That said, they\
    \ are strongly indicative of expected behaviour, so if the standard includes <code>int\
    \ main()</code> in an example, it suggests that <code>int main()</code> is not\
    \ forbidden, even if it is not the preferred notation.</p>\n<blockquote>\n<h3>6.5.3.4\
    \ The <code>sizeof</code> and <code>_Alignof</code> operators</h3>\n<p>…</p>\n\
    <p>¶8 EXAMPLE 3 In this example, the size of a variable length array is computed\
    \ and returned from a function:</p>\n<pre><code>#include &lt;stddef.h&gt;\n\n\
    size_t fsize3(int n)\n{\n    char b[n+3]; // variable length array\n    return\
    \ sizeof b; // execution time sizeof\n}\nint main()\n{\n    size_t size;\n   \
    \ size = fsize3(10); // fsize3 returns 13\n    return 0;\n}\n</code></pre>\n</blockquote>\n\
    </div>"
- - What are the rules for calling the superclass constructor?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>Base class constructors are automatically\
    \ called for you if they have no argument.  If you want to call a superclass constructor\
    \ with an argument, you must use the subclass's constructor initialization list.\
    \  Unlike Java, C++ supports multiple inheritance (for better or worse), so the\
    \ base class must be referred to by name, rather than \"super()\".</p>\n<pre><code>class\
    \ SuperClass\n{\n    public:\n\n        SuperClass(int foo)\n        {\n     \
    \       // do something with foo\n        }\n};\n\nclass SubClass : public SuperClass\n\
    {\n    public:\n\n        SubClass(int foo, int bar)\n        : SuperClass(foo)\
    \    // Call the superclass constructor in the subclass' initialization list.\n\
    \        {\n            // do something with bar\n        }\n};\n</code></pre>\n\
    <p>More info on the constructor's initialization list <a href=\"http://www.cprogramming.com/tutorial/initialization-lists-c++.html\"\
    \ rel=\"noreferrer\">here</a> and <a href=\"http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.6\"\
    \ rel=\"noreferrer\">here</a>.</p>\n</div>"
- - What are the rules for calling the superclass constructor?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>In C++, the no-argument constructors\
    \ for all superclasses and member variables are called for you, before entering\
    \ your constructor. If you want to pass them arguments, there is a separate syntax\
    \ for this called \"constructor chaining\", which looks like this:</p>\n<pre><code>class\
    \ Sub : public Base\n{\n  Sub(int x, int y)\n  : Base(x), member(y)\n  {\n  }\n\
    \  Type member;\n};\n</code></pre>\n<p>If anything run at this point throws, the\
    \ bases/members which had previously completed construction have their destructors\
    \ called and the exception is rethrown to to the caller. If you want to catch\
    \ exceptions during chaining, you must use a function try block:</p>\n<pre><code>class\
    \ Sub : public Base\n{\n  Sub(int x, int y)\n  try : Base(x), member(y)\n  {\n\
    \    // function body goes here\n  } catch(const ExceptionType &amp;e) {\n   \
    \ throw kaboom();\n  }\n  Type member;\n};\n</code></pre>\n<p>In this form, note\
    \ that the try block <strong>is</strong> the body of the function, rather than\
    \ being inside the body of the function; this allows it to catch exceptions thrown\
    \ by implicit or explicit member and base class initializations, as well as during\
    \ the body of the function. However, if a function catch block does not throw\
    \ a different exception, the runtime will rethrow the original error; exceptions\
    \ during initialization <strong>cannot</strong> be ignored.</p>\n</div>"
- - What are the rules for calling the superclass constructor?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>In C++ there is a concept of\
    \ constructor's initialization list, which is where you can and should call the\
    \ base class' constructor and where you should also initialize the data members.\
    \  The initialization list comes after the constructor signature following a colon,\
    \ and before the body of the constructor.  Let's say we have a class A:</p>\n\
    <pre><code>\nclass A : public B\n{\npublic:\n  A(int a, int b, int c);\nprivate:\n\
    \  int b_, c_;\n};\n</code></pre>\n<p>Then, assuming B has a constructor which\
    \ takes an int, A's constructor may look like this:</p>\n<pre><code>\nA::A(int\
    \ a, int b, int c) \n  : B(a), b_(b), c_(c) // initialization list\n{\n  // do\
    \ something\n}\n</code></pre>\n<p>As you can see, the constructor of the base\
    \ class is called in the initialization list.  Initializing the data members in\
    \ the initialization list, by the way, is preferable to assigning the values for\
    \ b_, and c_ inside the body of the constructor, because you are saving the extra\
    \ cost of assignment.</p>\n<p>Keep in mind, that data members are always initialized\
    \ in the order in which they are declared in the class definition, regardless\
    \ of their order in the initialization list.  To avoid strange bugs, which may\
    \ arise if your data members depend on each other, you should always make sure\
    \ that the order of the members is the same in the initialization list and the\
    \ class definition.  For the same reason the base class constructor must be the\
    \ first item in the initialization list.  If you omit it altogether, then the\
    \ default constructor for the base class will be called automatically.  In that\
    \ case, if the base class does not have a default constructor, you will get a\
    \ compiler error.</p>\n</div>"
- - How to concatenate a std::string and an int?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>In alphabetical order:</p>\n\
    <pre><code>std::string name = \"John\";\nint age = 21;\nstd::string result;\n\n\
    // 1. with Boost\nresult = name + boost::lexical_cast&lt;std::string&gt;(age);\n\
    \n// 2. with C++11\nresult = name + std::to_string(age);\n\n// 3. with FastFormat.Format\n\
    fastformat::fmt(result, \"{0}{1}\", name, age);\n\n// 4. with FastFormat.Write\n\
    fastformat::write(result, name, age);\n\n// 5. with the {fmt} library\nresult\
    \ = fmt::format(\"{}{}\", name, age);\n\n// 6. with IOStreams\nstd::stringstream\
    \ sstm;\nsstm &lt;&lt; name &lt;&lt; age;\nresult = sstm.str();\n\n// 7. with\
    \ itoa\nchar numstr[21]; // enough to hold all numbers up to 64-bits\nresult =\
    \ name + itoa(age, numstr, 10);\n\n// 8. with sprintf\nchar numstr[21]; // enough\
    \ to hold all numbers up to 64-bits\nsprintf(numstr, \"%d\", age);\nresult = name\
    \ + numstr;\n\n// 9. with STLSoft's integer_to_string\nchar numstr[21]; // enough\
    \ to hold all numbers up to 64-bits\nresult = name + stlsoft::integer_to_string(numstr,\
    \ 21, age);\n\n// 10. with STLSoft's winstl::int_to_string()\nresult = name +\
    \ winstl::int_to_string(age);\n\n// 11. With Poco NumberFormatter\nresult = name\
    \ + Poco::NumberFormatter().format(age);\n</code></pre>\n<ol>\n<li>is safe, but\
    \ slow; requires <a href=\"http://www.boost.org/\" rel=\"noreferrer\">Boost</a>\
    \ (header-only); most/all platforms</li>\n<li>is safe, requires C++11 (<a href=\"\
    http://www.cplusplus.com/reference/string/to_string/\" rel=\"noreferrer\">to_string()</a>\
    \ is already included in <code>#include &lt;string&gt;</code>)</li>\n<li>is safe,\
    \ and fast; requires <a href=\"http://fastformat.sourceforge.net/\" rel=\"noreferrer\"\
    >FastFormat</a>, which must be compiled; most/all platforms</li>\n<li>is safe,\
    \ and fast; requires <a href=\"http://fastformat.sourceforge.net/\" rel=\"noreferrer\"\
    >FastFormat</a>, which must be compiled; most/all platforms</li>\n<li>is safe,\
    \ and fast; requires <a href=\"https://github.com/fmtlib/fmt\" rel=\"noreferrer\"\
    >the {fmt} library</a>, which can either be compiled or used in a header-only\
    \ mode; most/all platforms</li>\n<li>safe, slow, and verbose; requires <code>#include\
    \ &lt;sstream&gt;</code> (from standard C++)</li>\n<li>is brittle (you must supply\
    \ a large enough buffer), fast, and verbose; itoa() is a non-standard extension,\
    \ and not guaranteed to be available for all platforms</li>\n<li>is brittle (you\
    \ must supply a large enough buffer), fast, and verbose; requires nothing (is\
    \ standard C++); all platforms</li>\n<li>is brittle (you must supply a large enough\
    \ buffer), <a href=\"http://www.ddj.com/cpp/184401596\" rel=\"noreferrer\">probably\
    \ the fastest-possible conversion</a>, verbose; requires <a href=\"http://www.stlsoft.org/\"\
    \ rel=\"noreferrer\">STLSoft</a> (header-only); most/all platforms</li>\n<li>safe-ish\
    \ (you don't use more than one <a href=\"http://www.stlsoft.org/doc-1.9/int%5F%5Fto%5F%5Fstring%5F8hpp.html\"\
    \ rel=\"noreferrer\">int_to_string()</a> call in a single statement), fast; requires\
    \ <a href=\"http://www.stlsoft.org/\" rel=\"noreferrer\">STLSoft</a> (header-only);\
    \ Windows-only</li>\n<li>is safe, but slow; requires <a href=\"http://www.boost.org/\"\
    \ rel=\"noreferrer\">Poco C++</a> ; most/all platforms</li>\n</ol>\n</div>"
- - How to concatenate a std::string and an int?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>In C++11, you can use <code>std::to_string</code>,\
    \ e.g.:</p>\n<pre><code>auto result = name + std::to_string( age );\n</code></pre>\n\
    </div>"
- - How to concatenate a std::string and an int?
  - "<div class=\"post-text\" itemprop=\"text\">\n<p>If you have Boost, you can convert\
    \ the integer to a string using <code>boost::lexical_cast&lt;std::string&gt;(age)</code>.</p>\n\
    <p>Another way is to use stringstreams:</p>\n<pre><code>std::stringstream ss;\n\
    ss &lt;&lt; age;\nstd::cout &lt;&lt; name &lt;&lt; ss.str() &lt;&lt; std::endl;\n\
    </code></pre>\n<p>A third approach would be to use <code>sprintf</code> or <code>snprintf</code>\
    \ from the C library.</p>\n<pre><code>char buffer[128];\nsnprintf(buffer, sizeof(buffer),\
    \ \"%s%d\", name.c_str(), age);\nstd::cout &lt;&lt; buffer &lt;&lt; std::endl;\n\
    </code></pre>\n<p>Other posters suggested using <code>itoa</code>. This is NOT\
    \ a standard function, so your code will not be portable if you use it. There\
    \ are compilers that don't support it.</p>\n</div>"
