categories:
- StackOverflow
- C++
conversations:
- - Why is it faster to process a sorted array than an unsorted array?
  - "<div class=\"post-text\" itemprop=\"text\"><p><strong>You are a victim of <a\
    \ href=\"//en.wikipedia.org/wiki/Branch_predictor\" rel=\"noreferrer\">branch\
    \ prediction</a> fail.</strong></p><hr/><h2>What is Branch Prediction?</h2><p>Consider\
    \ a railroad junction:</p><p><a href=\"//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG\"\
    \ rel=\"noreferrer\"><img alt=\"Licensed Image\" src=\"https://i.stack.imgur.com/muxnt.jpg\"\
    /></a><sub><a href=\"//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG\"\
    \ rel=\"noreferrer\">Image</a> by Mecanismo, via Wikimedia Commons. Used under\
    \ the <a href=\"//creativecommons.org/licenses/by-sa/3.0/deed.en\" rel=\"noreferrer\"\
    >CC-By-SA 3.0</a> license.</sub></p><p>Now for the sake of argument, suppose this\
    \ is back in the 1800s - before long distance or radio communication.</p><p>You\
    \ are the operator of a junction and you hear a train coming. You have no idea\
    \ which way it is supposed to go. You stop the train to ask the driver which direction\
    \ they want. And then you set the switch appropriately.</p><p><em>Trains are heavy\
    \ and have a lot of inertia. So they take forever to start up and slow down.</em></p><p>Is\
    \ there a better way? You guess which direction the train will go!</p><ul><li>If\
    \ you guessed right, it continues on.</li><li>If you guessed wrong, the captain\
    \ will stop, back up, and yell at you to flip the switch. Then it can restart\
    \ down the other path.</li></ul><p><strong>If you guess right every time</strong>,\
    \ the train will never have to stop.<br/><strong>If you guess wrong too often</strong>,\
    \ the train will spend a lot of time stopping, backing up, and restarting.</p><hr/><p><strong>Consider\
    \ an if-statement:</strong> At the processor level, it is a branch instruction:</p><p><img\
    \ alt=\"image2\" src=\"https://i.stack.imgur.com/pyfwC.png\"/></p><p>You are a\
    \ processor and you see a branch. You have no idea which way it will go. What\
    \ do you do? You halt execution and wait until the previous instructions are complete.\
    \ Then you continue down the correct path.</p><p><em>Modern processors are complicated\
    \ and have long pipelines. So they take forever to \"warm up\" and \"slow down\"\
    .</em></p><p>Is there a better way? You guess which direction the branch will\
    \ go!</p><ul><li>If you guessed right, you continue executing.</li><li>If you\
    \ guessed wrong, you need to flush the pipeline and roll back to the branch. Then\
    \ you can restart down the other path.</li></ul><p><strong>If you guess right\
    \ every time</strong>, the execution will never have to stop.<br/><strong>If you\
    \ guess wrong too often</strong>, you spend a lot of time stalling, rolling back,\
    \ and restarting.</p><hr/><p>This is branch prediction. I admit it's not the best\
    \ analogy since the train could just signal the direction with a flag. But in\
    \ computers, the processor doesn't know which direction a branch will go until\
    \ the last moment.</p><p>So how would you strategically guess to minimize the\
    \ number of times that the train must back up and go down the other path? You\
    \ look at the past history! If the train goes left 99% of the time, then you guess\
    \ left. If it alternates, then you alternate your guesses. If it goes one way\
    \ every 3 times, you guess the same...</p><p><strong><em>In other words, you try\
    \ to identify a pattern and follow it.</em></strong> This is more or less how\
    \ branch predictors work.</p><p>Most applications have well-behaved branches.\
    \ So modern branch predictors will typically achieve &gt;90% hit rates. But when\
    \ faced with unpredictable branches with no recognizable patterns, branch predictors\
    \ are virtually useless.</p><p>Further reading: <a href=\"//en.wikipedia.org/wiki/Branch_predictor\"\
    \ rel=\"noreferrer\">\"Branch predictor\" article on Wikipedia</a>.</p><hr/><h2>As\
    \ hinted from above, the culprit is this if-statement:</h2><pre><code>if (data[c]\
    \ &gt;= 128)    sum += data[c];</code></pre><p>Notice that the data is evenly\
    \ distributed between 0 and 255. When the data is sorted, roughly the first half\
    \ of the iterations will not enter the if-statement. After that, they will all\
    \ enter the if-statement.</p><p>This is very friendly to the branch predictor\
    \ since the branch consecutively goes the same direction many times.Even a simple\
    \ saturating counter will correctly predict the branch except for the few iterations\
    \ after it switches direction.</p><p><strong>Quick visualization:</strong></p><pre><code>T\
    \ = branch takenN = branch not takendata[] = 0, 1, 2, 3, 4, ... 126, 127, 128,\
    \ 129, 130, ... 250, 251, 252, ...branch = N  N  N  N  N  ...   N    N    T  \
    \  T    T  ...   T    T    T  ...       = NNNNNNNNNNNN ... NNNNNNNTTTTTTTTT ...\
    \ TTTTTTTTTT  (easy to predict)</code></pre><p>However, when the data is completely\
    \ random, the branch predictor is rendered useless because it can't predict random\
    \ data.Thus there will probably be around 50% misprediction. (no better than random\
    \ guessing)</p><pre><code>data[] = 226, 185, 125, 158, 198, 144, 217, 79, 202,\
    \ 118,  14, 150, 177, 182, 133, ...branch =   T,   T,   N,   T,   T,   T,   T,\
    \  N,   T,   N,   N,   T,   T,   T,   N  ...       = TTNTTTTNTNNTTTN ...   (completely\
    \ random - hard to predict)</code></pre><hr/><p><strong>So what can be done?</strong></p><p>If\
    \ the compiler isn't able to optimize the branch into a conditional move, you\
    \ can try some hacks if you are willing to sacrifice readability for performance.</p><p>Replace:</p><pre><code>if\
    \ (data[c] &gt;= 128)    sum += data[c];</code></pre><p>with:</p><pre><code>int\
    \ t = (data[c] - 128) &gt;&gt; 31;sum += ~t &amp; data[c];</code></pre><p>This\
    \ eliminates the branch and replaces it with some bitwise operations.</p><p><sub>(Note\
    \ that this hack is not strictly equivalent to the original if-statement. But\
    \ in this case, it's valid for all the input values of <code>data[]</code>.)</sub></p><p><strong>Benchmarks:\
    \ Core i7 920 @ 3.5 GHz</strong></p><p>C++ - Visual Studio 2010 - x64 Release</p><pre><code>//\
    \  Branch - Randomseconds = 11.777//  Branch - Sortedseconds = 2.352//  Branchless\
    \ - Randomseconds = 2.564//  Branchless - Sortedseconds = 2.587</code></pre><p>Java\
    \ - Netbeans 7.1.1 JDK 7 - x64</p><pre><code>//  Branch - Randomseconds = 10.93293813//\
    \  Branch - Sortedseconds = 5.643797077//  Branchless - Randomseconds = 3.113581453//\
    \  Branchless - Sortedseconds = 3.186068823</code></pre><p>Observations:</p><ul><li><strong>With\
    \ the Branch:</strong> There is a huge difference between the sorted and unsorted\
    \ data.</li><li><strong>With the Hack:</strong> There is no difference between\
    \ sorted and unsorted data.</li><li>In the C++ case, the hack is actually a tad\
    \ slower than with the branch when the data is sorted.</li></ul><p>A general rule\
    \ of thumb is to avoid data-dependent branching in critical loops. (such as in\
    \ this example)</p><hr/><p><strong>Update:</strong></p><ul><li><p>GCC 4.6.1 with\
    \ <code>-O3</code> or <code>-ftree-vectorize</code> on x64 is able to generate\
    \ a conditional move. So there is no difference between the sorted and unsorted\
    \ data - both are fast.</p></li><li><p>VC++ 2010 is unable to generate conditional\
    \ moves for this branch even under <code>/Ox</code>.</p></li><li><p>Intel Compiler\
    \ 11 does something miraculous. It <a href=\"//en.wikipedia.org/wiki/Loop_interchange\"\
    \ rel=\"noreferrer\">interchanges the two loops</a>, thereby hoisting the unpredictable\
    \ branch to the outer loop. So not only is it immune the mispredictions, it is\
    \ also twice as fast as whatever VC++ and GCC can generate! In other words, ICC\
    \ took advantage of the test-loop to defeat the benchmark...</p></li><li><p>If\
    \ you give the Intel Compiler the branchless code, it just out-right vectorizes\
    \ it... and is just as fast as with the branch (with the loop interchange).</p></li></ul><p>This\
    \ goes to show that even mature modern compilers can vary wildly in their ability\
    \ to optimize code...</p></div>"
- - Why is it faster to process a sorted array than an unsorted array?
  - <div class="post-text" itemprop="text"><p><strong>Branch prediction.</strong></p><p>With
    a sorted array, the condition <code>data[c] &gt;= 128</code> is first <code>false</code>
    for a streak of values, then becomes <code>true</code> for all later values. That's
    easy to predict. With an unsorted array, you pay for the branching cost.</p></div>
- - Why is it faster to process a sorted array than an unsorted array?
  - "<div class=\"post-text\" itemprop=\"text\"><p>The reason why performance improves\
    \ drastically when the data is sorted is that the branch prediction penalty is\
    \ removed, as explained beautifully in <a href=\"https://stackoverflow.com/users/922184/mysticial\"\
    >Mysticial</a>'s answer.</p><p>Now, if we look at the code</p><pre><code>if (data[c]\
    \ &gt;= 128)    sum += data[c];</code></pre><p>we can find that the meaning of\
    \ this particular <code>if... else...</code> branch is to add something when a\
    \ condition is satisfied. This type of branch can be easily transformed into a\
    \ <strong>conditional move</strong> statement, which would be compiled into a\
    \ conditional move instruction: <code>cmovl</code>, in an <code>x86</code> system.\
    \ The branch and thus the potential branch prediction penalty is removed.</p><p>In\
    \ <code>C</code>, thus <code>C++</code>, the statement, which would compile directly\
    \ (without any optimization) into the conditional move instruction in <code>x86</code>,\
    \ is the ternary operator <code>... ? ... : ...</code>. So we rewrite the above\
    \ statement into an equivalent one:</p><pre><code>sum += data[c] &gt;=128 ? data[c]\
    \ : 0;</code></pre><p>While maintaining readability, we can check the speedup\
    \ factor.</p><p>On an Intel <a href=\"http://en.wikipedia.org/wiki/Intel_Core#Core_i7\"\
    \ rel=\"noreferrer\">Core i7</a>-2600K @ 3.4 GHz and Visual Studio 2010 Release\
    \ Mode, the benchmark is (format copied from Mysticial):</p><p><strong>x86</strong></p><pre><code>//\
    \  Branch - Randomseconds = 8.885//  Branch - Sortedseconds = 1.528//  Branchless\
    \ - Randomseconds = 3.716//  Branchless - Sortedseconds = 3.71</code></pre><p><strong>x64</strong></p><pre><code>//\
    \  Branch - Randomseconds = 11.302//  Branch - Sorted seconds = 1.830//  Branchless\
    \ - Randomseconds = 2.736//  Branchless - Sortedseconds = 2.737</code></pre><p>The\
    \ result is robust in multiple tests. We get a great speedup when the branch result\
    \ is unpredictable, but we suffer a little bit when it is predictable. In fact,\
    \ when using a conditional move, the performance is the same regardless of the\
    \ data pattern.</p><p>Now let's look more closely by investigating the <code>x86</code>\
    \ assembly they generate. For simplicity, we use two functions <code>max1</code>\
    \ and <code>max2</code>.</p><p><code>max1</code> uses the conditional branch <code>if...\
    \ else ...</code>:</p><pre><code>int max1(int a, int b) {    if (a &gt; b)   \
    \     return a;    else        return b;}</code></pre><p><code>max2</code> uses\
    \ the ternary operator <code>... ? ... : ...</code>:</p><pre><code>int max2(int\
    \ a, int b) {    return a &gt; b ? a : b;}</code></pre><p>On a x86-64 machine,\
    \ <code>GCC -S</code> generates the assembly below.</p><pre><code>:max1    movl\
    \    %edi, -4(%rbp)    movl    %esi, -8(%rbp)    movl    -4(%rbp), %eax    cmpl\
    \    -8(%rbp), %eax    jle     .L2    movl    -4(%rbp), %eax    movl    %eax,\
    \ -12(%rbp)    jmp     .L4.L2:    movl    -8(%rbp), %eax    movl    %eax, -12(%rbp).L4:\
    \    movl    -12(%rbp), %eax    leave    ret:max2    movl    %edi, -4(%rbp)  \
    \  movl    %esi, -8(%rbp)    movl    -4(%rbp), %eax    cmpl    %eax, -8(%rbp)\
    \    cmovge  -8(%rbp), %eax    leave    ret</code></pre><p><code>max2</code> uses\
    \ much less code due to the usage of instruction <code>cmovge</code>. But the\
    \ real gain is that <code>max2</code> does not involve branch jumps, <code>jmp</code>,\
    \ which would have a significant performance penalty if the predicted result is\
    \ not right.</p><p>So why does a conditional move perform better?</p><p>In a typical\
    \ <code>x86</code> processor, the execution of an instruction is divided into\
    \ several stages. Roughly, we have different hardware to deal with different stages.\
    \ So we do not have to wait for one instruction to finish to start a new one.\
    \ This is called <strong><a href=\"http://en.wikipedia.org/wiki/Pipeline_%28computing%29\"\
    \ rel=\"noreferrer\">pipelining</a></strong>.</p><p>In a branch case, the following\
    \ instruction is determined by the preceding one, so we cannot do pipelining.\
    \ We have to either wait or predict.</p><p>In a conditional move case, the execution\
    \ conditional move instruction is divided into several stages, but the earlier\
    \ stages like <code>Fetch</code> and <code>Decode</code> does not depend on the\
    \ result of the previous instruction; only latter stages need the result. Thus,\
    \ we wait a fraction of one instruction's execution time. This is why the conditional\
    \ move version is slower than the branch when prediction is easy.</p><p>The book\
    \ <em><a href=\"https://rads.stackoverflow.com/amzn/click/com/0136108040\" rel=\"\
    noreferrer\">Computer Systems: A Programmer's Perspective, second edition</a></em>\
    \ explains this in detail. You can check Section 3.6.6 for <em>Conditional Move\
    \ Instructions</em>, entire Chapter 4 for <em>Processor Architecture</em>, and\
    \ Section 5.11.2 for a special treatment for <em>Branch Prediction and Misprediction\
    \ Penalties</em>.</p><p>Sometimes, some modern compilers can optimize our code\
    \ to assembly with better performance, sometimes some compilers can't (the code\
    \ in question is using Visual Studio's native compiler). Knowing the performance\
    \ difference between branch and conditional move when unpredictable can help us\
    \ write code with better performance when the scenario gets so complex that the\
    \ compiler can not optimize them automatically.</p></div>"
- - What is the “-->” operator in C++?
  - <div class="post-text" itemprop="text"><p><code>--&gt;</code> is not an operator.
    It is in fact two separate operators, <code>--</code> and <code>&gt;</code>.</p><p>The
    conditional's code decrements <code>x</code>, while returning <code>x</code>'s
    original (not decremented) value, and then compares the original value with <code>0</code>
    using the <code>&gt;</code> operator.</p><p><strong>To better understand, the
    statement could be written as follows:</strong></p><pre><code>while( (x--) &gt;
    0 )</code></pre></div>
- - What is the “-->” operator in C++?
  - <div class="post-text" itemprop="text"><p>Or for something completely different...
    x slides to 0</p><pre><code>while (x --\            \             \              \               &gt;
    0)     printf("%d ", x);</code></pre><p>Not so mathematical, but... every picture
    paints a thousand words...</p></div>
- - What is the “-->” operator in C++?
  - "<div class=\"post-text\" itemprop=\"text\"><p>That's a very complicated operator,\
    \ so even <a href=\"https://isocpp.org/std/the-committee\" rel=\"noreferrer\"\
    >ISO/IEC JTC1 (Joint Technical Committee 1)</a> placed its description in two\
    \ different parts of the C++ Standard.</p><p>Joking aside, they are two different\
    \ operators: <code>--</code> and <code>&gt;</code> described respectively in §5.2.6/2\
    \ and §5.9 of the C++03 Standard.</p></div>"
- - The Definitive C++ Book Guide and List
  - "<div class=\"post-text\" itemprop=\"text\"><h2>Beginner</h2><h3>Introductory,\
    \ no previous programming experience</h3><ul><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0321714113\"\
    \ rel=\"noreferrer\"><em>C++ Primer</em></a> * (Stanley Lippman, Josée Lajoie,\
    \ and Barbara E. Moo)  (<strong>updated for C++11</strong>) Coming at 1k pages,\
    \ this is a very thorough introduction into C++ that covers just about everything\
    \ in the language in a very accessible format and in great detail. The fifth edition\
    \ (released August 16, 2012) covers C++11. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1848\"\
    \ rel=\"noreferrer\">[Review]</a> </p></li><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0321992784\"\
    \ rel=\"noreferrer\"><em>Programming: Principles and Practice Using C++</em></a>\
    \ (Bjarne Stroustrup, 2nd Edition - May 25, 2014) (<strong>updated for C++11/C++14</strong>)\
    \ An introduction to programming using C++ by the creator of the language. A good\
    \ read, that assumes no previous programming experience, but is not only for beginners.\
    \ </p></li></ul><p><sub>* Not to be confused with <a href=\"https://rads.stackoverflow.com/amzn/click/com/0672326973\"\
    \ rel=\"noreferrer\"><em>C++ Primer Plus</em></a> (Stephen Prata), with a significantly\
    \ less favorable <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1744\"\
    \ rel=\"noreferrer\">review</a>.</sub></p><h3>Introductory, with previous programming\
    \ experience</h3><ul><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/B00F8CWGOS\"\
    \ rel=\"noreferrer\"><em>A Tour of C++</em></a> (Bjarne Stroustrup) (<strong><a\
    \ href=\"http://a.co/f7WPDeD\" rel=\"noreferrer\">2nd edition  for C++17</a></strong>)\
    \ The “tour” is a quick (about 180 pages and 14 chapters) tutorial overview of\
    \ all of standard C++ (language and standard library, <strong>and using C++11</strong>)\
    \ at a moderately high level for people who already know C++ or at least are experienced\
    \ programmers. This book is an extended version of the material that constitutes\
    \ Chapters 2-5 of The C++ Programming Language, 4th edition.</p></li><li><p><a\
    \ href=\"https://rads.stackoverflow.com/amzn/click/com/020170353X\" rel=\"noreferrer\"\
    ><em>Accelerated C++</em></a> (Andrew Koenig and Barbara Moo, 1st Edition - August\
    \ 24, 2000)  This basically covers the same ground as the <em>C++ Primer</em>,\
    \ but does so on a fourth of its space. This is largely because it does not attempt\
    \ to be an introduction to <em>programming</em>, but an introduction to <em>C++</em>\
    \ for people who've previously programmed in some other language. It has a steeper\
    \ learning curve, but, for those who can cope with this, it is a very compact\
    \ introduction to the language. (Historically, it broke new ground by being the\
    \ first beginner's book to use a modern approach to teaching the language.) Despite\
    \ this, the C++it teaches is purely C++98. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1185\"\
    \ rel=\"noreferrer\">[Review]</a></p></li></ul><h3>Best practices</h3><ul><li><p><a\
    \ href=\"https://rads.stackoverflow.com/amzn/click/com/0321334876\" rel=\"noreferrer\"\
    ><em>Effective C++</em></a> (Scott Meyers, 3rd Edition - May 22, 2005)  This was\
    \ written with the aim of being the best second book C++ programmers should read,\
    \ and it succeeded. Earlier editions were aimed at programmers coming from C,\
    \ the third edition changes this and targets programmers coming from languages\
    \ like Java. It presents ~50 easy-to-remember rules of thumb along with their\
    \ rationale in a very accessible (and enjoyable) style. For C++11 and C++14 the\
    \ examples and a few issues are outdated and Effective Modern C++ should be preferred.\
    \ <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=700\"\
    \ rel=\"noreferrer\">[Review]</a></p></li><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/1491903996\"\
    \ rel=\"noreferrer\"><em>Effective Modern C++</em></a> (Scott Meyers) This is\
    \ basically the new version of <em>Effective C++</em>, aimed at C++ programmers\
    \ making the transition from C++03 to C++11 and C++14. </p></li><li><a href=\"\
    https://rads.stackoverflow.com/amzn/click/com/0201749629\" rel=\"noreferrer\"\
    ><em>Effective STL</em></a> (Scott Meyers)  This aims to do the same to the part\
    \ of the standard library coming from the STL what <em>Effective C++</em> did\
    \ to the language as a whole: It presents rules of thumb along with their rationale.\
    \ <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=67\"\
    \ rel=\"noreferrer\">[Review]</a></li></ul><hr/><h2>Intermediate</h2><ul><li><p><a\
    \ href=\"https://rads.stackoverflow.com/amzn/click/com/020163371X\" rel=\"noreferrer\"\
    ><em>More Effective C++</em></a> (Scott Meyers) Even more rules of thumb than\
    \ <em>Effective C++</em>. Not as important as the ones in the first book, but\
    \ still good to know.</p></li><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201615622\"\
    \ rel=\"noreferrer\"><em>Exceptional C++</em></a> (Herb Sutter)  Presented as\
    \ a set of puzzles, this has one of the best and thorough discussions of the proper\
    \ resource management and exception safety in C++ through Resource Acquisition\
    \ is Initialization (RAII) in addition to in-depth coverage of a variety of other\
    \ topics including the pimpl idiom, name lookup, good class design, and the C++\
    \ memory model. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=209\"\
    \ rel=\"noreferrer\">[Review]</a></p></li><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/020170434X\"\
    \ rel=\"noreferrer\"><em>More Exceptional C++</em></a> (Herb Sutter)  Covers additional\
    \ exception safety topics not covered in <em>Exceptional C++</em>, in addition\
    \ to discussion of effective object-oriented programming in C++ and correct use\
    \ of the STL. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=784\"\
    \ rel=\"noreferrer\">[Review]</a></p></li><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201760428\"\
    \ rel=\"noreferrer\"><em>Exceptional C++ Style</em></a> (Herb Sutter)  Discusses\
    \ generic programming, optimization, and resource management; this book also has\
    \ an excellent exposition of how to write modular code in C++ by using non-member\
    \ functions and the single responsibility principle. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=107\"\
    \ rel=\"noreferrer\">[Review]</a></p></li><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0321113586\"\
    \ rel=\"noreferrer\"><em>C++ Coding Standards</em></a> (Herb Sutter and Andrei\
    \ Alexandrescu) “Coding standards” here doesn't mean “how many spaces should I\
    \ indent my code?”  This book contains 101 best practices, idioms, and common\
    \ pitfalls that can help you to write correct, understandable, and efficient C++\
    \ code. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1439\"\
    \ rel=\"noreferrer\">[Review]</a></p></li><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201734842\"\
    \ rel=\"noreferrer\"><em>C++ Templates: The Complete Guide</em></a> (David Vandevoorde\
    \ and Nicolai M. Josuttis) This is <em>the</em> book about templates as they existed\
    \ before C++11.  It covers everything from the very basics to some of the most\
    \ advanced template metaprogramming and explains every detail of how templates\
    \ work (both conceptually and at how they are implemented) and discusses many\
    \ common pitfalls.  Has excellent summaries of the One Definition Rule (ODR) and\
    \ overload resolution in the appendices. A <a href=\"https://rads.stackoverflow.com/amzn/click/com/0321714121\"\
    \ rel=\"noreferrer\">second edition</a> covering C++11, C++14 and C++17 has been\
    \ already published . <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=506\"\
    \ rel=\"noreferrer\">[Review]</a></p></li><li><p><a href=\"https://leanpub.com/cpp17/\"\
    \ rel=\"noreferrer\"><em>C++ 17 - The Complete Guide</em></a> (Nicolai M. Josuttis)\
    \ This book describes all the new features introduced in the C++17 Standard covering\
    \ everything from the simple ones like 'Inline Variables', 'constexpr if' all\
    \ the way up to 'Polymorphic Memory Resources' and 'New and Delete with overaligned\
    \ Data'.</p></li></ul><hr/><h2>Advanced</h2><ul><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201704315\"\
    \ rel=\"noreferrer\"><em>Modern C++ Design</em></a> (Andrei Alexandrescu)  A groundbreaking\
    \ book on advanced generic programming techniques.  Introduces policy-based design,\
    \ type lists, and fundamental generic programming idioms then explains how many\
    \ useful design patterns (including small object allocators, functors, factories,\
    \ visitors, and multi-methods) can be implemented efficiently, modularly, and\
    \ cleanly using generic programming. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=979\"\
    \ rel=\"noreferrer\">[Review]</a></p></li><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0321227255\"\
    \ rel=\"noreferrer\"><em>C++ Template Metaprogramming</em></a> (David Abrahams\
    \ and Aleksey Gurtovoy)</p></li><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/1933988770\"\
    \ rel=\"noreferrer\"><em>C++ Concurrency In Action</em></a> (Anthony Williams)\
    \ A book covering C++11 concurrency support including the thread library, the\
    \ atomics library, the C++ memory model, locks and mutexes, as well as issues\
    \ of designing and debugging multithreaded applications.</p></li><li><p><a href=\"\
    https://rads.stackoverflow.com/amzn/click/com/1460966163\" rel=\"noreferrer\"\
    ><em>Advanced C++ Metaprogramming</em></a> (Davide Di Gennaro) A pre-C++11 manual\
    \ of TMP techniques, focused more on practice than theory.  There are a ton of\
    \ snippets in this book, some of which are made obsolete by type traits, but the\
    \ techniques, are nonetheless useful to know.  If you can put up with the quirky\
    \ formatting/editing, it is easier to read than Alexandrescu, and arguably, more\
    \ rewarding.  For more experienced developers, there is a good chance that you\
    \ may pick up something about a dark corner of C++ (a quirk) that usually only\
    \ comes about through extensive experience.</p></li></ul><hr/><h2>Reference Style\
    \ - All Levels</h2><ul><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0321958322\"\
    \ rel=\"noreferrer\"><em>The C++ Programming Language</em></a> (Bjarne Stroustrup)\
    \ (<strong>updated for C++11</strong>) The classic introduction to C++ by its\
    \ creator. Written to parallel the classic K&amp;R, this indeed reads very much\
    \ like it and covers just about everything from the core language to the standard\
    \ library, to programming paradigms to the language's philosophy. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1853\"\
    \ rel=\"noreferrer\">[Review]</a> Note: All releases of the C++ standard are tracked\
    \ in this question: <a href=\"https://stackoverflow.com/a/4653479/14065\">Where\
    \ do I find the current C++ standard</a>.   </p></li><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0321623215\"\
    \ rel=\"noreferrer\"><em>C++ Standard Library Tutorial and Reference</em></a>\
    \ (Nicolai Josuttis) (<strong>updated for C++11</strong>) <em>The</em> introduction\
    \ and reference for the C++ Standard Library. The second edition (released on\
    \ April 9, 2012) covers C++11. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=1849\"\
    \ rel=\"noreferrer\">[Review]</a></p></li><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201183951\"\
    \ rel=\"noreferrer\"><em>The C++ IO Streams and Locales</em></a> (Angelika Langer\
    \ and Klaus Kreft)  There's very little to say about this book except that, if\
    \ you want to know anything about streams and locales, then this is the one place\
    \ to find definitive answers. <a href=\"http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=200\"\
    \ rel=\"noreferrer\">[Review]</a></p></li></ul><p><strong>C++11/14/17/… References:</strong></p><ul><li><p><em>The\
    \ C++<a href=\"https://www.iso.org/standard/50372.html\" rel=\"noreferrer\">11</a>/<a\
    \ href=\"https://www.iso.org/standard/64029.html\" rel=\"noreferrer\">14</a>/<a\
    \ href=\"https://www.iso.org/standard/68564.html\" rel=\"noreferrer\">17</a> Standard\
    \ (INCITS/ISO/IEC 14882:2011/2014/2017)</em> This, of course, is the final arbiter\
    \ of all that is or isn't C++. Be aware, however, that it is intended purely as\
    \ a reference for <em>experienced</em> users willing to devote considerable time\
    \ and effort to its understanding. The C++17 standard is released in electronic\
    \ form for 198 Swiss Francs.</p></li><li><p>The C++17 standard is available, but\
    \ seemingly not in an economical form – <a href=\"https://www.iso.org/standard/68564.html\"\
    \ rel=\"noreferrer\">directly from the ISO</a> it costs 198 Swiss Francs (about\
    \ $200 US). For most people, the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\"\
    \ rel=\"noreferrer\">final draft before standardization</a> is more than adequate\
    \ (and free). Many will prefer an <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4778.pdf\"\
    \ rel=\"noreferrer\">even newer draft</a>, documenting new features that are likely\
    \ to be included in C++20.</p></li><li><p><a href=\"http://www.artima.com/shop/overview_of_the_new_cpp\"\
    \ rel=\"noreferrer\"><em>Overview of the New C++ (C++11/14) (PDF only)</em></a>\
    \ (Scott Meyers) (<strong>updated for C++14</strong>) These are the presentation\
    \ materials (slides and some lecture notes) of a three-day training course offered\
    \ by Scott Meyers, who's a highly respected author on C++. Even though the list\
    \ of items is short, the quality is high.</p></li><li><p>The <a href=\"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md\"\
    \ rel=\"noreferrer\"><em>C++ Core Guidelines (C++11/14/17/…)</em></a> (edited\
    \ by Bjarne Stroustrup and Herb Sutter) is an evolving online document consisting\
    \ of a set of guidelines for using modern C++ well. The guidelines are focused\
    \ on relatively higher-level issues, such as interfaces, resource management,\
    \ memory management and concurrency affecting application architecture and library\
    \ design. The project was <a href=\"https://isocpp.org/blog/2015/09/bjarne-stroustrup-announces-cpp-core-guidelines\"\
    \ rel=\"noreferrer\">announced at CppCon'15 by Bjarne Stroustrup and others</a>\
    \ and welcomes contributions from the community. Most guidelines are supplemented\
    \ with a rationale and examples as well as discussions of possible tool support.\
    \ Many rules are designed specifically to be automatically checkable by static\
    \ analysis tools.</p></li><li><p>The <a href=\"https://isocpp.org/faq\" rel=\"\
    noreferrer\"><em>C++ Super-FAQ</em></a> (Marshall Cline, Bjarne Stroustrup and\
    \ others) is an effort by the Standard C++ Foundation to unify the C++ FAQs previously\
    \ maintained individually by Marshall Cline and Bjarne Stroustrup and also incorporating\
    \ new contributions. The items mostly address issues at an intermediate level\
    \ and are often written with a humorous tone. Not all items might be fully up\
    \ to date with the latest edition of the C++ standard yet.</p></li><li><p><a href=\"\
    http://en.cppreference.com/\" rel=\"noreferrer\"><em>cppreference.com (C++03/11/14/17/…)</em></a>\
    \ (initiated by Nate Kohl) is a wiki that summarizes the basic core-language features\
    \ and has extensive documentation of the C++ standard library. The documentation\
    \ is very precise but is easier to read than the official standard document and\
    \ provides better navigation due to its wiki nature. The project documents all\
    \ versions of the C++ standard and the site allows filtering the display for a\
    \ specific version. The project was <a href=\"https://isocpp.org/blog/2015/07/cppcon-2014-cppreference.com-documenting-cpp-one-edit-at-a-time-nate-kohl\"\
    \ rel=\"noreferrer\">presented by Nate Kohl at CppCon'14</a>.</p></li></ul><hr/><h2>Classics\
    \ / Older</h2><p><strong>Note:</strong> Some information contained within these\
    \ books may not be up-to-date or no longer considered best practice.</p><ul><li><p><a\
    \ href=\"https://rads.stackoverflow.com/amzn/click/com/0201543303\" rel=\"noreferrer\"\
    ><em>The Design and Evolution of C++</em></a> (Bjarne Stroustrup)  If you want\
    \ to know <em>why</em> the language is the way it is, this book is where you find\
    \ answers. This covers everything <em>before the standardization</em> of C++.</p></li><li><p><a\
    \ href=\"https://rads.stackoverflow.com/amzn/click/com/0201423391\" rel=\"noreferrer\"\
    ><em>Ruminations on C++</em></a> - (Andrew Koenig and Barbara Moo) <a href=\"\
    http://accu.org/index.php?module=bookreviews&amp;func=search&amp;rid=776\" rel=\"\
    noreferrer\">[Review]</a></p></li><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201548550\"\
    \ rel=\"noreferrer\"><em>Advanced C++ Programming Styles and Idioms</em></a> (James\
    \ Coplien)  A predecessor of the pattern movement, it describes many C++-specific\
    \ “idioms”. It's certainly a very good book and might still be worth a read if\
    \ you can spare the time, but quite old and not up-to-date with current C++. </p></li><li><p><a\
    \ href=\"https://rads.stackoverflow.com/amzn/click/com/0201633620\" rel=\"noreferrer\"\
    ><em>Large Scale C++ Software Design</em></a> (John Lakos)  Lakos explains techniques\
    \ to manage very big C++ software projects. Certainly, a good read, if it only\
    \ was up to date. It was written long before C++ 98 and misses on many features\
    \ (e.g. namespaces) important for large-scale projects. If you need to work in\
    \ a big C++ software project, you might want to read it, although you need to\
    \ take more than a grain of salt with it. The first volume of a new edition is\
    \ <a href=\"https://rads.stackoverflow.com/amzn/click/com/0201717069\" rel=\"\
    noreferrer\">expected in 2018</a>.</p></li><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201834545\"\
    \ rel=\"noreferrer\"><em>Inside the C++ Object Model</em></a> (Stanley Lippman)\
    \  If you want to know how virtual member functions are commonly implemented and\
    \ how base objects are commonly laid out in memory in a multi-inheritance scenario,\
    \ and how all this affects performance, this is where you will find thorough discussions\
    \ of such topics.</p></li><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201514591\"\
    \ rel=\"noreferrer\"><em>The Annotated C++ Reference Manual</em></a> (Bjarne Stroustrup,\
    \ Margaret A. Ellis) This book is quite outdated in the fact that it explores\
    \ the 1989 C++ 2.0 version - Templates, exceptions, namespaces and new casts were\
    \ not yet introduced. Saying that however, this book goes through the entire C++\
    \ standard of the time explaining the rationale, the possible implementations,\
    \ and features of the language. This is not a book to learn programming principles\
    \ and patterns on C++, but to understand every aspect of the C++ language.</p></li><li><p><a\
    \ href=\"https://rads.stackoverflow.com/amzn/click/com/0139798099\" rel=\"noreferrer\"\
    ><em>Thinking in C++</em></a> (Bruce Eckel, 2nd Edition, 2000).  Two volumes;\
    \ is a tutorial style <em>free</em> set of intro level books. Downloads: <a href=\"\
    https://ia800100.us.archive.org/10/items/TICPP2ndEdVolOne/TICPP-2nd-ed-Vol-one.zip\"\
    \ rel=\"noreferrer\">vol 1</a>, <a href=\"https://ia800108.us.archive.org/24/items/TICPP2ndEdVolTwo/TICPP-2nd-ed-Vol-two.zip\"\
    \ rel=\"noreferrer\">vol 2</a>. Unfortunately they’re marred by a number of trivial\
    \ errors (e.g. maintaining that temporaries are automatically <code>const</code>),\
    \ with no official errata list. A partial 3<sup>rd</sup> party errata list is\
    \ available at (<a href=\"http://www.computersciencelab.com/Eckel.htm\" rel=\"\
    noreferrer\">http://www.computersciencelab.com/Eckel.htm</a>), but it’s apparently\
    \ not maintained.</p></li><li><p><a href=\"https://rads.stackoverflow.com/amzn/click/com/0201533936\"\
    \ rel=\"noreferrer\"><em>Scientific and Engineering C++: An Introduction to Advanced\
    \ Techniques and Examples</em></a> (John Barton and Lee Nackman) It is a comprehensive\
    \ and very detailed book that tried to explain and make use of all the features\
    \ available in C++, in the context of numerical methods. It introduced at the\
    \ time several new techniques, such as the Curiously Recurring Template Pattern\
    \ (CRTP, also called Barton-Nackman trick).It pioneered several techniques such\
    \ as dimensional analysis and automatic differentiation. It came with a lot of\
    \ compilable and useful code, ranging from an expression parser to a Lapack wrapper.\
    \ The code is still available here: <a href=\"http://www.informit.com/store/scientific-and-engineering-c-plus-plus-an-introduction-9780201533934\"\
    \ rel=\"noreferrer\">http://www.informit.com/store/scientific-and-engineering-c-plus-plus-an-introduction-9780201533934</a>.Unfortunately,\
    \ the books have become somewhat outdated in the style and C++ features, however,\
    \ it was an incredible tour-de-force at the time (1994, pre-STL).The chapters\
    \ on dynamics inheritance are a bit complicated to understand and not very useful.An\
    \ updated version of this classic book that includes move semantics and the lessons\
    \ learned from the STL would be very nice.</p></li></ul></div>"
- - What are the differences between a pointer variable and a reference variable in
    C++?
  - "<div class=\"post-text\" itemprop=\"text\"><ol><li><p>A pointer can be re-assigned:\
    \ </p><pre><code>int x = 5;int y = 6;int *p;p =  &amp;x;p = &amp;y;*p = 10;assert(x\
    \ == 5);assert(y == 10);</code></pre><p>A reference cannot, and must be assigned\
    \ at initialization:</p><pre><code>int x = 5;int y = 6;int &amp;r = x;</code></pre></li><li><p>A\
    \ pointer has its own memory address and size on the stack (4 bytes on x86), whereas\
    \ a reference shares the same memory address (with the original variable) but\
    \ also takes up some space on the stack.  Since a reference has the same address\
    \ as the original variable itself, it is safe to think of a reference as another\
    \ name for the same variable.  Note: What a pointer points to can be on the stack\
    \ or heap.  Ditto a reference. My claim in this statement is not that a pointer\
    \ must point to the stack.  A pointer is just a variable that holds a memory address.\
    \  This variable is on the stack.  Since a reference has its own space on the\
    \ stack, and since the address is the same as the variable it references.  More\
    \ on <a href=\"https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936\"\
    >stack vs heap</a>.  This implies that there is a real address of a reference\
    \ that the compiler will not tell you. </p><pre><code>int x = 0;int &amp;r = x;int\
    \ *p = &amp;x;int *p2 = &amp;r;assert(p == p2);</code></pre></li><li><p>You can\
    \ have pointers to pointers to pointers offering extra levels of indirection.\
    \  Whereas references only offer one level of indirection. </p><pre><code>int\
    \ x = 0;int y = 0;int *p = &amp;x;int *q = &amp;y;int **pp = &amp;p;pp = &amp;q;//*pp\
    \ = q**pp = 4;assert(y == 4);assert(x == 0);</code></pre></li><li><p>Pointer can\
    \ be assigned <code>nullptr</code> directly, whereas reference cannot. If you\
    \ try hard enough, and you know how, you can make the address of a reference <code>nullptr</code>.\
    \  Likewise, if you try hard enough you can have a reference to a pointer, and\
    \ then that reference can contain <code>nullptr</code>.</p><pre><code>int *p =\
    \ nullptr;int &amp;r = nullptr; &lt;--- compiling errorint &amp;r = *p;  &lt;---\
    \ likely no compiling error, especially if the nullptr is hidden behind a function\
    \ call, yet it refers to a non-existent int at address 0</code></pre></li><li><p>Pointers\
    \ can iterate over an array, you can use <code>++</code> to go to the next item\
    \ that a pointer is pointing to, and <code>+ 4</code> to go to the 5th element.\
    \  This is no matter what size the object is that the pointer points to.</p></li><li><p>A\
    \ pointer needs to be dereferenced with <code>*</code> to access the memory location\
    \ it points to, whereas a reference can be used directly.  A pointer to a class/struct\
    \ uses <code>-&gt;</code> to access it's members whereas a reference uses a <code>.</code>.</p></li><li><p>A\
    \ pointer is a variable that holds a memory address.  Regardless of how a reference\
    \ is implemented, a reference has the same memory address as the item it references.</p></li><li><p>References\
    \ cannot be stuffed into an array, whereas pointers can be (Mentioned by user\
    \ @litb)</p></li><li><p>Const references can be bound to temporaries. Pointers\
    \ cannot (not without some indirection):</p><pre><code>const int &amp;x = int(12);\
    \ //legal C++int *y = &amp;int(12); //illegal to dereference a temporary.</code></pre><p>This\
    \ makes <code>const&amp;</code> safer for use in argument lists and so forth.</p></li></ol></div>"
- - What are the differences between a pointer variable and a reference variable in
    C++?
  - "<div class=\"post-text\" itemprop=\"text\"><h1>What's a C++ reference (<em>for\
    \ C programmers</em>)</h1><p>A <em>reference</em> can be thought of as a <em>constant\
    \ pointer</em> (not to be confused with a pointer to a constant value!) with automatic\
    \ indirection, ie the compiler will apply the <code>*</code> operator for you.</p><p>All\
    \ references must be initialized with a non-null value or compilation will fail.\
    \ It's neither possible to get the address of a reference - the address operator\
    \ will return the address of the referenced value instead - nor is it possible\
    \ to do arithmetics on references.</p><p>C programmers might dislike C++ references\
    \ as it will no longer be obvious when indirection happens or if an argument gets\
    \ passed by value or by pointer without looking at function signatures.</p><p>C++\
    \ programmers might dislike using pointers as they are considered unsafe - although\
    \ references aren't really any safer than constant pointers except in the most\
    \ trivial cases - lack the convenience of automatic indirection and carry a different\
    \ semantic connotation.</p><p>Consider the following statement from the <a href=\"\
    https://isocpp.org/wiki/faq/references#overview-refs\" rel=\"noreferrer\"><em>C++\
    \ FAQ</em></a>:</p><blockquote><p>Even though a reference is often implemented\
    \ using an address in the  underlying assembly language, please do <em>not</em>\
    \ think of a reference as a  funny looking pointer to an object. A reference <em>is</em>\
    \ the object. It is  not a pointer to the object, nor a copy of the object. It\
    \ <em>is</em> the  object.</p></blockquote><p>But if a reference <em>really</em>\
    \ were the object, how could there be dangling references? In unmanaged languages,\
    \ it's impossible for references to be any 'safer' than pointers - there generally\
    \ just isn't a way to reliably alias values across scope boundaries!</p><h1>Why\
    \ I consider C++ references useful</h1><p>Coming from a C background, C++ references\
    \ may look like a somewhat silly concept, but one should still use them instead\
    \ of pointers where possible: Automatic indirection <em>is</em> convenient, and\
    \ references become especially useful when dealing with <a href=\"https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\"\
    \ rel=\"noreferrer\">RAII</a> - but not because of any perceived safety advantage,\
    \ but rather because they make writing idiomatic code less awkward.</p><p>RAII\
    \ is one of the central concepts of C++, but it interacts non-trivially with copying\
    \ semantics. Passing objects by reference avoids these issues as no copying is\
    \ involved. If references were not present in the language, you'd have to use\
    \ pointers instead, which are more cumbersome to use, thus violating the language\
    \ design principle that the best-practice solution should be easier than the alternatives.</p></div>"
- - What are the differences between a pointer variable and a reference variable in
    C++?
  - "<div class=\"post-text\" itemprop=\"text\"><p>If you want to be really pedantic,\
    \ there is one thing you can do with a reference that you can't do with a pointer:\
    \ extend the lifetime of a temporary object. In C++ if you bind a const reference\
    \ to a temporary object, the lifetime of that object becomes the lifetime of the\
    \ reference.</p><pre><code>std::string s1 = \"123\";std::string s2 = \"456\";std::string\
    \ s3_copy = s1 + s2;const std::string&amp; s3_reference = s1 + s2;</code></pre><p>In\
    \ this example s3_copy copies the temporary object that is a result of the concatenation.\
    \ Whereas s3_reference in essence becomes the temporary object. It's really a\
    \ reference to a temporary object that now has the same lifetime as the reference.\
    \ </p><p>If you try this without the <code>const</code> it should fail to compile.\
    \ You cannot bind a non-const reference to a temporary object, nor can you take\
    \ its address for that matter.</p></div>"
- - How do I iterate over the words of a string?
  - <div class="post-text" itemprop="text"><p>For what it's worth, here's another
    way to extract tokens from an input string, relying only on standard library facilities.
    It's an example of the power and elegance behind the design of the STL.</p><pre><code>#include
    &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;#include &lt;algorithm&gt;#include
    &lt;iterator&gt;int main() {    using namespace std;    string sentence = "And
    I feel fine...";    istringstream iss(sentence);    copy(istream_iterator&lt;string&gt;(iss),         istream_iterator&lt;string&gt;(),         ostream_iterator&lt;string&gt;(cout,
    "\n"));}</code></pre><p>Instead of copying the extracted tokens to an output stream,
    one could insert them into a container, using the same generic <code>copy</code>
    algorithm.</p><pre><code>vector&lt;string&gt; tokens;copy(istream_iterator&lt;string&gt;(iss),     istream_iterator&lt;string&gt;(),     back_inserter(tokens));</code></pre><p>...
    or create the <code>vector</code> directly:</p><pre><code>vector&lt;string&gt;
    tokens{istream_iterator&lt;string&gt;{iss},                      istream_iterator&lt;string&gt;{}};</code></pre></div>
- - How do I iterate over the words of a string?
  - <div class="post-text" itemprop="text"><p>I use this to split string by a delimiter.
    The first puts the results in a pre-constructed vector, the second returns a new
    vector.</p><pre class="lang-c++ prettyprint-override"><code>#include &lt;string&gt;#include
    &lt;sstream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;template&lt;typename
    Out&gt;void split(const std::string &amp;s, char delim, Out result) {    std::stringstream
    ss(s);    std::string item;    while (std::getline(ss, item, delim)) {        *(result++)
    = item;    }}std::vector&lt;std::string&gt; split(const std::string &amp;s, char
    delim) {    std::vector&lt;std::string&gt; elems;    split(s, delim, std::back_inserter(elems));    return
    elems;}</code></pre><hr/><p>Note that this solution does not skip empty tokens,
    so the following will find 4 items, one of which is empty:</p><pre class="lang-c++
    prettyprint-override"><code>std::vector&lt;std::string&gt; x = split("one:two::three",
    ':');</code></pre></div>
- - How do I iterate over the words of a string?
  - <div class="post-text" itemprop="text"><p>A possible solution using Boost might
    be:</p><pre><code>#include &lt;boost/algorithm/string.hpp&gt;std::vector&lt;std::string&gt;
    strs;boost::split(strs, "string to split", boost::is_any_of("\t "));</code></pre><p>This
    approach might be even faster than the <code>stringstream</code> approach. And
    since this is a generic template function it can be used to split other types
    of strings (wchar, etc. or UTF-8) using all kinds of delimiters.</p><p>See the
    <a href="http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html"
    rel="noreferrer">documentation</a> for details.</p></div>
- - What does the explicit keyword mean?
  - "<div class=\"post-text\" itemprop=\"text\"><p>The compiler is allowed to make\
    \ one implicit conversion to resolve the parameters to a function. What this means\
    \ is that the compiler can use constructors callable with a <strong>single parameter</strong>\
    \ to convert from one type to another in order to get the right type for a parameter.\
    \ </p><p>Here's an example class with a constructor that can be used for implicit\
    \ conversions:</p><pre><code>class Foo{public:  // single parameter constructor,\
    \ can be used as an implicit conversion  Foo (int foo) : m_foo (foo)   {  }  int\
    \ GetFoo () { return m_foo; }private:  int m_foo;};</code></pre><p>Here's a simple\
    \ function that takes a <code>Foo</code> object:</p><pre><code>void DoBar (Foo\
    \ foo){  int i = foo.GetFoo ();}</code></pre><p>and here's where the <code>DoBar</code>\
    \ function is called.</p><pre><code>int main (){  DoBar (42);}</code></pre><p>The\
    \ argument is not a <code>Foo</code> object, but an <code>int</code>. However,\
    \ there exists a constructor for <code>Foo</code> that takes an <code>int</code>\
    \ so this constructor can be used to convert the parameter to the correct type.</p><p>The\
    \ compiler is allowed to do this once for each parameter.</p><p>Prefixing the\
    \ <code>explicit</code> keyword to the constructor prevents the compiler from\
    \ using that constructor for implicit conversions. Adding it to the above class\
    \ will create a compiler error at the function call <code>DoBar (42)</code>. \
    \ It is now necessary to call for conversion explicitly with  <code>DoBar (Foo\
    \ (42))</code></p><p>The reason you might want to do this is to avoid accidental\
    \ construction that can hide bugs.  Contrived example:</p><ul><li>You have a <code>MyString(int\
    \ size)</code> class with a constructor that constructs a string of the given\
    \ size.  You have a function <code>print(const MyString&amp;)</code>, and you\
    \ call <code>print(3)</code> (when you <em>actually</em> intended to call <code>print(\"\
    3\")</code>).  You expect it to print \"3\", but it prints an empty string of\
    \ length 3 instead.</li></ul></div>"
- - What does the explicit keyword mean?
  - "<div class=\"post-text\" itemprop=\"text\"><p>Suppose, you have a class <code>String</code>:</p><pre><code>class\
    \ String {public:    String(int n); // allocate n bytes to the String object \
    \   String(const char *p); // initializes object with char *p};</code></pre><p>Now,\
    \ if you try:</p><pre><code>String mystring = 'x';</code></pre><p>The character\
    \ <code>'x'</code> will be implicitly converted to <code>int</code> and then the\
    \ <code>String(int)</code> constructor will be called. But, this is not what the\
    \ user might have intended. So, to prevent such conditions, we shall define the\
    \ constructor as <code>explicit</code>:</p><pre><code>class String {public:  \
    \  explicit String (int n); //allocate n bytes    String(const char *p); // initialize\
    \ sobject with string p};</code></pre></div>"
- - What does the explicit keyword mean?
  - <div class="post-text" itemprop="text"><p>In C++, a constructor with only one
    required parameter is considered an implicit conversion function.  It converts
    the parameter type to the class type.  Whether this is a good thing or not depends
    on the semantics of the constructor.</p><p>For example, if you have a string class
    with constructor <code>String(const char* s)</code>, that's probably exactly what
    you want.  You can pass a <code>const char*</code> to a function expecting a <code>String</code>,
    and the compiler will automatically construct a temporary <code>String</code>
    object for you.</p><p>On the other hand, if you have a buffer class whose constructor
    <code>Buffer(int size)</code> takes the size of the buffer in bytes, you probably
    don't want the compiler to quietly turn <code>int</code>s into <code>Buffer</code>s.  To
    prevent that, you declare the constructor with the <code>explicit</code> keyword:</p><pre><code>class
    Buffer { explicit Buffer(int size); ... }</code></pre><p>That way,</p><pre><code>void
    useBuffer(Buffer&amp; buf);useBuffer(4);</code></pre><p>becomes a compile-time
    error.  If you want to pass a temporary <code>Buffer</code> object, you have to
    do so explicitly:</p><pre><code>useBuffer(Buffer(4));</code></pre><p>In summary,
    if your single-parameter constructor converts the parameter into an object of
    your class, you probably don't want to use the <code>explicit</code> keyword.  But
    if you have a constructor that simply happens to take a single parameter, you
    should declare it as <code>explicit</code> to prevent the compiler from surprising
    you with unexpected conversions.</p></div>
- - Why is “using namespace std” considered bad practice?
  - "<div class=\"post-text\" itemprop=\"text\"><p>This is not related to performance\
    \ at all. But consider this: you are using two libraries called Foo and Bar:</p><pre><code>using\
    \ namespace foo;using namespace bar;</code></pre><p>Everything works fine, you\
    \ can call <code>Blah()</code> from Foo and <code>Quux()</code> from Bar without\
    \ problems. But one day you upgrade to a new version of Foo 2.0, which now offers\
    \ a function called <code>Quux()</code>. Now you've got a conflict: Both Foo 2.0\
    \ and Bar import <code>Quux()</code> into your global namespace. This is going\
    \ to take some effort to fix, especially if the function parameters happen to\
    \ match.</p><p>If you had used <code>foo::Blah()</code> and <code>bar::Quux()</code>,\
    \ then the introduction of <code>foo::Quux()</code> would have been a non-event.</p></div>"
- - Why is “using namespace std” considered bad practice?
  - "<div class=\"post-text\" itemprop=\"text\"><p>I agree with everything <a href=\"\
    https://stackoverflow.com/questions/1452721/1452738#1452738\">Greg wrote</a>,\
    \ but I'd like to add: <strong><em>It can even get worse than Greg said!</em></strong></p><p>Library\
    \ Foo 2.0 could introduce a function, <code>Quux()</code>, that is an unambiguously\
    \ better match for some of your calls to <code>Quux()</code> than the <code>bar::Quux()</code>\
    \ your code called for years. Then your <strong><em>code still compiles</em></strong>,\
    \ but <strong><em>it silently calls the wrong function</em></strong> and does\
    \ god-knows-what. That's about as bad as things can get.</p><p>Keep in mind that\
    \ the <code>std</code> namespace has tons of identifiers, many of which are <em>very</em>\
    \ common ones (think <code>list</code>, <code>sort</code>, <code>string</code>,\
    \ <code>iterator</code>, etc.) which are very likely to appear in other code,\
    \ too.</p><p>If you consider this unlikely: There was <a href=\"https://stackoverflow.com/a/2712125/140719\"\
    >a question asked</a> here on Stack Overflow where pretty much exactly this happened\
    \ (wrong function called due to omitted <code>std::</code> prefix) about half\
    \ a year after I gave this answer. <a href=\"https://stackoverflow.com/questions/13402789/\"\
    >Here</a> is another, more recent example of such a question.So this is a real\
    \ problem.</p><hr/><p>Here's one more data point: Many, many years ago, I also\
    \ used to find it annoying having to prefix everything from the standard library\
    \ with <code>std::</code>. Then I worked in a project where it was decided at\
    \ the start that both <code>using</code> directives and declarations are banned\
    \ except for function scopes. Guess what? It took most of us very few weeks to\
    \ get used to writing the prefix, and after a few more weeks most of us even agreed\
    \ that it actually made the code <em>more readable</em>. There's a reason for\
    \ that: <strong><em>Whether you like shorter or longer prose is subjective, but\
    \ the prefixes objectively add clarity to the code.</em></strong> Not only the\
    \ compiler, but you, too, find it easier to see which identifier is referred to.</p><p>In\
    \ a decade, that project grew to have several million lines of code. Since these\
    \ discussions come up again and again, I once was curious how often the (allowed)\
    \ function-scope <code>using</code> actually was used in the project. I grep'd\
    \ the sources for it and only found one or two dozen places where it was used.\
    \ To me this indicates that, once tried, developers don't find <code>std::</code>\
    \ painful enough to employ using directives even once every 100 kLoC even where\
    \ it was allowed to be used.</p><hr/><p>Bottom line: Explicitly prefixing everything\
    \ doesn't do any harm, takes very little getting used to, and has objective advantages.\
    \ In particular, it makes the code easier to interpret by the compiler and by\
    \ human readers — and that should probably be the main goal when writing code.</p></div>"
- - Why is “using namespace std” considered bad practice?
  - <div class="post-text" itemprop="text"><p>The problem with putting <code>using
    namespace</code> in the header files of your classes is that it forces anyone
    who wants to use your classes (by including your header files) to also be 'using'
    (i.e. seeing everything in) those other namespaces.</p><p>However, you may feel
    free to put a using statement in your (private) *.cpp files.</p><hr/><p>Beware
    that some people disagree with my saying "feel free" like this -- because although
    a using statement in a cpp file is <em>better</em> than in a header (because it
    doesn't affect people who include your header file), they think it's still not
    <em>good</em> (because depending on the code it could make the implementation
    of the class more difficult to maintain). <a href="https://isocpp.org/wiki/faq/coding-standards#using-namespace-std"
    rel="noreferrer">This FAQ topic</a> says,</p><blockquote><p>The using-directive
    exists for legacy C++ code and to ease the transition to namespaces, but you probably
    shouldn’t use it on a regular basis, at least not in your new C++ code.</p></blockquote><p>The
    FAQ suggests two alternatives:</p><ul><li><p>A using-declaration:</p><pre><code>using
    std::cout; // a using-declaration lets you use cout without qualificationcout
    &lt;&lt; "Values:";</code></pre></li><li><p>Just typing std::</p><pre><code>std::cout
    &lt;&lt; "Values:";</code></pre></li></ul></div>
- - How do you set, clear, and toggle a single bit?
  - <div class="post-text" itemprop="text"><h1>Setting a bit</h1><p>Use the bitwise
    OR operator (<code>|</code>) to set a bit.</p><pre><code>number |= 1UL &lt;&lt;
    n;</code></pre><p>That will set the <code>n</code>th bit of <code>number</code>.
    <code>n</code> should be zero, if you want to set the <code>1</code>st bit and
    so on upto <code>n-1</code>, if you want to set the <code>n</code>th bit.</p><p>Use
    <code>1ULL</code> if <code>number</code> is wider than <code>unsigned long</code>;
    promotion of <code>1UL &lt;&lt; n</code> doesn't happen until after evaluating
    <code>1UL &lt;&lt; n</code> where it's undefined behaviour to shift by more than
    the width of a <code>long</code>.  The same applies to all the rest of the examples.</p><h1>Clearing
    a bit</h1><p>Use the bitwise AND operator (<code>&amp;</code>) to clear a bit.</p><pre><code>number
    &amp;= ~(1UL &lt;&lt; n);</code></pre><p>That will clear the <code>n</code>th
    bit of <code>number</code>. You must invert the bit string with the bitwise NOT
    operator (<code>~</code>), then AND it.</p><h1>Toggling a bit</h1><p>The XOR operator
    (<code>^</code>) can be used to toggle a bit.</p><pre><code>number ^= 1UL &lt;&lt;
    n;</code></pre><p>That will toggle the <code>n</code>th bit of <code>number</code>.</p><h1>Checking
    a bit</h1><p>You didn't ask for this, but I might as well add it.</p><p>To check
    a bit, shift the number n to the right, then bitwise AND it:</p><pre><code>bit
    = (number &gt;&gt; n) &amp; 1U;</code></pre><p>That will put the value of the
    <code>n</code>th bit of <code>number</code> into the variable <code>bit</code>.</p><h1>Changing
    the <em>n</em>th bit to <em>x</em></h1><p>Setting the <code>n</code>th bit to
    either <code>1</code> or <code>0</code> can be achieved with the following on
    a 2's complement C++ implementation:</p><pre><code>number ^= (-x ^ number) &amp;
    (1UL &lt;&lt; n);</code></pre><p>Bit <code>n</code> will be set if <code>x</code>
    is <code>1</code>, and cleared if <code>x</code> is <code>0</code>.  If <code>x</code>
    has some other value, you get garbage.  <code>x = !!x</code> will booleanize it
    to 0 or 1.</p><p>To make this independent of 2's complement negation behaviour
    (where <code>-1</code> has all bits set, unlike on a 1's complement or sign/magnitude
    C++ implementation), use unsigned negation.</p><pre><code>number ^= (-(unsigned
    long)x ^ number) &amp; (1UL &lt;&lt; n);</code></pre><p>or</p><pre><code>unsigned
    long newbit = !!x;    // Also booleanize to force 0 or 1number ^= (-newbit ^ number)
    &amp; (1UL &lt;&lt; n);</code></pre><p>It's generally a good idea to use unsigned
    types for portable bit manipulation.</p><p>It's also generally a good idea to
    not to copy/paste code in general and so many people use preprocessor macros (like
    <a href="https://stackoverflow.com/a/263738/52074">the community wiki answer further
    down</a>) or some sort of encapsulation.</p></div>
- - How do you set, clear, and toggle a single bit?
  - '<div class="post-text" itemprop="text"><p>Using the Standard C++ Library: <a
    href="http://en.cppreference.com/w/cpp/utility/bitset" rel="noreferrer"><code>std::bitset&lt;N&gt;</code></a>.</p><p>Or
    the <a href="http://en.wikipedia.org/wiki/Boost_%28C%2B%2B_libraries%29" rel="noreferrer">Boost</a>
    version: <a href="http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html"
    rel="noreferrer"><code>boost::dynamic_bitset</code></a>.</p><p>There is no need
    to roll your own:</p><pre><code>#include &lt;bitset&gt;#include &lt;iostream&gt;int
    main(){    std::bitset&lt;5&gt; x;    x[1] = 1;    x[2] = 0;    // Note x[0-4]  valid    std::cout
    &lt;&lt; x &lt;&lt; std::endl;}</code></pre><hr/><pre><code>[Alpha:] &gt; ./a.out00010</code></pre><p>The
    Boost version allows a runtime sized bitset compared with a <a href="https://en.wikipedia.org/wiki/C%2B%2B_Standard_Library"
    rel="noreferrer">standard library</a> compile-time sized bitset.</p></div>'
- - How do you set, clear, and toggle a single bit?
  - <div class="post-text" itemprop="text"><p>The other option is to use bit fields:</p><pre><code>struct
    bits {    unsigned int a:1;    unsigned int b:1;    unsigned int c:1;};struct
    bits mybits;</code></pre><p>defines a 3-bit field (actually, it's three 1-bit
    felds). Bit operations now become a bit (haha) simpler:</p><p>To set or clear
    a bit:</p><pre><code>mybits.b = 1;mybits.c = 0;</code></pre><p>To toggle a bit:</p><pre><code>mybits.a
    = !mybits.a;mybits.b = ~mybits.b;mybits.c ^= 1;  /* all work */</code></pre><p>Checking
    a bit:</p><pre><code>if (mybits.c)  //if mybits.c is non zero the next line below
    will execute</code></pre><p>This only works with fixed-size bit fields. Otherwise
    you have to resort to the bit-twiddling techniques described in previous posts.</p></div>
- - When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?
  - <div class="post-text" itemprop="text"><p><strong><code>static_cast</code></strong>
    is the first cast you should attempt to use. It does things like implicit conversions
    between types (such as <code>int</code> to <code>float</code>, or pointer to <code>void*</code>),
    and it can also call explicit conversion functions (or implicit ones). In many
    cases, explicitly stating <code>static_cast</code> isn't necessary, but it's important
    to note that the <code>T(something)</code> syntax is equivalent to <code>(T)something</code>
    and should be avoided (more on that later). A <code>T(something, something_else)</code>
    is safe, however, and guaranteed to call the constructor.</p><p><code>static_cast</code>
    can also cast through inheritance hierarchies. It is unnecessary when casting
    upwards (towards a base class), but when casting downwards it can be used as long
    as it doesn't cast through <code>virtual</code> inheritance. It does not do checking,
    however, and it is undefined behavior to <code>static_cast</code> down a hierarchy
    to a type that isn't actually the type of the object.</p><hr/><p><strong><code>const_cast</code></strong>
    can be used to remove or add <code>const</code> to a variable; no other C++ cast
    is capable of removing it (not even <code>reinterpret_cast</code>). It is important
    to note that modifying a formerly <code>const</code> value is only undefined if
    the original variable is <code>const</code>; if you use it to take the <code>const</code>
    off a reference to something that wasn't declared with <code>const</code>, it
    is safe. This can be useful when overloading member functions based on <code>const</code>,
    for instance. It can also be used to add <code>const</code> to an object, such
    as to call a member function overload.</p><p><code>const_cast</code> also works
    similarly on <code>volatile</code>, though that's less common.</p><hr/><p><strong><code>dynamic_cast</code></strong>
    is almost exclusively used for handling polymorphism. You can cast a pointer or
    reference to any polymorphic type to any other class type (a polymorphic type
    has at least one virtual function, declared or inherited). You can use it for
    more than just casting downwards -- you can cast sideways or even up another chain.
    The <code>dynamic_cast</code> will seek out the desired object and return it if
    possible. If it can't, it will return <code>nullptr</code> in the case of a pointer,
    or throw <code>std::bad_cast</code> in the case of a reference.</p><p><code>dynamic_cast</code>
    has some limitations, though. It doesn't work if there are multiple objects of
    the same type in the inheritance hierarchy (the so-called 'dreaded diamond') and
    you aren't using <code>virtual</code> inheritance. It also can only go through
    public inheritance - it will always fail to travel through <code>protected</code>
    or <code>private</code> inheritance. This is rarely an issue, however, as such
    forms of inheritance are rare.</p><hr/><p><strong><code>reinterpret_cast</code></strong>
    is the most dangerous cast, and should be used very sparingly. It turns one type
    directly into another - such as casting the value from one pointer to another,
    or storing a pointer in an <code>int</code>, or all sorts of other nasty things.
    Largely, the only guarantee you get with <code>reinterpret_cast</code> is that
    normally if you cast the result back to the original type, you will get the exact
    same value (but <strong><em>not</em></strong> if the intermediate type is smaller
    than the original type). There are a number of conversions that <strong><code>reinterpret_cast</code></strong>
    cannot do, too. It's used primarily for particularly weird conversions and bit
    manipulations, like turning a raw data stream into actual data, or storing data
    in the low bits of an aligned pointer.</p><hr/><p><strong>C-style cast</strong>
    and <strong>function-style cast</strong> are casts using <code>(type)object</code>
    or <code>type(object)</code>, respectively. A C-style cast is defined as the first
    of the following which succeeds:</p><ul><li><code>const_cast</code></li><li><code>static_cast</code>
    (though ignoring access restrictions)</li><li><code>static_cast</code> (see above),
    then <code>const_cast</code></li><li><code>reinterpret_cast</code></li><li><code>reinterpret_cast</code>,
    then <code>const_cast</code></li></ul><p>It can therefore be used as a replacement
    for other casts in some instances, but can be extremely dangerous because of the
    ability to devolve into a <code>reinterpret_cast</code>, and the latter should
    be preferred when explicit casting is needed, unless you are sure <code>static_cast</code>
    will succeed or <code>reinterpret_cast</code> will fail. Even then, consider the
    longer, more explicit option.</p><p>C-style casts also ignore access control when
    performing a <code>static_cast</code>, which means that they have the ability
    to perform an operation that no other cast can. This is mostly a kludge, though,
    and in my mind is just another reason to avoid C-style casts.</p></div>
- - When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?
  - <div class="post-text" itemprop="text"><p>Use <code>dynamic_cast</code> for converting
    pointers/references within an inheritance hierarchy.</p><p>Use <code>static_cast</code>
    for ordinary type conversions.</p><p>Use <code>reinterpret_cast</code> for low-level
    reinterpreting of bit patterns.  Use with extreme caution.</p><p>Use <code>const_cast</code>
    for casting away <code>const/volatile</code>.  Avoid this unless you are stuck
    using a const-incorrect API.</p></div>
- - When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?
  - '<div class="post-text" itemprop="text"><p><em>(A lot of theoretical and conceptual
    explanation has been given above)</em> </p><p>Below are some of the <strong>practical
    examples</strong> when I used <strong>static_cast</strong>, <strong>dynamic_cast</strong>,
    <strong>const_cast</strong>, <strong>reinterpret_cast</strong>.</p><p>(Also referes
    this to understand the explaination : <a href="http://www.cplusplus.com/doc/tutorial/typecasting/"
    rel="noreferrer">http://www.cplusplus.com/doc/tutorial/typecasting/</a>)</p><p><strong>static_cast
    :</strong></p><pre><code>OnEventData(void* pData){  ......  //  pData is a void*
    pData,   //  EventData is a structure e.g.   //  typedef struct _EventData {  //  std::string
    id;  //  std:: string remote_id;  //  } EventData;  // On Some Situation a void
    pointer *pData  // has been static_casted as   // EventData* pointer   EventData
    *evtdata = static_cast&lt;EventData*&gt;(pData);  .....}</code></pre><p><strong>dynamic_cast
    :</strong></p><pre><code>void DebugLog::OnMessage(Message *msg){    static DebugMsgData
    *debug;    static XYZMsgData *xyz;    if(debug = dynamic_cast&lt;DebugMsgData*&gt;(msg-&gt;pdata)){        //
    debug message    }    else if(xyz = dynamic_cast&lt;XYZMsgData*&gt;(msg-&gt;pdata)){        //
    xyz message    }    else/* if( ... )*/{        // ...    }}</code></pre><p><strong>const_cast
    :</strong></p><pre><code>// *Passwd declared as a constconst unsigned char *Passwd//
    on some situation it require to remove its constnessconst_cast&lt;unsigned char*&gt;(Passwd)</code></pre><p><strong>reinterpret_cast
    :</strong></p><pre><code>typedef unsigned short uint16;// Read Bytes returns that
    2 bytes got read. bool ByteBuffer::ReadUInt16(uint16&amp; val) {  return ReadBytes(reinterpret_cast&lt;char*&gt;(&amp;val),
    2);}</code></pre></div>'
- - Why are elementwise additions much faster in separate loops than in a combined
    loop?
  - "<div class=\"post-text\" itemprop=\"text\"><p>Upon further analysis of this,\
    \ I believe this is (at least partially) caused by data alignment of the four\
    \ pointers. This will cause some level of cache bank/way conflicts.</p><p>If I've\
    \ guessed correctly on how you are allocating your arrays, they <strong><em>are\
    \ likely to be aligned to the page line</em></strong>.</p><p>This means that all\
    \ your accesses in each loop will fall on the same cache way. However, Intel processors\
    \ have had 8-way L1 cache associativity for a while. But in reality, the performance\
    \ isn't completely uniform. Accessing 4-ways is still slower than say 2-ways.</p><p><strong>EDIT\
    \ : It does in fact look like you are allocating all the arrays separately.</strong>Usually\
    \ when such large allocations are requested, the allocator will request fresh\
    \ pages from the OS. Therefore, there is a high chance that large allocations\
    \ will appear at the same offset from a page-boundary.</p><p><strong>Here's the\
    \ test code:</strong></p><pre><code>int main(){    const int n = 100000;#ifdef\
    \ ALLOCATE_SEPERATE    double *a1 = (double*)malloc(n * sizeof(double));    double\
    \ *b1 = (double*)malloc(n * sizeof(double));    double *c1 = (double*)malloc(n\
    \ * sizeof(double));    double *d1 = (double*)malloc(n * sizeof(double));#else\
    \    double *a1 = (double*)malloc(n * sizeof(double) * 4);    double *b1 = a1\
    \ + n;    double *c1 = b1 + n;    double *d1 = c1 + n;#endif    //  Zero the data\
    \ to prevent any chance of denormals.    memset(a1,0,n * sizeof(double));    memset(b1,0,n\
    \ * sizeof(double));    memset(c1,0,n * sizeof(double));    memset(d1,0,n * sizeof(double));\
    \    //  Print the addresses    cout &lt;&lt; a1 &lt;&lt; endl;    cout &lt;&lt;\
    \ b1 &lt;&lt; endl;    cout &lt;&lt; c1 &lt;&lt; endl;    cout &lt;&lt; d1 &lt;&lt;\
    \ endl;    clock_t start = clock();    int c = 0;    while (c++ &lt; 10000){#if\
    \ ONE_LOOP        for(int j=0;j&lt;n;j++){            a1[j] += b1[j];        \
    \    c1[j] += d1[j];        }#else        for(int j=0;j&lt;n;j++){           \
    \ a1[j] += b1[j];        }        for(int j=0;j&lt;n;j++){            c1[j] +=\
    \ d1[j];        }#endif    }    clock_t end = clock();    cout &lt;&lt; \"seconds\
    \ = \" &lt;&lt; (double)(end - start) / CLOCKS_PER_SEC &lt;&lt; endl;    system(\"\
    pause\");    return 0;}</code></pre><hr/><p><strong>Benchmark Results:</strong></p><h1>EDIT:\
    \ Results on an <em>actual</em> Core 2 architecture machine:</h1><p><strong>2\
    \ x Intel Xeon X5482 Harpertown @ 3.2 GHz:</strong></p><pre><code>#define ALLOCATE_SEPERATE#define\
    \ ONE_LOOP00600020006D0020007A002000870020seconds = 6.206#define ALLOCATE_SEPERATE//#define\
    \ ONE_LOOP005E0020006B00200078002000850020seconds = 2.116//#define ALLOCATE_SEPERATE#define\
    \ ONE_LOOP0057002000633520006F6A20007B9F20seconds = 1.894//#define ALLOCATE_SEPERATE//#define\
    \ ONE_LOOP008C00200098352000A46A2000B09F20seconds = 1.993</code></pre><p>Observations:</p><ul><li><p><strong>6.206\
    \ seconds</strong> with one loop and <strong>2.116 seconds</strong> with two loops.\
    \ This reproduces the OP's results exactly.</p></li><li><p><strong>In the first\
    \ two tests, the arrays are allocated separately.</strong> You'll notice that\
    \ they all have the same alignment relative to the page.</p></li><li><p><strong>In\
    \ the second two tests, the arrays are packed together to break that alignment.</strong>\
    \ Here you'll notice both loops are faster. Furthermore, the second (double) loop\
    \ is now the slower one as you would normally expect.</p></li></ul><p>As @Stephen\
    \ Cannon points out in the comments, there is very likely possibility that this\
    \ alignment causes <strong><em>false aliasing</em></strong> in the load/store\
    \ units or the cache. I Googled around for this and found that Intel actually\
    \ has a hardware counter for <strong><em>partial address aliasing</em></strong>\
    \ stalls:</p><p><a href=\"http://software.intel.com/sites/products/documentation/doclib/stdxe/2013/~amplifierxe/pmw_dp/events/partial_address_alias.html\"\
    >http://software.intel.com/sites/products/documentation/doclib/stdxe/2013/~amplifierxe/pmw_dp/events/partial_address_alias.html</a></p><hr/><h1>5\
    \ Regions - Explanations</h1><p><strong>Region 1:</strong></p><p>This one is easy.\
    \ The dataset is so small that the performance is dominated by overhead like looping\
    \ and branching.</p><p><strong>Region 2:</strong></p><p><strike>Here, as the data\
    \ sizes increases, the amount of relative overhead goes down and the performance\
    \ \"saturates\". Here two loops is slower because it has twice as much loop and\
    \ branching overhead.</strike></p><p>I'm not sure exactly what's going on here...\
    \ Alignment could still play an effect as Agner Fog mentions <a href=\"http://www.agner.org/optimize/blog/read.php?i=142\"\
    >cache bank conflicts</a>. (That link is about Sandy Bridge, but the idea should\
    \ still be applicable to Core 2.)</p><p><strong>Region 3:</strong></p><p>At this\
    \ point, the data no longer fits in L1 cache. So performance is capped by the\
    \ L1 &lt;-&gt; L2 cache bandwidth.</p><p><strong>Region 4:</strong></p><p>The\
    \ performance drop in the single-loop is what we are observing. And as mentioned,\
    \ this is due to the alignment which (most likely) causes <strong><em>false aliasing</em></strong>\
    \ stalls in the processor load/store units.</p><p>However, in order for false\
    \ aliasing to occur, there must be a large enough stride between the datasets.\
    \ This is why you don't see this in region 3.</p><p><strong>Region 5:</strong></p><p>At\
    \ this point, nothing fits in cache. So you're bound by memory bandwidth.</p><hr/><p><img\
    \ alt=\"2 x Intel X5482 Harpertown @ 3.2 GHz\" src=\"https://i.stack.imgur.com/ElCGL.png\"\
    /><img alt=\"Intel Core i7 870 @ 2.8 GHz\" src=\"https://i.stack.imgur.com/QMpwj.png\"\
    /><img alt=\"Intel Core i7 2600K @ 4.4 GHz\" src=\"https://i.stack.imgur.com/NpyhG.png\"\
    /></p></div>"
- - Why are elementwise additions much faster in separate loops than in a combined
    loop?
  - "<div class=\"post-text\" itemprop=\"text\"><p>OK, the right answer definitely\
    \ has to do something with the CPU cache. But to use the cache argument can be\
    \ quite difficult, especially without data.</p><p>There are many answers, that\
    \ led to a lot of discussion, but let's face it: Cache issues can be very complex\
    \ and are not one dimensional. They depend heavily on the size of the data, so\
    \ my question was unfair: It turned out to be at a very interesting point in the\
    \ cache graph.</p><p>@Mysticial's answer convinced a lot of people (including\
    \ me), probably because it was the only one that seemed to rely on facts, but\
    \ it was only one \"data point\" of the truth.</p><p>That's why I combined his\
    \ test (using a continuous vs. separate allocation) and @James' Answer's advice.</p><p>The\
    \ graphs below shows, that most of the answers and especially the majority of\
    \ comments to the question and answers can be considered completely wrong or true\
    \ depending on the exact scenario and parameters used.</p><p>Note that my initial\
    \ question was at <strong>n = 100.000</strong>. This point (by accident) exhibits\
    \ special behavior: </p><ol><li><p>It possesses the greatest discrepancy between\
    \ the one and two loop'ed version (almost a factor of three)</p></li><li><p>It\
    \ is the only point, where one-loop (namely with continuous allocation) beats\
    \ the two-loop version. (This made Mysticial's answer possible, at all.)</p></li></ol><p>The\
    \ result using initialized data:</p><p><img alt=\"Enter image description here\"\
    \ src=\"https://i.stack.imgur.com/orxF8.png\"/></p><p>The result using uninitialized\
    \ data (this is what Mysticial tested):</p><p><img alt=\"Enter image description\
    \ here\" src=\"https://i.stack.imgur.com/mZPh9.png\"/></p><p>And this is a hard-to-explain\
    \ one: Initialized data, that is allocated once and reused for every following\
    \ test case of different vector size:</p><p><img alt=\"Enter image description\
    \ here\" src=\"https://i.stack.imgur.com/aiDfv.png\"/></p><h2>Proposal</h2><p>Every\
    \ low-level performance related question on Stack Overflow should be required\
    \ to provide MFLOPS information for the whole range of cache relevant data sizes!\
    \ It's a waste of everybody's time to think of answers and especially discuss\
    \ them with others without this information.</p></div>"
- - Why are elementwise additions much faster in separate loops than in a combined
    loop?
  - <div class="post-text" itemprop="text"><p>The second loop involves a lot less
    cache activity, so it's easier for the processor to keep up with the memory demands.</p></div>
- - 'What is the difference between #include <filename> and #include “filename”?'
  - <div class="post-text" itemprop="text"><p>In practice, the difference is in the
    location where the preprocessor searches for the included file. </p><p>For <code>#include
    &lt;filename&gt;</code> the preprocessor searches in an implementation dependent
    manner, normally in search directories pre-designated by the compiler/IDE. This
    method is normally used to include standard library header files.</p><p>For <code>#include
    "filename"</code> the preprocessor searches first in the same directory as the
    file containing the directive, and then follows the search path used for the <code>#include
    &lt;filename&gt;</code> form. This method is normally used to include programmer-defined
    header files.</p><p>A more complete description is available in the GCC <a href="https://gcc.gnu.org/onlinedocs/cpp/Search-Path.html"
    rel="noreferrer">documentation on search paths</a>.</p></div>
- - 'What is the difference between #include <filename> and #include “filename”?'
  - "<div class=\"post-text\" itemprop=\"text\"><p>The only way to know is to read\
    \ your implementation's documentation.</p><p>In <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf#page=182\"\
    \ rel=\"nofollow noreferrer\">the C standard</a>, section 6.10.2, paragraphs 2\
    \ to 4 state:</p><blockquote><ul><li><p>A preprocessing directive of the form</p><pre><code>#include\
    \ &lt;h-char-sequence&gt; new-line</code></pre><p>searches a sequence of implementation-defined\
    \ places for a <strong>header</strong> identified uniquely by the specified sequence\
    \ between the <code>&lt;</code> and <code>&gt;</code> delimiters, and causes the\
    \ replacement of that directive by the entire contents of the <strong>header</strong>.\
    \ How the places are specified or the header identified is implementation-defined.</p></li><li><p>A\
    \ preprocessing directive of the form</p><pre><code>#include \"q-char-sequence\"\
    \ new-line</code></pre><p>causes the replacement of that directive by the entire\
    \ contents of the <strong>source file</strong> identified by the specified sequence\
    \ between the <code>\"</code> delimiters. The named <strong>source file</strong>\
    \ is searched for in an implementation-defined manner. If this search is not supported,\
    \ or if the search fails, the directive is reprocessed as if it read</p><pre><code>#include\
    \ &lt;h-char-sequence&gt; new-line</code></pre><p>with the identical contained\
    \ sequence (including <code>&gt;</code> characters, if any) from the original\
    \  directive.</p></li><li><p>A preprocessing directive of the form</p><pre><code>#include\
    \ pp-tokens new-line</code></pre><p>(that does not match one of the two previous\
    \ forms) is permitted. The preprocessing tokens after <code>include</code> in\
    \ the directive are processed just as in normal text. (Each identifier currently\
    \ defined as a macro name is replaced by its replacement list of preprocessing\
    \ tokens.) The directive resulting after all replacements shall match one of the\
    \ two previous forms. The method by which a sequence of preprocessing tokens between\
    \ a <code>&lt;</code> and a <code>&gt;</code> preprocessing token pair or a pair\
    \ of <code>\"</code> characters is combined into a single header name preprocessing\
    \ token is implementation-defined.</p></li></ul><h3>Definitions:</h3><ul><li><p>h-char:\
    \ any member of the source character set except the new-line character and <code>&gt;</code></p></li><li><p>q-char:\
    \ any member of the source character set except the new-line character and <code>\"\
    </code></p></li></ul></blockquote></div>"
- - 'What is the difference between #include <filename> and #include “filename”?'
  - <div class="post-text" itemprop="text"><p>The sequence of characters between &lt;
    and &gt; uniquely refer to a header, which isn't necessarily a file. Implementations
    are pretty much free to use the character sequence as they wish. (Mostly, however,
    just treat it as a file name and do a search in the <em>include path</em>, as
    the other posts state.)</p><p>If the <code>#include "file"</code> form is used,
    the implementation first looks for a file of the given name, if supported. If
    not (supported), or if the search fails, the implementation behaves as though
    the other (<code>#include &lt;file&gt;</code>) form was used.</p><p>Also, a third
    form exists and is used when the <code>#include</code> directive doesn't match
    either of the forms above. In this form, some basic preprocessing (such as macro
    expansion) is done on the "operands" of the <code>#include</code> directive, and
    the result is expected to match one of the two other forms.</p></div>
- - What are the basic rules and idioms for operator overloading?
  - "<div class=\"post-text\" itemprop=\"text\"><h1>Common operators to overload</h1><p>Most\
    \ of the work in overloading operators is boiler-plate code. That is little wonder,\
    \ since operators are merely syntactic sugar, their actual work could be done\
    \ by (and often is forwarded to) plain functions. But it is important that you\
    \ get this boiler-plate code right. If you fail, either your operator’s code won’t\
    \ compile or your users’ code won’t compile or your users’ code will behave surprisingly.</p><h2>Assignment\
    \ Operator</h2><p>There's a lot to be said about assignment. However, most of\
    \ it has already been said in <a href=\"https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom\"\
    >GMan's famous Copy-And-Swap FAQ</a>, so I'll skip most of it here, only listing\
    \ the perfect assignment operator for reference:</p><pre><code>X&amp; X::operator=(X\
    \ rhs){  swap(rhs);  return *this;}</code></pre><h2>Bitshift Operators (used for\
    \ Stream I/O)</h2><p>The bitshift operators <code>&lt;&lt;</code> and <code>&gt;&gt;</code>,\
    \ although still used in hardware interfacing for the bit-manipulation functions\
    \ they inherit from C, have become more prevalent as overloaded stream input and\
    \ output operators in most applications.  For guidance overloading as bit-manipulation\
    \ operators, see the section below on Binary Arithmetic Operators.  For implementing\
    \ your own custom format and parsing logic when your object is used with iostreams,\
    \ continue.</p><p>The stream operators, among the most commonly overloaded operators,\
    \ are binary infix operators for which the syntax specifies no restriction on\
    \ whether they should be members or non-members.Since they change their left argument\
    \ (they alter the stream’s state), they should, according to the rules of thumb,\
    \ be implemented as members of their left operand’s type. However, their left\
    \ operands are streams from the standard library, and while most of the stream\
    \ output and input operators defined by the standard library are indeed defined\
    \ as members of the stream classes, when you implement output and input operations\
    \ for your own types, you cannot change the standard library’s stream types. That’s\
    \ why you need to implement these operators for your own types as non-member functions.The\
    \ canonical forms of the two are these:</p><pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp;\
    \ os, const T&amp; obj){  // write obj to stream  return os;}std::istream&amp;\
    \ operator&gt;&gt;(std::istream&amp; is, T&amp; obj){  // read obj from stream\
    \  if( /* no valid object of T found in stream */ )    is.setstate(std::ios::failbit);\
    \  return is;}</code></pre><p>When implementing <code>operator&gt;&gt;</code>,\
    \ manually setting the stream’s state is only necessary when the reading itself\
    \ succeeded, but the result is not what would be expected.</p><h2>Function call\
    \ operator</h2><p>The function call operator, used to create function objects,\
    \ also known as functors, must be defined as a <strong><em>member</em></strong>\
    \ function, so it always has the implicit <code>this</code> argument of member\
    \ functions. Other than this it can be overloaded to take any number of additional\
    \ arguments, including zero.</p><p>Here's an example of the syntax:</p><pre><code>class\
    \ foo {public:    // Overloaded call operator    int operator()(const std::string&amp;\
    \ y) {        // ...    }};</code></pre><p>Usage:</p><pre><code>foo f;int a =\
    \ f(\"hello\");</code></pre><p>Throughout the C++ standard library, function objects\
    \ are always copied. Your own function objects should therefore be cheap to copy.\
    \ If a function object absolutely needs to use data which is expensive to copy,\
    \ it is better to store that data elsewhere and have the function object refer\
    \ to it.</p><h2>Comparison operators</h2><p>The binary infix comparison operators\
    \ should, according to the rules of thumb, be implemented as non-member functions<sup>1</sup>.\
    \ The unary prefix negation <code>!</code> should (according to the same rules)\
    \ be implemented as a member function. (but it is usually not a good idea to overload\
    \ it.)</p><p>The standard library’s algorithms (e.g. <code>std::sort()</code>)\
    \ and types (e.g. <code>std::map</code>) will always only expect <code>operator&lt;</code>\
    \ to be present. However, the <em>users of your type will expect all the other\
    \ operators to be present</em>, too, so if you define <code>operator&lt;</code>,\
    \ be sure to follow the third fundamental rule of operator overloading and also\
    \ define all the other boolean comparison operators. The canonical way to implement\
    \ them is this:</p><pre><code>inline bool operator==(const X&amp; lhs, const X&amp;\
    \ rhs){ /* do actual comparison */ }inline bool operator!=(const X&amp; lhs, const\
    \ X&amp; rhs){return !operator==(lhs,rhs);}inline bool operator&lt; (const X&amp;\
    \ lhs, const X&amp; rhs){ /* do actual comparison */ }inline bool operator&gt;\
    \ (const X&amp; lhs, const X&amp; rhs){return  operator&lt; (rhs,lhs);}inline\
    \ bool operator&lt;=(const X&amp; lhs, const X&amp; rhs){return !operator&gt;\
    \ (lhs,rhs);}inline bool operator&gt;=(const X&amp; lhs, const X&amp; rhs){return\
    \ !operator&lt; (lhs,rhs);}</code></pre><p>The important thing to note here is\
    \ that only two of these operators actually do anything, the others are just forwarding\
    \ their arguments to either of these two to do the actual work.</p><p>The syntax\
    \ for overloading the remaining binary boolean operators (<code>||</code>, <code>&amp;&amp;</code>)\
    \ follows the rules of the comparison operators. However, it is <em>very</em>\
    \ unlikely that you would find a reasonable use case for these<sup>2</sup>.</p><p><sup>1</sup>\
    \ <sub>As with all rules of thumb, sometimes there might be reasons to break this\
    \ one, too. If so, do not forget that the left-hand operand of the binary comparison\
    \ operators, which for member functions will be <code>*this</code>, needs to be\
    \ <code>const</code>, too. So a comparison operator implemented as a member function\
    \ would have to have this signature:</sub></p><pre><code>bool operator&lt;(const\
    \ X&amp; rhs) const { /* do actual comparison with *this */ }</code></pre><p><sub>(Note\
    \ the <code>const</code> at the end.)</sub></p><p><sup>2</sup> <sub>It should\
    \ be noted that the built-in version of <code>||</code> and <code>&amp;&amp;</code>\
    \ use shortcut semantics. While the user defined ones (because they are syntactic\
    \ sugar for method calls) do not use shortcut semantics. User will expect these\
    \ operators to have shortcut semantics, and their code may depend on it, Therefore\
    \ it is highly advised NEVER to define them.</sub></p><h2>Arithmetic Operators</h2><h3>Unary\
    \ arithmetic operators</h3><p>The unary increment and decrement operators come\
    \ in both prefix and postfix flavor. To tell one from the other, the postfix variants\
    \ take an additional dummy int argument. If you overload increment or decrement,\
    \ be sure to always implement both prefix and postfix versions.Here is the canonical\
    \ implementation of increment, decrement follows the same rules:</p><pre><code>class\
    \ X {  X&amp; operator++()  {    // do actual increment    return *this;  }  X\
    \ operator++(int)  {    X tmp(*this);    operator++();    return tmp;  }};</code></pre><p>Note\
    \ that the postfix variant is implemented in terms of prefix. Also note that postfix\
    \ does an extra copy.<sup>2</sup></p><p>Overloading unary minus and plus is not\
    \ very common and probably best avoided. If needed, they should probably be overloaded\
    \ as member functions. </p><p><sup>2</sup> <sub>Also note that the postfix variant\
    \ does more work and is therefore less efficient to use than the prefix variant.\
    \ This is a good reason to generally prefer prefix increment over postfix increment.\
    \ While compilers can usually optimize away the additional work of postfix increment\
    \ for built-in types, they might not be able to do the same for user-defined types\
    \ (which could be something as innocently looking as a list iterator). Once you\
    \ got used to do <code>i++</code>, it becomes very hard to remember to do <code>++i</code>\
    \ instead when <code>i</code> is not of a built-in type (plus you'd have to change\
    \ code when changing a type), so it is better to make a habit of always using\
    \ prefix increment, unless postfix is explicitly needed.</sub></p><h3>Binary arithmetic\
    \ operators</h3><p>For the binary arithmetic operators, do not forget to obey\
    \ the third basic rule operator overloading: If you provide <code>+</code>, also\
    \ provide <code>+=</code>, if you provide <code>-</code>, do not omit <code>-=</code>,\
    \ etc. Andrew Koenig is said to have been the first to observe that the compound\
    \ assignment operators can be used as a base for their non-compound counterparts.\
    \ That is, operator <code>+</code> is implemented in terms of <code>+=</code>,\
    \ <code>-</code> is implemented in terms of <code>-=</code> etc.</p><p>According\
    \ to our rules of thumb, <code>+</code> and its companions should be non-members,\
    \ while their compound assignment counterparts (<code>+=</code> etc.), changing\
    \ their left argument, should be a member. Here is the exemplary code for <code>+=</code>\
    \ and <code>+</code>, the other binary arithmetic operators should be implemented\
    \ in the same way:</p><pre><code>class X {  X&amp; operator+=(const X&amp; rhs)\
    \  {    // actual addition of rhs to *this    return *this;  }};inline X operator+(X\
    \ lhs, const X&amp; rhs){  lhs += rhs;  return lhs;}</code></pre><p><code>operator+=</code>\
    \ returns its result per reference, while <code>operator+</code> returns a copy\
    \ of its result. Of course, returning a reference is usually more efficient than\
    \ returning a copy, but in the case of <code>operator+</code>, there is no way\
    \ around the copying. When you write <code>a + b</code>, you expect the result\
    \ to be a new value, which is why <code>operator+</code> has to return a new value.<sup>3</sup>Also\
    \ note that <code>operator+</code> takes its left operand <strong><em>by copy</em></strong>\
    \ rather than by const reference. The reason for this is the same as the reason\
    \ giving for <code>operator=</code> taking its argument per copy.</p><p>The bit\
    \ manipulation operators <code>~</code> <code>&amp;</code> <code>|</code> <code>^</code>\
    \ <code>&lt;&lt;</code> <code>&gt;&gt;</code> should be implemented in the same\
    \ way as the arithmetic operators. However, (except for overloading <code>&lt;&lt;</code>\
    \ and <code>&gt;&gt;</code> for output and input) there are very few reasonable\
    \ use cases for overloading these.</p><p><sup>3</sup> <sub>Again, the lesson to\
    \ be taken from this is that <code>a += b</code> is, in general, more efficient\
    \ than <code>a + b</code> and should be preferred if possible.</sub></p><h2>Array\
    \ Subscripting</h2><p>The array subscript operator is a binary operator which\
    \ must be implemented as a class member. It is used for container-like types that\
    \ allow access to their data elements by a key.The canonical form of providing\
    \ these is this:</p><pre><code>class X {        value_type&amp; operator[](index_type\
    \ idx);  const value_type&amp; operator[](index_type idx) const;  // ...};</code></pre><p>Unless\
    \ you do not want users of your class to be able to change data elements returned\
    \ by <code>operator[]</code> (in which case you can omit the non-const variant),\
    \ you should always provide both variants of the operator.</p><p>If value_type\
    \ is known to refer to a built-in type, the const variant of the operator should\
    \ return a copy instead of a const reference.</p><h2>Operators for Pointer-like\
    \ Types</h2><p>For defining your own iterators or smart pointers, you have to\
    \ overload the unary prefix dereference operator <code>*</code> and the binary\
    \ infix pointer member access operator <code>-&gt;</code>:</p><pre><code>class\
    \ my_ptr {        value_type&amp; operator*();  const value_type&amp; operator*()\
    \ const;        value_type* operator-&gt;();  const value_type* operator-&gt;()\
    \ const;};</code></pre><p>Note that these, too, will almost always need both a\
    \ const and a non-const version.For the <code>-&gt;</code> operator, if <code>value_type</code>\
    \ is of <code>class</code> (or <code>struct</code> or <code>union</code>) type,\
    \ another <code>operator-&gt;()</code> is called recursively, until an <code>operator-&gt;()</code>\
    \ returns a value of non-class type.</p><p>The unary address-of operator should\
    \ never be overloaded.</p><p>For <code>operator-&gt;*()</code> see <a href=\"\
    https://stackoverflow.com/q/8777845/140719\">this question</a>. It's rarely used\
    \ and thus rarely ever overloaded. In fact, even iterators do not overload it.</p><hr/><p>Continue\
    \ to <a href=\"https://stackoverflow.com/questions/4421706/operator-overloading/16615725#16615725\"\
    >Conversion Operators</a></p></div>"
- - What are the basic rules and idioms for operator overloading?
  - '<div class="post-text" itemprop="text"><h1>The Three Basic Rules of Operator
    Overloading in C++</h1><p>When it comes to operator overloading in C++, there
    are <strong><em>three basic rules you should follow</em></strong>. As with all
    such rules, there are indeed exceptions. Sometimes people have deviated from them
    and the outcome was not bad code, but such positive deviations are few and far
    between. At the very least, 99 out of 100 such deviations I have seen were unjustified.
    However, it might just as well have been 999 out of 1000. So you’d better stick
    to the following rules. </p><ol><li><p><strong><em>Whenever the meaning of an
    operator is not obviously clear and undisputed, it should not be overloaded.</em></strong>
    <em>Instead, provide a function with a well-chosen name.</em><br/>Basically, the
    first and foremost rule for overloading operators, at its very heart, says: <em>Don’t
    do it</em>. That might seem strange, because there is a lot to be known about
    operator overloading and so a lot of articles, book chapters, and other texts
    deal with all this. But despite this seemingly obvious evidence, <em>there are
    only a surprisingly few cases where operator overloading is appropriate</em>.
    The reason is that actually it is hard to understand the semantics behind the
    application of an operator unless the use of the operator in the application domain
    is well known and undisputed. Contrary to popular belief, this is hardly ever
    the case.  </p></li><li><p><strong><em>Always stick to the operator’s well-known
    semantics.</em></strong><br/>C++ poses no limitations on the semantics of overloaded
    operators. Your compiler will happily accept code that implements the binary <code>+</code>
    operator to subtract from its right operand. However, the users of such an operator
    would never suspect the expression <code>a + b</code> to subtract <code>a</code>
    from <code>b</code>. Of course, this supposes that the semantics of the operator
    in the application domain is undisputed. </p></li><li><p><strong><em>Always provide
    all out of a set of related operations.</em></strong><br/><em>Operators are related
    to each other</em> and to other operations. If your type supports <code>a + b</code>,
    users will expect to be able to call <code>a += b</code>, too. If it supports
    prefix increment <code>++a</code>, they will expect <code>a++</code> to work as
    well. If they can check whether <code>a &lt; b</code>, they will most certainly
    expect to also to be able to check whether <code>a &gt; b</code>. If they can
    copy-construct your type, they expect assignment to work as well. </p></li></ol><hr/><p>Continue
    to <a href="https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729#4421729">The
    Decision between Member and Non-member</a>.</p></div>'
- - What are the basic rules and idioms for operator overloading?
  - "<div class=\"post-text\" itemprop=\"text\"><h1>The General Syntax of operator\
    \ overloading in C++</h1><p>You cannot change the meaning of operators for built-in\
    \ types in C++, operators can only be overloaded for user-defined types<sup>1</sup>.\
    \ That is, at least one of the operands has to be of a user-defined type. As with\
    \ other overloaded functions, operators can be overloaded for a certain set of\
    \ parameters only once. </p><p>Not all operators can be overloaded in C++. Among\
    \ the operators that cannot be overloaded are: <code>.</code> <code>::</code>\
    \ <code>sizeof</code> <code>typeid</code> <code>.*</code> and the only ternary\
    \ operator in C++, <code>?:</code> </p><p>Among the operators that can be overloaded\
    \ in C++ are these: </p><ul><li>arithmetic operators: <code>+</code> <code>-</code>\
    \ <code>*</code> <code>/</code> <code>%</code> and <code>+=</code> <code>-=</code>\
    \ <code>*=</code> <code>/=</code> <code>%=</code> (all binary infix); <code>+</code>\
    \ <code>-</code> (unary prefix); <code>++</code> <code>--</code> (unary prefix\
    \ and postfix) </li><li>bit manipulation: <code>&amp;</code> <code>|</code> <code>^</code>\
    \ <code>&lt;&lt;</code> <code>&gt;&gt;</code> and <code>&amp;=</code> <code>|=</code>\
    \ <code>^=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> (all binary infix);\
    \ <code>~</code> (unary prefix) </li><li>boolean algebra: <code>==</code> <code>!=</code>\
    \ <code>&lt;</code> <code>&gt;</code> <code>&lt;=</code> <code>&gt;=</code> <code>||</code>\
    \ <code>&amp;&amp;</code> (all binary infix); <code>!</code> (unary prefix)</li><li>memory\
    \ management: <code>new</code> <code>new[]</code> <code>delete</code> <code>delete[]</code></li><li>implicit\
    \ conversion operators</li><li>miscellany: <code>=</code> <code>[]</code> <code>-&gt;</code>\
    \ <code>-&gt;*</code> <code>,</code>  (all binary infix); <code>*</code> <code>&amp;</code>\
    \ (all unary prefix) <code>()</code> (function call, n-ary infix) </li></ul><p>However,\
    \ the fact that you <em>can</em> overload all of these does not mean you <em>should</em>\
    \ do so. See the basic rules of operator overloading.</p><p>In C++, operators\
    \ are overloaded in the form of <strong><em>functions with special names</em></strong>.\
    \ As with other functions, overloaded operators can generally be implemented either\
    \ as a <strong><em>member function of their left operand's type</em></strong>\
    \ or as <strong><em>non-member functions</em></strong>. Whether you are free to\
    \ choose or bound to use either one depends on several criteria.<sup>2</sup> A\
    \ unary operator <code>@</code><sup>3</sup>, applied to an object x, is invoked\
    \ either as <code>operator@(x)</code> or as <code>x.operator@()</code>. A binary\
    \ infix operator <code>@</code>, applied to the objects <code>x</code> and <code>y</code>,\
    \ is called either as <code>operator@(x,y)</code> or as <code>x.operator@(y)</code>.<sup>4</sup>\
    \ </p><p>Operators that are implemented as non-member functions are sometimes\
    \ friend of their operand’s type. </p><p><sup>1</sup> <sub>The term “user-defined”\
    \ might be slightly misleading. C++ makes the distinction between built-in types\
    \ and user-defined types. To the former belong for example int, char, and double;\
    \ to the latter belong all struct, class, union, and enum types, including those\
    \ from the standard library, even though they are not, as such, defined by users.</sub></p><p><sup>2</sup>\
    \ <sub>This is covered in <a href=\"https://stackoverflow.com/questions/4421706/operator-overloading/4421729#4421729\"\
    >a later part</a> of this FAQ.</sub></p><p><sup>3</sup> <sub>The <code>@</code>\
    \ is not a valid operator in C++ which is why I use it as a placeholder.</sub></p><p><sup>4</sup>\
    \ <sub>The only ternary operator in C++ cannot be overloaded and the only n-ary\
    \ operator must always be implemented as a member function.</sub></p><hr/><p>Continue\
    \ to <a href=\"https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421708#4421708\"\
    >The Three Basic Rules of Operator Overloading in C++</a>. </p></div>"
- - What is The Rule of Three?
  - "<div class=\"post-text\" itemprop=\"text\"><h1>Introduction</h1><p>C++ treats\
    \ variables of user-defined types with <em>value semantics</em>.This means that\
    \ objects are implicitly copied in various contexts,and we should understand what\
    \ \"copying an object\" actually means.</p><p>Let us consider a simple example:</p><pre><code>class\
    \ person{    std::string name;    int age;public:    person(const std::string&amp;\
    \ name, int age) : name(name), age(age)    {    }};int main(){    person a(\"\
    Bjarne Stroustrup\", 60);    person b(a);   // What happens here?    b = a;  \
    \       // And here?}</code></pre><p>(If you are puzzled by the <code>name(name),\
    \ age(age)</code> part,this is called a <a href=\"https://stackoverflow.com/questions/1272680/\"\
    >member initializer list</a>.)</p><h1>Special member functions</h1><p>What does\
    \ it mean to copy a <code>person</code> object?The <code>main</code> function\
    \ shows two distinct copying scenarios.The initialization <code>person b(a);</code>\
    \ is performed by the <em>copy constructor</em>.Its job is to construct a fresh\
    \ object based on the state of an existing object.The assignment <code>b = a</code>\
    \ is performed by the <em>copy assignment operator</em>.Its job is generally a\
    \ little more complicated,because the target object is already in some valid state\
    \ that needs to be dealt with.</p><p>Since we declared neither the copy constructor\
    \ nor the assignment operator (nor the destructor) ourselves,these are implicitly\
    \ defined for us. Quote from the standard:</p><blockquote><p>The [...] copy constructor\
    \ and copy assignment operator, [...] and destructor are special member functions.\
    \  [ <em>Note</em>: <strong>The implementation will implicitly declare these member\
    \ functions  for some class types when the program does not explicitly declare\
    \ them.</strong>  The implementation will implicitly define them if they are used.\
    \ [...] <em>end note</em> ]  [n3126.pdf section 12 §1]</p></blockquote><p>By default,\
    \ copying an object means copying its members:</p><blockquote><p>The implicitly-defined\
    \ copy constructor for a non-union class X performs a memberwise copy of its subobjects.\
    \  [n3126.pdf section 12.8 §16]</p><p>The implicitly-defined copy assignment operator\
    \ for a non-union class X performs memberwise copy assignment  of its subobjects.\
    \  [n3126.pdf section 12.8 §30]</p></blockquote><h2>Implicit definitions</h2><p>The\
    \ implicitly-defined special member functions for <code>person</code> look like\
    \ this:</p><pre><code>// 1. copy constructorperson(const person&amp; that) : name(that.name),\
    \ age(that.age){}// 2. copy assignment operatorperson&amp; operator=(const person&amp;\
    \ that){    name = that.name;    age = that.age;    return *this;}// 3. destructor~person(){}</code></pre><p>Memberwise\
    \ copying is exactly what we want in this case:<code>name</code> and <code>age</code>\
    \ are copied, so we get a self-contained, independent <code>person</code> object.The\
    \ implicitly-defined destructor is always empty.This is also fine in this case\
    \ since we did not acquire any resources in the constructor.The members' destructors\
    \ are implicitly called after the <code>person</code> destructor is finished:</p><blockquote><p>After\
    \ executing the body of the destructor and destroying any automatic objects allocated\
    \ within the body,  a destructor for class X calls the destructors for X's direct\
    \ [...] members  [n3126.pdf 12.4 §6]</p></blockquote><h1>Managing resources</h1><p>So\
    \ when should we declare those special member functions explicitly?When our class\
    \ <em>manages a resource</em>, that is,when an object of the class is <em>responsible</em>\
    \ for that resource.That usually means the resource is <em>acquired</em> in the\
    \ constructor(or passed into the constructor) and <em>released</em> in the destructor.</p><p>Let\
    \ us go back in time to pre-standard C++.There was no such thing as <code>std::string</code>,\
    \ and programmers were in love with pointers.The <code>person</code> class might\
    \ have looked like this:</p><pre><code>class person{    char* name;    int age;public:\
    \    // the constructor acquires a resource:    // in this case, dynamic memory\
    \ obtained via new[]    person(const char* the_name, int the_age)    {       \
    \ name = new char[strlen(the_name) + 1];        strcpy(name, the_name);      \
    \  age = the_age;    }    // the destructor must release this resource via delete[]\
    \    ~person()    {        delete[] name;    }};</code></pre><p>Even today, people\
    \ still write classes in this style and get into trouble:\"<em>I pushed a person\
    \ into a vector and now I get crazy memory errors!</em>\"Remember that by default,\
    \ copying an object means copying its members,but copying the <code>name</code>\
    \ member merely copies a pointer, <em>not</em> the character array it points to!This\
    \ has several unpleasant effects:</p><ol><li>Changes via <code>a</code> can be\
    \ observed via <code>b</code>.</li><li>Once <code>b</code> is destroyed, <code>a.name</code>\
    \ is a dangling pointer.</li><li>If <code>a</code> is destroyed, deleting the\
    \ dangling pointer yields <a href=\"https://stackoverflow.com/questions/2397984/\"\
    >undefined behavior</a>.</li><li>Since the assignment does not take into account\
    \ what <code>name</code> pointed to before the assignment,sooner or later you\
    \ will get memory leaks all over the place.</li></ol><h2>Explicit definitions</h2><p>Since\
    \ memberwise copying does not have the desired effect, we must define the copy\
    \ constructor and the copy assignment operator explicitly to make deep copies\
    \ of the character array:</p><pre><code>// 1. copy constructorperson(const person&amp;\
    \ that){    name = new char[strlen(that.name) + 1];    strcpy(name, that.name);\
    \    age = that.age;}// 2. copy assignment operatorperson&amp; operator=(const\
    \ person&amp; that){    if (this != &amp;that)    {        delete[] name;    \
    \    // This is a dangerous point in the flow of execution!        // We have\
    \ temporarily invalidated the class invariants,        // and the next statement\
    \ might throw an exception,        // leaving the object in an invalid state :(\
    \        name = new char[strlen(that.name) + 1];        strcpy(name, that.name);\
    \        age = that.age;    }    return *this;}</code></pre><p>Note the difference\
    \ between initialization and assignment:we must tear down the old state before\
    \ assigning to <code>name</code> to prevent memory leaks.Also, we have to protect\
    \ against self-assignment of the form <code>x = x</code>.Without that check, <code>delete[]\
    \ name</code> would delete the array containing the <em>source</em> string,because\
    \ when you write <code>x = x</code>, both <code>this-&gt;name</code> and <code>that.name</code>\
    \ contain the same pointer.</p><h2>Exception safety</h2><p>Unfortunately, this\
    \ solution will fail if <code>new char[...]</code> throws an exception due to\
    \ memory exhaustion.One possible solution is to introduce a local variable and\
    \ reorder the statements:</p><pre><code>// 2. copy assignment operatorperson&amp;\
    \ operator=(const person&amp; that){    char* local_name = new char[strlen(that.name)\
    \ + 1];    // If the above statement throws,    // the object is still in the\
    \ same state as before.    // None of the following statements will throw an exception\
    \ :)    strcpy(local_name, that.name);    delete[] name;    name = local_name;\
    \    age = that.age;    return *this;}</code></pre><p>This also takes care of\
    \ self-assignment without an explicit check.An even more robust solution to this\
    \ problem is the <a href=\"https://stackoverflow.com/questions/3279543/\">copy-and-swap\
    \ idiom</a>,but I will not go into the details of exception safety here.I only\
    \ mentioned exceptions to make the following point: <strong>Writing classes that\
    \ manage resources is hard.</strong></p><h2>Noncopyable resources</h2><p>Some\
    \ resources cannot or should not be copied, such as file handles or mutexes.In\
    \ that case, simply declare the copy constructor and copy assignment operator\
    \ as <code>private</code> without giving a definition:</p><pre><code>private:\
    \    person(const person&amp; that);    person&amp; operator=(const person&amp;\
    \ that);</code></pre><p>Alternatively, you can inherit from <code>boost::noncopyable</code>\
    \ or declare them as deleted (in C++11 and above):</p><pre><code>person(const\
    \ person&amp; that) = delete;person&amp; operator=(const person&amp; that) = delete;</code></pre><h2>The\
    \ rule of three</h2><p>Sometimes you need to implement a class that manages a\
    \ resource.(Never manage multiple resources in a single class,this will only lead\
    \ to pain.)In that case, remember the <strong>rule of three</strong>:</p><blockquote><p>If\
    \ you need to explicitly declare either the destructor,  copy constructor or copy\
    \ assignment operator yourself,  you probably need to explicitly declare all three\
    \ of them.</p></blockquote><p>(Unfortunately, this \"rule\" is not enforced by\
    \ the C++ standard or any compiler I am aware of.)</p><h2>The rule of five</h2><p>From\
    \ C++11 on, an object has 2 extra special member functions: the move constructor\
    \ and move assignment. The rule of five states to implement these functions as\
    \ well.</p><p>An example with the signatures:</p><pre><code>class person{    std::string\
    \ name;    int age;public:    person(const std::string&amp; name, int age);  \
    \      // Ctor    person(const person &amp;) = default;                // Copy\
    \ Ctor    person(person &amp;&amp;) noexcept = default;            // Move Ctor\
    \    person&amp; operator=(const person &amp;) = default;     // Copy Assignment\
    \    person&amp; operator=(person &amp;&amp;) noexcept = default; // Move Assignment\
    \    ~person() noexcept = default;                    // Dtor};</code></pre><h2>The\
    \ rule of zero</h2><p>The rule of 3/5 is also referred to as the rule of 0/3/5.\
    \ The zero part of the rule states that you are allowed to not write any of the\
    \ special member functions when creating your class.</p><h1>Advice</h1><p>Most\
    \ of the time, you do not need to manage a resource yourself,because an existing\
    \ class such as <code>std::string</code> already does it for you.Just compare\
    \ the simple code using a <code>std::string</code> memberto the convoluted and\
    \ error-prone alternative using a <code>char*</code> and you should be convinced.As\
    \ long as you stay away from raw pointer members, the rule of three is unlikely\
    \ to concern your own code.</p></div>"
- - What is The Rule of Three?
  - <div class="post-text" itemprop="text"><p>The <a href="http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29"
    rel="noreferrer">Rule of Three</a> is a rule of thumb for C++, basically saying
    </p><blockquote><p>If your class needs any of</p><ul><li>a <strong>copy constructor</strong>,</li><li>an
    <strong>assignment operator</strong>, </li><li>or a <strong>destructor</strong>,
    </li></ul><p>defined explictly, then it is likely to need <strong>all three of
    them</strong>.</p></blockquote><p>The reasons for this is that all three of them
    are usually used to manage a resource, and if your class manages a resource, it
    usually needs to manage copying as well as freeing. </p><p>If there is no good
    semantic for copying the resource your class manages, then consider to forbid
    copying by declaring (not <em><a href="https://stackoverflow.com/questions/1410563/what-is-the-difference-between-a-definition-and-a-declaration/1410632#1410632">defining</a></em>)
    the copy constructor and assignment operator as <code>private</code>. </p><p>(Note
    that the forthcoming new version of the C++ standard (which is C++11) adds move
    semantics to C++, which will likely change the Rule of Three. However, I know
    too little about this to write a C++11 section about the Rule of Three.)</p></div>
- - What is The Rule of Three?
  - <div class="post-text" itemprop="text"><p>The law of the big three is as specified
    above.</p><p>An easy example, in plain English, of the kind of problem it solves:</p><p><strong>Non
    default destructor</strong></p><p>You allocated memory in your constructor and
    so you need to write a destructor to delete it.  Otherwise you will cause a memory
    leak.</p><p>You might think that this is job done. </p><p>The problem will be,
    if a copy is made of your object, then the copy will point to the same memory
    as the original object.</p><p>Once, one of these deletes the memory in its destructor,
    the other will have a pointer to invalid memory (this is called a dangling pointer)
    when it tries to use it things are going to get hairy.</p><p>Therefore, you write
    a copy constructor so that it allocates new objects their own pieces of memory
    to destroy.</p><p><strong>Assignment operator and copy constructor</strong></p><p>You
    allocated memory in your constructor to a member pointer of your class.  When
    you copy an object of this class the default assignment operator and copy constructor
    will copy the value of this member pointer to the new object.</p><p>This means
    that the new object and the old object will be pointing at the same piece of memory
    so when you change it in one object it will be changed for the other objerct too.  If
    one object deletes this memory the other will carry on trying to use it - eek.</p><p>To
    resolve this you write your own version of the copy constructor and assignment
    operator.  Your versions allocate separate memory to the new objects and copy
    across the values that the first pointer is pointing to rather than its address.</p></div>
- - What is the copy-and-swap idiom?
  - "<div class=\"post-text\" itemprop=\"text\"><h2>Overview</h2><h3>Why do we need\
    \ the copy-and-swap idiom?</h3><p>Any class that manages a resource (a <em>wrapper</em>,\
    \ like a smart pointer) needs to implement <a href=\"https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three\"\
    >The Big Three</a>. While the goals and implementation of the copy-constructor\
    \ and destructor are straightforward, the copy-assignment operator is arguably\
    \ the most nuanced and difficult. How should it be done? What pitfalls need to\
    \ be avoided?</p><p>The <em>copy-and-swap idiom</em> is the solution, and elegantly\
    \ assists the assignment operator in achieving two things: avoiding <a href=\"\
    http://en.wikipedia.org/wiki/Don%27t_repeat_yourself\" rel=\"noreferrer\">code\
    \ duplication</a>, and providing a <a href=\"http://en.wikipedia.org/wiki/Exception_guarantees\"\
    \ rel=\"noreferrer\">strong exception guarantee</a>.</p><h3>How does it work?</h3><p><a\
    \ href=\"https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom/3279616#3279616\"\
    >Conceptually</a>, it works by using the copy-constructor's functionality to create\
    \ a local copy of the data, then takes the copied data with a <code>swap</code>\
    \ function, swapping the old data with the new data. The temporary copy then destructs,\
    \ taking the old data with it. We are left with a copy of the new data.</p><p>In\
    \ order to use the copy-and-swap idiom, we need three things: a working copy-constructor,\
    \ a working destructor (both are the basis of any wrapper, so should be complete\
    \ anyway), and a <code>swap</code> function.</p><p>A swap function is a <em>non-throwing</em>\
    \ function that swaps two objects of a class, member for member. We might be tempted\
    \ to use <code>std::swap</code> instead of providing our own, but this would be\
    \ impossible; <code>std::swap</code> uses the copy-constructor and copy-assignment\
    \ operator within its implementation, and we'd ultimately be trying to define\
    \ the assignment operator in terms of itself!</p><p>(Not only that, but unqualified\
    \ calls to <code>swap</code> will use our custom swap operator, skipping over\
    \ the unnecessary construction and destruction of our class that <code>std::swap</code>\
    \ would entail.)</p><hr/><h2>An in-depth explanation</h2><h3>The goal</h3><p>Let's\
    \ consider a concrete case. We want to manage, in an otherwise useless class,\
    \ a dynamic array. We start with a working constructor, copy-constructor, and\
    \ destructor:</p><pre><code>#include &lt;algorithm&gt; // std::copy#include &lt;cstddef&gt;\
    \ // std::size_tclass dumb_array{public:    // (default) constructor    dumb_array(std::size_t\
    \ size = 0)        : mSize(size),          mArray(mSize ? new int[mSize]() : nullptr)\
    \    {    }    // copy-constructor    dumb_array(const dumb_array&amp; other)\
    \        : mSize(other.mSize),          mArray(mSize ? new int[mSize] : nullptr),\
    \    {        // note that this is non-throwing, because of the data        //\
    \ types being used; more attention to detail with regards        // to exceptions\
    \ must be given in a more general case, however        std::copy(other.mArray,\
    \ other.mArray + mSize, mArray);    }    // destructor    ~dumb_array()    { \
    \       delete [] mArray;    }private:    std::size_t mSize;    int* mArray;};</code></pre><p>This\
    \ class almost manages the array successfully, but it needs <code>operator=</code>\
    \ to work correctly.</p><h3>A failed solution</h3><p>Here's how a naive implementation\
    \ might look:</p><pre><code>// the hard partdumb_array&amp; operator=(const dumb_array&amp;\
    \ other){    if (this != &amp;other) // (1)    {        // get rid of the old\
    \ data...        delete [] mArray; // (2)        mArray = nullptr; // (2) *(see\
    \ footnote for rationale)        // ...and put in the new        mSize = other.mSize;\
    \ // (3)        mArray = mSize ? new int[mSize] : nullptr; // (3)        std::copy(other.mArray,\
    \ other.mArray + mSize, mArray); // (3)    }    return *this;}</code></pre><p>And\
    \ we say we're finished; this now manages an array, without leaks. However, it\
    \ suffers from three problems, marked sequentially in the code as <code>(n)</code>.</p><ol><li><p>The\
    \ first  is the self-assignment test. This check serves two purposes: it's an\
    \ easy way to prevent us from running needless code on self-assignment, and it\
    \ protects us from subtle bugs (such as deleting the array only to try and copy\
    \ it). But in all other cases it merely serves to slow the program down, and act\
    \ as noise in the code; self-assignment rarely occurs, so most of the time this\
    \ check is a waste. It would be better if the operator could work properly without\
    \ it.</p></li><li><p>The second is that it only provides a basic exception guarantee.\
    \ If <code>new int[mSize]</code> fails, <code>*this</code> will have been modified.\
    \ (Namely, the size is wrong and the data is gone!) For a strong exception guarantee,\
    \ it would need to be something akin to:</p><pre><code>dumb_array&amp; operator=(const\
    \ dumb_array&amp; other){    if (this != &amp;other) // (1)    {        // get\
    \ the new data ready before we replace the old        std::size_t newSize = other.mSize;\
    \        int* newArray = newSize ? new int[newSize]() : nullptr; // (3)      \
    \  std::copy(other.mArray, other.mArray + newSize, newArray); // (3)        //\
    \ replace the old data (all are non-throwing)        delete [] mArray;       \
    \ mSize = newSize;        mArray = newArray;    }    return *this;}</code></pre></li><li><p>The\
    \ code has expanded! Which leads us to the third problem: code duplication. Our\
    \ assignment operator effectively duplicates all the code we've already written\
    \ elsewhere, and that's a terrible thing.</p></li></ol><p>In our case, the core\
    \ of it is only two lines (the allocation and the copy), but with more complex\
    \ resources this code bloat can be quite a hassle. We should strive to never repeat\
    \ ourselves.</p><p>(One might wonder: if this much code is needed to manage one\
    \ resource correctly, what if my class manages more than one? While this may seem\
    \ to be a valid concern, and indeed it requires non-trivial <code>try</code>/<code>catch</code>\
    \ clauses, this is a non-issue. That's because a class should manage <a href=\"\
    http://en.wikipedia.org/wiki/Single_responsibility_principle\" rel=\"noreferrer\"\
    ><em>one resource only</em></a>!)</p><h3>A successful solution</h3><p>As mentioned,\
    \ the copy-and-swap idiom will fix all these issues. But right now, we have all\
    \ the requirements except one: a <code>swap</code> function. While The Rule of\
    \ Three successfully entails the existence of our copy-constructor, assignment\
    \ operator, and destructor, it should really be called \"The Big Three and A Half\"\
    : any time your class manages a resource it also makes sense to provide a <code>swap</code>\
    \ function.</p><p>We need to add swap functionality to our class, and we do that\
    \ as follows†:</p><pre><code>class dumb_array{public:    // ...    friend void\
    \ swap(dumb_array&amp; first, dumb_array&amp; second) // nothrow    {        //\
    \ enable ADL (not necessary in our case, but good practice)        using std::swap;\
    \        // by swapping the members of two objects,        // the two objects\
    \ are effectively swapped        swap(first.mSize, second.mSize);        swap(first.mArray,\
    \ second.mArray);    }    // ...};</code></pre><p>(<a href=\"https://stackoverflow.com/questions/5695548/public-friend-swap-member-function\"\
    >Here</a> is the explanation why <code>public friend swap</code>.) Now not only\
    \ can we swap our <code>dumb_array</code>'s, but swaps in general can be more\
    \ efficient; it merely swaps pointers and sizes, rather than allocating and copying\
    \ entire arrays. Aside from this bonus in functionality and efficiency, we are\
    \ now ready to implement the copy-and-swap idiom.</p><p>Without further ado, our\
    \ assignment operator is:</p><pre><code>dumb_array&amp; operator=(dumb_array other)\
    \ // (1){    swap(*this, other); // (2)    return *this;}</code></pre><p>And that's\
    \ it! With one fell swoop, all three problems are elegantly tackled at once.</p><h3>Why\
    \ does it work?</h3><p>We first notice an important choice: the parameter argument\
    \ is taken <em>by-value</em>. While one could just as easily do the following\
    \ (and indeed, many naive implementations of the idiom do):</p><pre><code>dumb_array&amp;\
    \ operator=(const dumb_array&amp; other){    dumb_array temp(other);    swap(*this,\
    \ temp);    return *this;}</code></pre><p>We lose an <a href=\"https://web.archive.org/web/20140113221447/http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/\"\
    \ rel=\"noreferrer\">important optimization opportunity</a>. Not only that, but\
    \ this choice is critical in C++11, which is discussed later. (On a general note,\
    \ a remarkably useful guideline is as follows: if you're going to make a copy\
    \ of something in a function, let the compiler do it in the parameter list.‡)</p><p>Either\
    \ way, this method of obtaining our resource is the key to eliminating code duplication:\
    \ we get to use the code from the copy-constructor to make the copy, and never\
    \ need to repeat any bit of it. Now that the copy is made, we are ready to swap.</p><p>Observe\
    \ that upon entering the function that all the new data is already allocated,\
    \ copied, and ready to be used. This is what gives us a strong exception guarantee\
    \ for free: we won't even enter the function if construction of the copy fails,\
    \ and it's therefore not possible to alter the state of <code>*this</code>. (What\
    \ we did manually before for a strong exception guarantee, the compiler is doing\
    \ for us now; how kind.)</p><p>At this point we are home-free, because <code>swap</code>\
    \ is non-throwing. We swap our current data with the copied data, safely altering\
    \ our state, and the old data gets put into the temporary. The old data is then\
    \ released when the function returns. (Where upon the parameter's scope ends and\
    \ its destructor is called.)</p><p>Because the idiom repeats no code, we cannot\
    \ introduce bugs within the operator. Note that this means we are rid of the need\
    \ for a self-assignment check, allowing a single uniform implementation of <code>operator=</code>.\
    \ (Additionally, we no longer have a performance penalty on non-self-assignments.)</p><p>And\
    \ that is the copy-and-swap idiom.</p><h2>What about C++11?</h2><p>The next version\
    \ of C++, C++11, makes one very important change to how we manage resources: the\
    \ Rule of Three is now <strong>The Rule of Four</strong> (and a half). Why? Because\
    \ not only do we need to be able to copy-construct our resource, <a href=\"https://stackoverflow.com/questions/3106110/can-someone-please-explain-move-semantics-to-me\"\
    >we need to move-construct it as well</a>.</p><p>Luckily for us, this is easy:</p><pre><code>class\
    \ dumb_array{public:    // ...    // move constructor    dumb_array(dumb_array&amp;&amp;\
    \ other)        : dumb_array() // initialize via default constructor, C++11 only\
    \    {        swap(*this, other);    }    // ...};</code></pre><p>What's going\
    \ on here? Recall the goal of move-construction: to take the resources from another\
    \ instance of the class, leaving it in a state guaranteed to be assignable and\
    \ destructible.</p><p>So what we've done is simple: initialize via the default\
    \ constructor (a C++11 feature), then swap with <code>other</code>; we know a\
    \ default constructed instance of our class can safely be assigned and destructed,\
    \ so we know <code>other</code> will be able to do the same, after swapping.</p><p>(Note\
    \ that some compilers do not support constructor delegation; in this case, we\
    \ have to manually default construct the class. This is an unfortunate but luckily\
    \ trivial task.)</p><h3>Why does that work?</h3><p>That is the only change we\
    \ need to make to our class, so why does it work? Remember the ever-important\
    \ decision we made to make the parameter a value and not a reference:</p><pre><code>dumb_array&amp;\
    \ operator=(dumb_array other); // (1)</code></pre><p>Now, if <code>other</code>\
    \ is being initialized with an rvalue, <em>it will be move-constructed</em>. Perfect.\
    \ In the same way C++03 let us re-use our copy-constructor functionality by taking\
    \ the argument by-value, C++11 will <em>automatically</em> pick the move-constructor\
    \ when appropriate as well. (And, of course, as mentioned in previously linked\
    \ article, the copying/moving of the value may simply be elided altogether.)</p><p>And\
    \ so concludes the copy-and-swap idiom.</p><hr/><h3>Footnotes</h3><p>*Why do we\
    \ set <code>mArray</code> to null? Because if any further code in the operator\
    \ throws, the destructor of <code>dumb_array</code> might be called; and if that\
    \ happens without setting it to null, we attempt to delete memory that's already\
    \ been deleted! We avoid this by setting it to null, as deleting null is a no-operation.</p><p>†There\
    \ are other claims that we should specialize <code>std::swap</code> for our type,\
    \ provide an in-class <code>swap</code> along-side a free-function <code>swap</code>,\
    \ etc. But this is all unnecessary: any proper use of <code>swap</code> will be\
    \ through an unqualified call, and our function will be found through <a href=\"\
    http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\" rel=\"noreferrer\"\
    >ADL</a>. One function will do.</p><p>‡The reason is simple: once you have the\
    \ resource to yourself, you may swap and/or move it (C++11) anywhere it needs\
    \ to be. And by making the copy in the parameter list, you maximize optimization.</p></div>"
- - What is the copy-and-swap idiom?
  - "<div class=\"post-text\" itemprop=\"text\"><p>Assignment, at its heart, is two\
    \ steps: <strong><em>tearing down the object's old state</em></strong> and <strong><em>building\
    \ its new state as a copy</em></strong> of some other object's state. </p><p>Basically,\
    \ that's what the <strong><em>destructor</em></strong> and the <strong><em>copy\
    \ constructor</em></strong> do, so the first idea would be to delegate the work\
    \ to them. However, since destruction mustn't fail, while construction might,\
    \ <em>we actually want to do it the other way around</em>: <strong><em>first perform\
    \ the constructive part</em></strong> and if that succeeded, <strong><em>then\
    \ do the destructive part</em></strong>. The copy-and-swap idiom is a way to do\
    \ just that: It first calls a class' copy constructor to create a temporary, then\
    \ swaps its data with the temporary's, and then lets the temporary's destructor\
    \ destroy the old state.<br/>Since <code>swap()</code> is supposed to never fail,\
    \ the only part which might fail is the copy-construction. That is performed first,\
    \ and if it fails, nothing will be changed in the targeted object. </p><p>In its\
    \ refined form, copy-and-swap is implemented by having the copy performed by initializing\
    \ the (non-reference) parameter of the assignment operator: </p><pre><code>T&amp;\
    \ operator=(T tmp){    this-&gt;swap(tmp);    return *this;}</code></pre></div>"
- - What is the copy-and-swap idiom?
  - "<div class=\"post-text\" itemprop=\"text\"><p>There are some good answers already.\
    \  I'll focus <em>mainly</em> on what I think they lack - an explanation of the\
    \ \"cons\" with the copy-and-swap idiom....</p><blockquote><p>What is the copy-and-swap\
    \ idiom?</p></blockquote><p>A way of implementing the assignment operator in terms\
    \ of a swap function:</p><pre><code>X&amp; operator=(X rhs){    swap(rhs);   \
    \ return *this;}</code></pre><p>The fundamental idea is that:</p><ul><li><p>the\
    \ most error-prone part of assigning to an object is ensuring any resources the\
    \ new state needs are acquired (e.g. memory, descriptors)</p></li><li><p>that\
    \ acquisition can be attempted <em>before</em> modifying the current state of\
    \ the object (i.e. <code>*this</code>) if a copy of the new value is made, which\
    \ is why <code>rhs</code> is accepted <em>by value</em> (i.e. copied) rather than\
    \ <em>by reference</em></p></li><li><p>swapping the state of the local copy <code>rhs</code>\
    \ and <code>*this</code> is <em>usually</em> relatively easy to do without potential\
    \ failure/exceptions, given the local copy doesn't need any particular state afterwards\
    \ (just needs state fit for the destructor to run, much as for an object being\
    \ <em>moved</em> from in &gt;= C++11)</p></li></ul><blockquote><p>When should\
    \ it be used?  (Which problems does it solve <strong>[/create]</strong>?)</p></blockquote><ul><li><p>When\
    \ you want the assigned-to objected unaffected by an assignment that throws an\
    \ exception, assuming you have or can write a <code>swap</code> with strong exception\
    \ guarantee, and ideally one that can't fail/<code>throw</code>..†</p></li><li><p>When\
    \ you want a clean, easy to understand, robust way to define the assignment operator\
    \ in terms of (simpler) copy constructor, <code>swap</code> and destructor functions.</p><ul><li>Self-assignment\
    \ done as a copy-and-swap avoids oft-overlooked edge cases.‡<p></p></li></ul></li><li>When\
    \ any performance penalty or momentarily higher resource usage created by having\
    \ an extra temporary object during the assignment is not important to your application.\
    \ ⁂</li></ul><hr/><p>† <code>swap</code> throwing: it's generally possible to\
    \ reliably swap data members that the objects track by pointer, but non-pointer\
    \ data members that don't have a throw-free swap, or for which swapping has to\
    \ be implemented as <code>X tmp = lhs; lhs = rhs; rhs = tmp;</code> and copy-construction\
    \ or assignment may throw, still have the potential to fail leaving some data\
    \ members swapped and others not.  This potential applies even to C++03 <code>std::string</code>'s\
    \ as James comments on another answer:</p><blockquote><p>@wilhelmtell: In C++03,\
    \ there is no mention of exceptions potentially thrown by std::string::swap (which\
    \ is called by std::swap). In C++0x, std::string::swap is noexcept and must not\
    \ throw exceptions. – James McNellis Dec 22 '10 at 15:24 </p></blockquote><hr/><p>‡\
    \ assignment operator implementation that seems sane when assigning from a distinct\
    \ object can easily fail for self-assignment.  While it might seem unimaginable\
    \ that client code would even attempt self-assignment, it can happen relatively\
    \ easily during algo operations on containers, with <code>x = f(x);</code> code\
    \ where <code>f</code> is (perhaps only for some <code>#ifdef</code> branches)\
    \ a macro ala <code>#define f(x) x</code> or a function returning a reference\
    \ to <code>x</code>, or even (likely inefficient but concise) code like <code>x\
    \ = c1 ? x * 2 : c2 ? x / 2 : x;</code>).  For example:</p><pre><code>struct X{\
    \    T* p_;    size_t size_;    X&amp; operator=(const X&amp; rhs)    {      \
    \  delete[] p_;  // OUCH!        p_ = new T[size_ = rhs.size_];        std::copy(p_,\
    \ rhs.p_, rhs.p_ + rhs.size_);    }    ...};</code></pre><p>On self-assignment,\
    \ the above code delete's <code>x.p_;</code>, points <code>p_</code> at a newly\
    \ allocated heap region, then attempts to read the <em>uninitialised</em> data\
    \ therein (Undefined Behaviour), if that doesn't do anything too weird, <code>copy</code>\
    \ attempts a self-assignment to every just-destructed 'T'!</p><hr/><p>⁂ The copy-and-swap\
    \ idiom can introduce inefficiencies or limitations due to the use of an extra\
    \ temporary (when the operator's parameter is copy-constructed):</p><pre><code>struct\
    \ Client{    IP_Address ip_address_;    int socket_;    X(const X&amp; rhs)  \
    \    : ip_address_(rhs.ip_address_), socket_(connect(rhs.ip_address_))    { }};</code></pre><p>Here,\
    \ a hand-written <code>Client::operator=</code> might check if <code>*this</code>\
    \ is already connected to the same server as <code>rhs</code> (perhaps sending\
    \ a \"reset\" code if useful), whereas the copy-and-swap approach would invoke\
    \ the copy-constructor which would likely be written to open a distinct socket\
    \ connection then close the original one.  Not only could that mean a remote network\
    \ interaction instead of a simple in-process variable copy, it could run afoul\
    \ of client or server limits on socket resources or connections.  (Of course this\
    \ class has a pretty horrid interface, but that's another matter ;-P).</p></div>"
- - C++11 introduced a standardized memory model. What does it mean? And how is it
    going to affect C++ programming?
  - <div class="post-text" itemprop="text"><p>First, you have to learn to think like
    a Language Lawyer.</p><p>The C++ specification does not make reference to any
    particular compiler, operating system, or CPU.  It makes reference to an <em>abstract
    machine</em> that is a generalization of actual systems.  In the Language Lawyer
    world, the job of the programmer is to write code for the abstract machine; the
    job of the compiler is to actualize that code on a concrete machine.  By coding
    rigidly to the spec, you can be certain that your code will compile and run without
    modification on any system with a compliant C++ compiler, whether today or 50
    years from now.</p><p>The abstract machine in the C++98/C++03 specification is
    fundamentally single-threaded.  So it is not possible to write multi-threaded
    C++ code that is "fully portable" with respect to the spec.  The spec does not
    even say anything about the <em>atomicity</em> of memory loads and stores or the
    <em>order</em> in which loads and stores might happen, never mind things like
    mutexes.</p><p>Of course, you can write multi-threaded code in practice for particular
    concrete systems – like pthreads or Windows.  But there is no <em>standard</em>
    way to write multi-threaded code for C++98/C++03.</p><p>The abstract machine in
    C++11 is multi-threaded by design.  It also has a well-defined <em>memory model</em>;
    that is, it says what the compiler may and may not do when it comes to accessing
    memory.</p><p>Consider the following example, where a pair of global variables
    are accessed concurrently by two threads:</p><pre><code>           Global           int
    x, y;Thread 1            Thread 2x = 17;             cout &lt;&lt; y &lt;&lt;
    " ";y = 37;             cout &lt;&lt; x &lt;&lt; endl;</code></pre><p>What might
    Thread 2 output?</p><p>Under C++98/C++03, this is not even Undefined Behavior;
    the question itself is <em>meaningless</em> because the standard does not contemplate
    anything called a "thread".</p><p>Under C++11, the result is Undefined Behavior,
    because loads and stores need not be atomic in general.  Which may not seem like
    much of an improvement...  And by itself, it's not.</p><p>But with C++11, you
    can write this:</p><pre><code>           Global           atomic&lt;int&gt; x,
    y;Thread 1                 Thread 2x.store(17);             cout &lt;&lt; y.load()
    &lt;&lt; " ";y.store(37);             cout &lt;&lt; x.load() &lt;&lt; endl;</code></pre><p>Now
    things get much more interesting.  First of all, the behavior here is <em>defined</em>.  Thread
    2 could now print <code>0 0</code> (if it runs before Thread 1), <code>37 17</code>
    (if it runs after Thread 1), or <code>0 17</code> (if it runs after Thread 1 assigns
    to x but before it assigns to y).</p><p>What it cannot print is <code>37 0</code>,
    because the default mode for atomic loads/stores in C++11 is to enforce <em>sequential
    consistency</em>.  This just means all loads and stores must be "as if" they happened
    in the order you wrote them within each thread, while operations among threads
    can be interleaved however the system likes.  So the default behavior of atomics
    provides both <em>atomicity</em> and <em>ordering</em> for loads and stores.</p><p>Now,
    on a modern CPU, ensuring sequential consistency can be expensive.  In particular,
    the compiler is likely to emit full-blown memory barriers between every access
    here.  But if your algorithm can tolerate out-of-order loads and stores; i.e.,
    if it requires atomicity but not ordering; i.e., if it can tolerate <code>37 0</code>
    as output from this program, then you can write this:</p><pre><code>           Global           atomic&lt;int&gt;
    x, y;Thread 1                            Thread 2x.store(17,memory_order_relaxed);   cout
    &lt;&lt; y.load(memory_order_relaxed) &lt;&lt; " ";y.store(37,memory_order_relaxed);   cout
    &lt;&lt; x.load(memory_order_relaxed) &lt;&lt; endl;</code></pre><p>The more modern
    the CPU, the more likely this is to be faster than the previous example.</p><p>Finally,
    if you just need to keep particular loads and stores in order, you can write:</p><pre><code>           Global           atomic&lt;int&gt;
    x, y;Thread 1                            Thread 2x.store(17,memory_order_release);   cout
    &lt;&lt; y.load(memory_order_acquire) &lt;&lt; " ";y.store(37,memory_order_release);   cout
    &lt;&lt; x.load(memory_order_acquire) &lt;&lt; endl;</code></pre><p>This takes
    us back to the ordered loads and stores – so <code>37 0</code> is no longer a
    possible output – but it does so with minimal overhead.  (In this trivial example,
    the result is the same as full-blown sequential consistency; in a larger program,
    it would not be.)</p><p>Of course, if the only outputs you want to see are <code>0
    0</code> or <code>37 17</code>, you can just wrap a mutex around the original
    code.  But if you have read this far, I bet you already know how that works, and
    this answer is already longer than I intended :-).</p><p>So, bottom line. Mutexes
    are great, and C++11 standardizes them. But sometimes for performance reasons
    you want lower-level primitives (e.g., the classic <a href="http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-6-double-checked-locking.html"
    rel="noreferrer">double-checked locking pattern</a>).  The new standard provides
    high-level gadgets like mutexes and condition variables, and it also provides
    low-level gadgets like atomic types and the various flavors of memory barrier.  So
    now you can write sophisticated, high-performance concurrent routines entirely
    within the language specified by the standard, and you can be certain your code
    will compile and run unchanged on both today's systems and tomorrow's.</p><p>Although
    to be frank, unless you are an expert and working on some serious low-level code,
    you should probably stick to mutexes and condition variables.  That's what I intend
    to do.</p><p>For more on this stuff, see <a href="http://bartoszmilewski.wordpress.com/2008/12/01/c-atomics-and-memory-ordering/"
    rel="noreferrer">this blog post</a>.</p></div>
- - C++11 introduced a standardized memory model. What does it mean? And how is it
    going to affect C++ programming?
  - "<div class=\"post-text\" itemprop=\"text\"><p>I will just give the analogy with\
    \ which I understand memory consistency models (or memory models, for short).\
    \ It is inspired by Leslie Lamport's seminal paper <a href=\"http://dl.acm.org/citation.cfm?id=359545.359563\"\
    \ rel=\"noreferrer\">\"Time, Clocks, and the Ordering of Events in a Distributed\
    \ System\"</a>.The analogy is apt and has fundamental significance, but may be\
    \ overkill for many people. However, I hope it provides a mental image (a pictorial\
    \ representation) that facilitates reasoning about memory consistency models.</p><p>Let’s\
    \ view the histories of all memory locations in a space-time diagram in which\
    \ the horizontal axis represents the address space (i.e., each memory location\
    \ is represented by a point on that axis) and the vertical axis represents time\
    \ (we will see that, in general, there is not a universal notion of time). The\
    \ history of values held by each memory location is, therefore, represented by\
    \ a vertical column at that memory address. Each value change is due to one of\
    \ the threads writing a new value to that location. By a <strong><em>memory image</em></strong>,\
    \ we will mean the aggregate/combination of values of all memory locations observable\
    \ <strong><em>at a particular time</em></strong> by <strong><em>a particular thread</em></strong>.</p><p>Quoting\
    \ from <a href=\"http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016\"\
    \ rel=\"noreferrer\">\"A Primer on Memory Consistency and Cache Coherence\"</a></p><blockquote><p>The\
    \ intuitive (and most restrictive) memory model is sequential consistency (SC)\
    \ in which a multithreaded execution should look like an interleaving of the sequential\
    \ executions of each constituent thread, as if the threads were time-multiplexed\
    \ on a single-core processor.</p></blockquote><p>That global memory order can\
    \ vary from one run of the program to another and may not be known beforehand.\
    \ The characteristic feature of SC is the set of horizontal slices in the address-space-time\
    \ diagram representing <strong><em>planes of simultaneity</em></strong> (i.e.,\
    \ memory images). On a given plane, all of its events (or memory values) are simultaneous.\
    \ There is a notion of <em>Absolute Time</em>, in which all threads agree on which\
    \ memory values are simultaneous. In SC, at every time instant, there is only\
    \ one memory image shared by all threads. That's, at every instant of time, all\
    \ processors agree on the memory image (i.e., the aggregate content of memory).\
    \ Not only does this imply that all threads view the same sequence of values for\
    \ all memory locations, but also that all processors observe the same <em>combinations\
    \ of values</em> of all variables. This is the same as saying all memory operations\
    \ (on all memory locations) are observed in the same total order by all threads.</p><p>In\
    \ relaxed memory models, each thread will slice up address-space-time in its own\
    \ way, the only restriction being that slices of each thread shall not cross each\
    \ other because all threads must agree on the history of every individual memory\
    \ location (of course, slices of different threads may, and will, cross each other).\
    \ There is no universal way to slice it up (no privileged foliation of address-space-time).\
    \ Slices do not have to be planar (or linear). They can be curved and this is\
    \ what can make a thread read values written by another thread out of the order\
    \ they were written in. Histories of different memory locations may slide (or\
    \ get stretched) arbitrarily relative to each other <strong><em>when viewed by\
    \ any particular thread</em></strong>. Each thread will have a different sense\
    \ of which events (or, equivalently, memory values) are simultaneous. The set\
    \ of events (or memory values) that are simultaneous to one thread are not simultaneous\
    \ to another. Thus, in a relaxed memory model, all threads still observe the same\
    \ history (i.e., sequence of values) for each memory location. But they may observe\
    \ different memory images (i.e., combinations of values of all memory locations).\
    \ Even if two different memory locations are written by the same thread in sequence,\
    \ the two newly written values may be observed in different order by other threads.</p><p>[Picture\
    \ from Wikipedia]<img alt=\"Picture from Wikipedia\" src=\"https://upload.wikimedia.org/wikipedia/commons/f/f1/Relsim2.GIF\"\
    /></p><p>Readers familiar with Einstein’s <strong>Special Theory of Relativity</strong>\
    \ will notice what I am alluding to. Translating Minkowski’s words into the memory\
    \ models realm: address space and time are shadows of address-space-time. In this\
    \ case, each observer (i.e., thread) will project shadows of events (i.e., memory\
    \ stores/loads) onto his own world-line (i.e., his time axis) and his own plane\
    \ of simultaneity (his address-space axis). Threads in the C++11 memory model\
    \ correspond to <strong><em>observers</em></strong> that are moving relative to\
    \ each other in special relativity. Sequential consistency corresponds to the\
    \ <strong>Galilean space-time</strong> (i.e., all observers agree on one absolute\
    \ order of events and a global sense of simultaneity).</p><p>The resemblance between\
    \ memory models and special relativity stems from the fact that both define a\
    \ partially-ordered set of events, often called a causal set. Some events (i.e.,\
    \ memory stores) can affect (but not be affected by) other events. A C++11 thread\
    \ (or observer in physics) is no more than a chain (i.e., a totally ordered set)\
    \ of events (e.g., memory loads and stores to possibly different addresses).</p><p>In\
    \ relativity, some order is restored to the seemingly chaotic picture of partially\
    \ ordered events, since the only temporal ordering that all observers agree on\
    \ is the ordering among “timelike” events (i.e., those events that are in principle\
    \ connectible by any particle going slower than the speed of light in a vacuum).\
    \ Only the timelike related events are invariantly ordered.<a href=\"http://philosophyfaculty.ucsd.edu/faculty/ccallender/index.html\"\
    \ rel=\"noreferrer\">Time in Physics, Craig Callender</a>.</p><p>In C++11 memory\
    \ model, a similar mechanism (the acquire-release consistency model) is used to\
    \ establish these <strong><em>local causality relations</em></strong>.</p><p>To\
    \ provide a definition of memory consistency and a motivation for abandoning SC,\
    \ I will quote from <a href=\"http://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC016\"\
    \ rel=\"noreferrer\">\"A Primer on Memory Consistency and Cache Coherence\"</a></p><blockquote><p>For\
    \ a shared memory machine, the memory consistency model defines the architecturally\
    \ visible behavior of its memory system. The correctness criterion for a single\
    \ processor core partitions behavior between “<em>one correct result</em>” and\
    \ “<em>many incorrect alternatives</em>”. This is because the processor’s architecture\
    \ mandates that the execution of a thread transforms a given input state into\
    \ a single well-defined output state, even on an out-of-order core. Shared memory\
    \ consistency models, however, concern the loads and stores of multiple threads\
    \ and usually allow <em>many correct executions</em> while disallowing many (more)\
    \ incorrect ones. The possibility of multiple correct executions is due to the\
    \ ISA allowing multiple threads to execute concurrently, often with many possible\
    \ legal interleavings of instructions from different threads.</p><p><strong><em>Relaxed</em></strong>\
    \ or <strong><em>weak</em></strong> memory consistency models are motivated by\
    \ the fact that most memory orderings in strong models are unnecessary. If a thread\
    \ updates ten data items and then a synchronization flag, programmers usually\
    \ do not care if the data items are updated in order with respect to each other\
    \ but only that all data items are updated before the flag is updated (usually\
    \ implemented using FENCE instructions). Relaxed models seek to capture this increased\
    \ ordering flexibility and preserve only the orders that programmers “<em>require</em>”\
    \ to get both higher performance and correctness of SC. For example, in certain\
    \ architectures, FIFO write buffers are used by each core to hold the results\
    \ of committed (retired) stores before writing the results to the caches. This\
    \ optimization enhances performance but violates SC. The write buffer hides the\
    \ latency of servicing a store miss. Because stores are common, being able to\
    \ avoid stalling on most of them is an important benefit. For a single-core processor,\
    \ a write buffer can be made architecturally invisible by ensuring that a load\
    \ to address A returns the value of the most recent store to A even if one or\
    \ more stores to A are in the write buffer. This is typically done by either bypassing\
    \ the value of the most recent store to A to the load from A, where “most recent”\
    \ is determined by program order, or by stalling a load of A if a store to A is\
    \ in the write buffer. When multiple cores are used, each will have its own bypassing\
    \ write buffer. Without write buffers, the hardware is SC, but with write buffers,\
    \ it is not, making write buffers architecturally visible in a multicore processor.</p><p>Store-store\
    \ reordering may happen if a core has a non-FIFO write buffer that lets stores\
    \ depart in a different order than the order in which they entered. This might\
    \ occur if the first store misses in the cache while the second hits or if the\
    \ second store can coalesce with an earlier store (i.e., before the first store).\
    \ Load-load reordering may also happen on dynamically-scheduled cores that execute\
    \ instructions out of program order. That can behave the same as reordering stores\
    \ on another core (Can you come up with an example interleaving between two threads?).\
    \ Reordering an earlier load with a later store (a load-store reordering) can\
    \ cause many incorrect behaviors, such as loading a value after releasing the\
    \ lock that protects it (if the store is the unlock operation). Note that store-load\
    \ reorderings may also arise due to local bypassing in the commonly implemented\
    \ FIFO write buffer, even with a core that executes all instructions in program\
    \ order.</p></blockquote><p>Because cache coherence and memory consistency are\
    \ sometimes confused, it is instructive to also have this quote:</p><blockquote><p>Unlike\
    \ consistency, <strong><em>cache coherence</em></strong> is neither visible to\
    \ software nor required. Coherence seeks to make the caches of a shared-memory\
    \ system as functionally invisible as the caches in a single-core system. Correct\
    \ coherence ensures that a programmer cannot determine whether and where a system\
    \ has caches by analyzing the results of loads and stores. This is because correct\
    \ coherence ensures that the caches never enable new or different <strong><em>functional</em></strong>\
    \ behavior (programmers may still be able to infer likely cache structure using\
    \ <strong><em>timing</em></strong> information). The main purpose of cache coherence\
    \ protocols is maintaining the single-writer-multiple-readers (SWMR) invariant\
    \ for every memory location.  An important distinction between coherence and consistency\
    \ is that coherence is specified on a <strong><em>per-memory location basis</em></strong>,\
    \ whereas consistency is specified with respect to <strong><em>all</em></strong>\
    \ memory locations.</p></blockquote><p>Continuing with our mental picture, the\
    \ SWMR invariant corresponds to the physical requirement that there be at most\
    \ one particle located at any one location but there can be an unlimited number\
    \ of observers of any location.</p></div>"
- - C++11 introduced a standardized memory model. What does it mean? And how is it
    going to affect C++ programming?
  - "<div class=\"post-text\" itemprop=\"text\"><p><sub>This is now a multiple-year\
    \ old question, but being very popular, it's worth mentioning a fantastic resource\
    \ for learning about the C++11 memory model. I see no point in summing up his\
    \ talk in order to make this yet another full answer, but given this is the guy\
    \ who actually wrote the standard, I think it's well worth watching the talk.</sub></p><p>Herb\
    \ Sutter has a three hour long talk about the C++11 memory model titled \"atomic&lt;&gt;\
    \ Weapons\", available on the Channel9 site - <a href=\"http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-1-of-2\"\
    \ rel=\"noreferrer\">part 1</a> and <a href=\"http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Herb-Sutter-atomic-Weapons-2-of-2\"\
    \ rel=\"noreferrer\">part 2</a>. The talk is pretty technical, and covers the\
    \ following topics:</p><ol><li>Optimizations, Races, and the Memory Model</li><li>Ordering\
    \ – What: Acquire and Release</li><li>Ordering – How: Mutexes, Atomics, and/or\
    \ Fences</li><li>Other Restrictions on Compilers and Hardware</li><li>Code Gen\
    \ &amp; Performance: x86/x64, IA64, POWER, ARM</li><li>Relaxed Atomics</li></ol><p>The\
    \ talk doesn't elaborate on the API, but rather on the reasoning, background,\
    \ under the hood and behind the scenes (did you know relaxed semantics were added\
    \ to the standard only because POWER and ARM do not support synchronized load\
    \ efficiently?).</p></div>"
